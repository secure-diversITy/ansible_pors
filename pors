#!/bin/bash
########################################################################################
## @file	pors.sh
## @brief       PORS is an UI for managing your whole Splunk infrastructure with Ansible
## @author	Thomas Fischer <mail -AT- sedi -DOT- one>
## @date        2017-2023
## @copyright	AGPL v3
## @details     
##    This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU Affero General Public License as
##    published by the Free Software Foundation, either version 3 of the
##    License, or (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU Affero General Public License for more details.
##
##    You should have received a copy of the GNU Affero General Public License
##    along with this program.  If not, see <https://www.gnu.org/licenses/>.
##
########################################################################################
#
## @mainpage Playbooks-On-Rails for Splunk (PORS)
## @section intro Overview
## Playbooks-On-Rails for Splunk (PORS) is a wrapper and GUI (ncurses/dialog based) to execute several tasks with ansible.<br>
## This is a pure **technical** documentation of PORS for those who want to understand how it works under the hood
##
## @section code Code
## PORS is hosted at github:<br>
## https://github.com/secure-diversITy/ansible_pors
## 
## @section secintro User documentation
## Playbooks-On-Rails for Splunk (PORS) configuration and installation is described here: <br>
## https://github.com/secure-diversITy/ansible_pors/wiki
##<br>
###############################################################################################################
VERSIONTYPE=RC
VERSIONNUM="4.0-91"
VERSION="${VERSIONNUM}_${VERSIONTYPE}"
###############################################################################################################
#
# This script can be automatically documented by doxygen (http://doxygen.nl)
#
# There are a few things you have to do so though:
# - every var must be exported or declared to get identified properly
# - every function must start like that: "<name>(){ <EOL>" 
#   So func name, brackets and { must be all in the same line and you have to start code at the next line first.
# - bash advanced if-var-empty syntax like: ': "${DEFSPLAPIADMIN:=admin}"' won't get detected, 
#   use test -z and declare instead
#
# doxygen copy templates:
#
# # @var 
# # @brief 
# # @details 
#
# # @fn F_NAME()
# # @brief ..
# # @param 1 ..
# # @return ..
# # @exception ..
# # @details ..
##############################################################################################################

## @var NCURSES_NO_UTF8_ACS
## @brief ensure PuttY will not look ugly
export NCURSES_NO_UTF8_ACS=1

###############################################################################
# Do NOT change variables here! 
###############################################################################
# all user variables can and have to be set here:
#
# --> ${HOME}/.pors/vars
#
# init that file with:
# cp EXAMPLES/.pors_vars-example ${HOME}/.pors/vars
#
# then modify ${HOME}/.pors/vars to your needs
#
###############################################################################

# source an variable overwrite if available
[ -f ${HOME}/.pors/vars ] && source ${HOME}/.pors/vars

# DEBUG mode (1) or not (0)
: "${DEBUG:=0}"

[ $DEBUG -eq 1 ] && echo "DEBUG MODE ON !!!!"

## @var RUNMODE
## @brief PORS can run in several modes this sets the default
## @showinitializer
## @details There is *no* (!) need to touch this as it will be adjusted depending
## on the parameters how PORS is started (e.g. --batch will set batch mode)
export RUNMODE="interactive"

## @var OS_SERVICE_USER
## @brief An (optional) service account username
## @showinitializer
## @details This account will be added when installing a new VM only.
## So on a new VM deployment this user will be created and given root
## permissions. The if empty check must exists to make it appear in the doc..
[ -z "${OS_SERVICE_USER}" ] && \
export OS_SERVICE_USER=

## @var PYTHONUNBUFFERED
## @brief avoid buffering when exec python code (ansible)
## @showinitializer
## @details when python buffers output PORS seems to hang until the 
## whole playbook has been finished without any feedback. This ensures we see output directly in PORS.
export PYTHONUNBUFFERED=1

## @var BIN
## @brief auto generate the binary name without path
## @showinitializer
declare BIN=${0##*/}

## @var REQAVERSION
## @brief The minimal required Ansible version
## @details the version string in the format: X.x.x
## @showinitializer
declare REQAVERSION="2.8.0"

# ensure we run in a proper environment
if [ -z "$CALLUSR" ];then
    MYHOME=${HOME}/.$(echo ${BIN/.sh}|tr -d _)
else
    MYHOME=/tmp/pors-${CALLUSR}
fi

## @var WORKDIR
## @brief The working directory where all run files will be stored
## @details Every user has its own temp directory accessible only by the PORS user
## @showinitializer
declare WORKDIR="$MYHOME"
[ ! -d "$WORKDIR" ] && mkdir -p $WORKDIR
chown ${USER} $WORKDIR
chmod 755 $WORKDIR  

## @var ADIR
## @brief auto generate the path name of the bin
## @showinitializer
## @details the PORS install dir. can be overwritten in ~/.pors/vars 
[ -z "$ADIR" ] && \
declare ADIR="/opt/pors"

## @var DATADIR
## @brief the PORS data directory
## @showinitializer
## @details the PORS data dir. can be overwritten in ~/.pors/vars
[ -z "$DATADIR" ] && \
declare DATADIR="/opt/pors_data"

## @var ALOG
## @brief The PORS action log tracks any actions taken
## @showinitializer
## @details PORS action log. can be overwritten in ~/.pors/vars
[ -z "$ALOG" ] && \
declare ALOG="$DATADIR/audit/action.log"

## @var ALOGMAXMB
## @brief The PORS action log max size in MB before rotating
## @showinitializer
## @details can be overwritten in ~/.pors/vars
[ -z "$ALOGMAXMB" ] && \
declare ALOGMAXMB=10

## @var AINVENTORY
## @brief Ansible inventories directory
## @showinitializer
## @details the PORS inventories dir.
## the place where your Ansible inventories (with their subdirs like development, production) are in.
## also includes app links etc. should be overwritten in ~/.pors/vars for production use.
[ -z "$AINVENTORY" ] && \
declare AINVENTORY="$DATADIR/inventories"

## @var DEFAULTSYML
## @brief full path to roles/defaults/main.yml
## @showinitializer
declare DEFAULTSYML=${ADIR}/roles/defaults/main.yml

## @var KICKUSER
## @brief Default setting for overtaken a running session
## @showinitializer
## @details normally we want to have 1 instance running the same time. This avoids dozens of problems which could occur.
## The default when pressing just enter can be y (remove and take the lock) or N (quit)
declare KICKUSER=N

## @var APATH
## @brief The path to the regular ansible playbook binary
## @showinitializer
[ -z "$APATH" ] && \
declare APATH="/usr/bin"

## @var ABIN
## @brief The ansible playbook binary name
## @showinitializer
[ -z "$ABIN" ] && \
declare ABIN="$APATH/ansible-playbook"

## @var VBIN
## @brief The full path to the regular ansible-vault binary
## @showinitializer
[ -z "$VBIN" ] && \
declare VBIN="/usr/bin/ansible-vault"

## @var LOGDIR
## @brief The log directory
## @showinitializer
[ -z "$LOGDIR" ] && \
declare LOGDIR=${WORKDIR}/logs

## @var LOG
## @brief The log file
## @showinitializer
declare LOG=${LOGDIR}/$(date +%F_%H-%M)_${BIN}.log

## @var MAXLOG
## @brief How many log files are allowed before rotate starts
## @showinitializer
[ -z "$MAXLOG" ] && \
declare MAXLOG=7

## @var AEUSRHOSTFILE
## @brief the user choosen hostfile will be written into this file
## @details can be sourced like: source $AEUSRHOSTFILE - will set HOSTFILE=
## @showinitializer
declare AEUSRHOSTFILE=${WORKDIR}/ae_current_hostfile

## @var PLAYNOISE
## @brief Verbosity level of playbooks
## @details By default only basic output will be shown which can be increased by
## starting PORS with --verbose (equals to -vvv) or --debug (equals to -vvvv)
## Do not change this value here. If you want to override the default setting here
## adjust the ~/.pors/vars file instead
## @showinitializer
[ -z "$PLAYNOISE" ] && \
declare PLAYNOISE="-vv"

## @var EDITBIN
## @brief The editor which will be used e.g. when editing system/local files
## @details Can be overwritten by ~/.pors/vars
## @showinitializer
[ -z "$EDITBIN" ] && \
declare EDITBIN=/usr/bin/vim

## @var PBDIR
## @brief The directory where all playbooks are expected (base path)
## @details Can be overwritten by ~/.pors/vars
## @showinitializer
[ -z "$PBDIR" ] && \
declare PBDIR="$ADIR/playbooks"

## @var PBDIRCRIBL
## @brief The directory where all CRIBL playbooks are expected
## @details playbooks for CRIBL logstream
## @showinitializer
[ -z "$PBDIRCRIBL" ] && \
declare PBDIRCRIBL="$PBDIR/cribl"

## @var PBDIRSHELPER
## @brief The directory where all shelper playbooks are expected
## @details playbooks for splunk shelper
## @showinitializer
[ -z "$PBDIRSHELPER" ] && \
declare PBDIRSHELPER="$PBDIR/shelper"

## @var PBDIRSPLUNK
## @brief The directory where all splunk playbooks are expected
## @details playbooks for splunk
## @showinitializer
[ -z "$PBDIRSPLUNK" ] && \
declare PBDIRSPLUNK="$PBDIR/splunk"

## @var PBDIRVMWARE
## @brief The directory where all vmware playbooks are expected
## @details playbooks for VMware
## @showinitializer
[ -z "$PBDIRVMWARE" ] && \
declare PBDIRVMWARE="$PBDIR/vmware"

## @var PBDIRSYSTEM
## @brief The directory where all system playbooks are expected
## @details playbooks for System
## @showinitializer
[ -z "$PBDIRSYSTEM" ] && \
declare PBDIRSYSTEM="$PBDIR/system"

## @var PBDIRGOOGLECP
## @brief The directory where all GCP playbooks are expected
## @details playbooks for Google Cloud Platform (GCP)
## @showinitializer
[ -z "$PBDIRGOOGLECP" ] && \
declare PBDIRGOOGLECP="$PBDIR/googlecp"

## @var PBDIRPROXMOX
## @brief The directory where all PVE playbooks are expected
## @details playbooks for Proxmox VE (PVE)
## @showinitializer
[ -z "$PBDIRPROXMOX" ] && \
declare PBDIRPROXMOX="$PBDIR/proxmox"

## @var PBDIRLOCAL
## @brief playbooks for local (i.e. ansible) itself
## @details The directory where all local playbooks (usually ansible related) are expected 
## @showinitializer
[ -z "$PBDIRLOCAL" ] && \
declare PBDIRLOCAL="$PBDIR/local"

## @var ROLEDIR
## @brief The directory where all roles are expected
## @details Can be overwritten by ~/.pors/vars
## @showinitializer
[ -z "$ROLEDIR" ] && \
declare ROLEDIR="$ADIR/roles"

## @var PBENAPP
## @brief Adding/Linking new app(s) to PORS
## @showinitializer
declare PBENAPP=${PBDIRSPLUNK}/ae_enable_app.yml

## @var PBREGENDEPLOY
## @brief Regenerate ae_deploy_apps.yml
## @showinitializer
## @details This playbook generates $PBDEPLAPP based on the linked apps<-->targets
declare PBREGENDEPLOY=${PBDIRSPLUNK}/ae_recreate_deploy.yml

## @var PBDEPLAPP
## @brief Deploy apps to given targets
## @showinitializer
## @details This playbook gets autogenerated when running $PBREGENDEPLOY
declare PBDEPLAPP=ae_deploy_apps.yml

## @var PBDEPLSYSC
## @brief Deploy system/local configs to given targets 
## @showinitializer
declare PBDEPLSYSC=${PBDIRSPLUNK}/ae_deploy_systemconfigs.yml

## @var PBGETTARGETS
## @brief Parsing inventories file and create an expanded host list for each target
## @showinitializer
declare PBGETTARGETS=${PBDIRSPLUNK}/ae_get_targets.yml

## @var PBUPGRADE
## @brief Upgrade splunk
## @showinitializer
declare PBUPGRADE=${PBDIRSPLUNK}/ae_upgrade_splunk.yml

## @var  PBSHINSTALL
## @brief Install/Upgrade the splunk helper
## @details https://github.com/secure-diversITy/splunk/tree/master/splunkhelper
## @showinitializer
declare PBSHINSTALL=${PBDIRSHELPER}/ae_install_shelper.yml

## @var SHOWAPPS
## @brief Show app deployment state by target(s) and type (local, git, ...)
## @showinitializer
declare SHOWAPPS=${ADIR}/ae_show_app_deploymentstate.sh

## @var PBSHRELOAD
## @brief Execute splunk helper tasks
## @details https://github.com/secure-diversITy/splunk/tree/master/splunkhelper
## @showinitializer
declare PBSHRELOAD=${PBDIRSYSTEM}/ae_shelper_reload.yml

## @var PBSPLACT
## @brief Maintenance tasks for splunk
## @details Examples: splunk stop, start, restart
## @showinitializer
declare PBSPLACT=${PBDIRSPLUNK}/splunk_actions.yml

## @var PBINSTALL
## @brief Install splunk
## @details Will install splunk on a single host or group of hosts
## @showinitializer
declare PBINSTALL=${PBDIRSPLUNK}/ae_install_splunk.yml

## @var PBINSTALLLOGSTREAM
## @brief Install cribl logstream
## @details Will install cribl logstream on a single host or group of hosts
## @showinitializer
declare PBINSTALLLOGSTREAM=${PBDIRCRIBL}/ae_install_logstream.yml

## @var PBCONFLOGSTREAM
## @brief Configure cribl logstream
## @details Will configure cribl logstream on a single host or group of hosts
## @showinitializer
declare PBCONFLOGSTREAM=${PBDIRCRIBL}/configure_logstream.yml

## @var PBUPGRADELOGSTREAM
## @brief Upgrade cribl logstream
## @details Will upgrade cribl logstream on a single host or group of hosts
## @showinitializer
declare PBUPGRADELOGSTREAM=${PBDIRCRIBL}/ae_upgrade_logstream.yml

## @var PBCONFMN
## @brief Configures splunk as a master node
## @details This will configure an existing splunk installation as a MasterNode for a new cluster
## @showinitializer
declare PBCONFMN=${PBDIRSPLUNK}/ae_configure_masternode.yml

## @var PBCONFLM
## @brief Configures splunk as a license master
## @details This will configure an existing splunk installation as a LicenseMaster
## @showinitializer
declare PBCONFLM=${PBDIRSPLUNK}/configure_licensemaster.yml

## @var PBCONFDS
## @brief Configures splunk as a deploymentserver
## @details This will configure an existing splunk installation as a DeploymentServer
## @showinitializer
declare PBCONFDS=${PBDIRSPLUNK}/configure_deploymentserver.yml

## @var PBCONFMC
## @brief Configures splunk as a Monitoring Console
## @details This will configure an existing splunk installation as a MonitoringConsole
## @showinitializer
declare PBCONFMC=${PBDIRSPLUNK}/configure_monitoringconsole.yml

## @var PBDEPLMONKEY
## @brief Deploys the MonitoringConsole key for monitoring given targets
## @showinitializer
declare PBDEPLMONKEY=${PBDIRSPLUNK}/deploy_monitoringkeys.yml

## @var PBCONFMONROLES
## @brief (Re-)configure the MonitoringConsole roles
## @showinitializer
declare PBCONFMONROLES=${PBDIRSPLUNK}/configure_monitoringroles.yml

## @var PBCONFPEER
## @brief Configures splunk as a peernode 
## @details This will configure an existing splunk installation as a peernode of an existing indexer cluster
## @showinitializer
declare PBCONFPEER=${PBDIRSPLUNK}/ae_configure_ix_peernode.yml

## @var PBCONFSHCM
## @brief Configures splunk as a SHC member
## @details This will configure an existing splunk installation as a SHC member
## @showinitializer
declare PBCONFSHCM=${PBDIRSPLUNK}/configure_shcmember.yml

## @var PBCONFSH
## @brief Configures splunk as a searchhead
## @details This will configure an existing splunk installation as a SearchHead
## @showinitializer
declare PBCONFSH=${PBDIRSPLUNK}/ae_configure_searchhead.yml

## @var PBCONFDEP
## @brief Configures splunk as a SHC deployer
## @details This will configure an existing splunk installation as a Deployer
## @showinitializer
declare PBCONFDEP=${PBDIRSPLUNK}/configure_deployer.yml

## @var PBCONFHF
## @brief Configures splunk as a heavy forwarder
## @details This will configure an existing splunk installation as a Heavy Forwarder
## @showinitializer
declare PBCONFHF=${PBDIRSPLUNK}/ae_configure_heavyforwarder.yml

## @var INSTDEF
## @brief splunk installation conf
## @details Used to configure several splunk installation relevant stuff like tgz/rpm/version etc
## @showinitializer
declare INSTDEF=splunk_installation.yml

## @var PBDLSPL
## @brief Downloader for splunk tar's
## @details Will download a defined splunk release (hard coded type: linux/64bit/tar.gz) directly from splunk
## @showinitializer
declare PBDLSPL=${PBDIRSPLUNK}/ae_download_splunk.yml 

## @var INSTDEFLS
## @brief cribl logstream installation conf
## @showinitializer
declare INSTDEFLS=logstream_installation.yml

## @var PBDLLOGSTREAM
## @brief Downloader for cribl logstream
## @details Will download a defined logstream release directly from cribl
## @showinitializer
declare PBDLLOGSTREAM=${PBDIRCRIBL}/ae_download_logstream.yml

## @var PBGHFETCHREPOS
## @brief Fetch all accessible github repos
## @details Will connect to the defined repo server and fetches all repository locations (http or ssh - as defined)
## @showinitializer
declare PBGHFETCHREPOS="${PBDIRSPLUNK}/github_get_repos.yml"

## @var PBGLFETCHREPOS
## @brief Fetch all accessible gitlab repos
## @details Will connect to the defined repo server and fetches all repository locations (http or ssh - as defined)
## @showinitializer
declare PBGLFETCHREPOS="${PBDIRSPLUNK}/gitlab_get_repos.yml"

## @var PBVCINFO
## @brief Collecting vCenter information
## @details Will connect to a vCenter and grabs all relevant information for VM deployment
## @showinitializer
declare PBVCINFO="${PBDIRVMWARE}/vcenter_get-info.yml"

## @var PBVCGETVHOSTSTATES
## @brief Collecting / Refreshing vhost conenction states
## @details Will connect to a vCenter and re-evaluates the states for each connected vhost (ESX)
## @showinitializer
declare PBVCGETVHOSTSTATES="${PBDIRVMWARE}/vcenter_get-vhoststates.yml"

## @var PBVCVMDEPLOY
## @brief Deploys a VM over a given vCenter to a ESX host
## @details Will connect to a vCenter and deploys a new VM to it (based on a given template)
## @showinitializer
declare PBVCVMDEPLOY="${PBDIRVMWARE}/vcenter_deploy-vm.yml"

## @var PBVCSHOW
## @brief Parse and show all local defined vCenters
## @details vCenter definitions are taken in:
## $INVENTORY/$TARGETENV/group_vars/all/bare_install
## The playbook $PBVCSHOW will parse and write the results to a tmp file defined in $PBVCSHOW
## @showinitializer
declare PBVCSHOW="${PBDIRVMWARE}/vcenter_show-avail.yml"


## @var PBVCVMPOWERON
## @brief powers on a vSphere VM (without any conditions required) and wait until fully started
## @showinitializer
PBVCVMPOWERON="${PBDIRVMWARE}/vcenter_always_poweron-vm.yml"

## @var PBVMNEWDISK
## @brief Add an additional disk to an existing VM
## @details ..
## @showinitializer
declare PBVMNEWDISK="${PBDIRVMWARE}/ae_vm_add-new-disk.yml"

## @var PBVMDISKFORMAT
## @brief Formatting a given disk in a VM
## @details ..
## @showinitializer
declare PBVMDISKFORMAT="${PBDIRVMWARE}/ae_vm_format-new-disk.yml"

## @var PBPVEDEPLOY
## @brief Deploys a VM to Proxmox
## @details Will connect to a Proxmox Node and deploys a new VM to it (based on a given template)
## @showinitializer
declare PBPVEDEPLOY="${PBDIRPROXMOX}/px_create_vm.yml"

## @var PBPVEGETNODES
## @brief Get configured PVE nodes
## @details Get configured Proxmox Nodes from the ansible config
## @showinitializer
declare PBPVEGETNODES="${PBDIRPROXMOX}/px_get_nodes.yml"

## @var PBGCPGETIDS
## @brief Get configured GCP project ids
## @details Get configured Google Cloud Platform project ids from the ansible config
## @showinitializer
declare PBGCPGETIDS="${PBDIRGOOGLECP}/gcp_get_ids.yml"

## @var PBGCPDEPLOY
## @brief Deploy GCP instance(s)
## @details Deploy a Google Cloud Platform (GCP) instance (including configuration)
## @showinitializer
declare PBGCPDEPLOY="${PBDIRGOOGLECP}/gcp_deploy_instance.yml"

## @var PBSYSDISKFORMAT
## @brief Formats a disk
## @details Formats an existing (!) disk
## @showinitializer
declare PBSYSDISKFORMAT="${PBDIRSYSTEM}/disk_format.yml"

## @var PBBASEINSTALL
## @brief setup the default base of a deployed system
## @details El-Repo kernel and system upgrades are just 2 examples here
## @showinitializer
declare PBBASEINSTALL="${PBDIRSYSTEM}/ae_system_base.yml"

## @var PBSYSKERNEL
## @brief Install/Set/Update the kernel
## @details El-Repo kernel
## @showinitializer
declare PBSYSKERNEL="${PBDIRSYSTEM}/ae_system_kernel.yml"

## @var PBSYSUPGRADE
## @brief System Upgrade
## @details Refreshes cache DB and starting a full system upgrade
## @showinitializer
declare PBSYSUPGRADE="${PBDIRSYSTEM}/ae_system_upgrade.yml"

## @var PBSSHCHK
## @brief Initial SSH connect
## @details Will add the host key when none exists yet. Add will be skipped when a host key changed!
## @showinitializer
declare PBSSHCHK="${PBDIRSYSTEM}/ae_ssh.yml"

## @var PBSYSREBOOT
## @brief general system reboot (linux)
## @details reboots a remote system
## @showinitializer
declare PBSYSREBOOT="${PBDIRSYSTEM}/ae_system_reboot.yml"

## @var PBCREATEUSER
## @brief Playbook for creating a linux user
## @showinitializer
declare PBCREATEUSER="${PBDIRSYSTEM}/ae_create_useracc.yml"

## @var PBDEPLOYKEY
## @brief Playbook for deploying a splunk pub key
## @showinitializer
declare PBDEPLOYKEY="${PBDIRSPLUNK}/deploy_splunk_pubpem.yml"

## @var PBLOCGETVAR
## @brief Playbook for accessing a given ansible variable
## @showinitializer
declare PBLOCGETVAR="${PBDIRLOCAL}/get_ansible_var.yml"

## @var PBFETCHFILES
## @brief Playbook for fetching files locally
## @showinitializer
declare PBFETCHFILES="${PBDIRSPLUNK}/fetch_files.yml"



## @var DEFSPLAPIADMIN
## @brief default splunk API (target:8089) admin account
## @details Defaults to "admin" user and can be changed interactively in PORS when asked.
## Do not change it here, for this define AEUSER in {HOME}/.pors/vars instead
## This account needs privileges to run API calls so either the admin or an user with at least the following capabilities (not tested and so maybe incomplete):
## - rest_apps_view
## - rest_properties_get
## - rest_properties_set
## - restart_splunkd
## FIXME: DEPRECATED -> handled by vault now
## @showinitializer
[ -z "$DEFSPLAPIADMIN" ] && \
declare DEFSPLAPIADMIN=admin

## @var DEFHOSTFILE
## @brief default filename for host/group definitions in ansible
## @details Defaults to "hosts" and can be changed interactively in PORS when asked.
## Do not change it here, for this define AEUSER in {HOME}/.pors/vars instead
## @showinitializer
[ -z "$DEFHOSTFILE" ] && \
declare DEFHOSTFILE=hosts

## @var GLABSETTINGS
## @brief gitlab authentication file
## @details stores the gitlab token for communicationg with gitlab API
## Do not change it here, for this define AEUSER in {HOME}/.pors/vars instead
## @showinitializer
[ -f "${HOME}/.pors/gitlab.auth" ] && GLABSETTINGS="${HOME}/.pors/gitlab.auth"
[ -z "$GLABSETTINGS" ] && \
declare GLABSETTINGS="$WORKDIR/gitlab.auth"

## @var AEUSER
## @brief local username for running PORS
## @details Defaults to "splunk" as it is meant for multi-user environments to keep track of actions in PORS. 
## Do not change it here, for this define AEUSER in {HOME}/.pors/vars instead
## @showinitializer
#: "${AEUSER:=splunk}"
[ -z "$AEUSER" ] && \
declare AEUSER=pors

## @var ENABLEVAULT
## @brief Make use of the Ansible Vault
## @details When set to "yes" PORS will ask for the Vault password on certain actions
## hint: to operate seamless the typed password gets stored locally but only until the cookie authentication has finished.
## after that the temporary file gets deleted automatically.
## If you are scared about storing a password even temporary do not enable this functionality.
## @showinitializer
[ -z "$ENABLEVAULT" ] && \
declare ENABLEVAULT=yes

## @var SESSIONBASEDVAULT
## @brief Store the Ansible Vault temp file for the whole session
## @details When set to "yes" PORS will not remove the temporary Vault password (req: ENABLEVAULT=yes)
## for the whole session (less questions but less secure). When PORS ends it will be deleted of course.
## If you are scared about storing a password even temporary do not enable this functionality.
## @showinitializer
[ -z "$SESSIONBASEDVAULT" ] && \
declare SESSIONBASEDVAULT=yes

## @var DEFAULTVAULT
## @brief full path to the default vault
## @details This is used to check the typed password so it must exists (if using ENABLEVAULT=yes)
## @showinitializer
[ -z "$DEFAULTVAULT" ] && \
declare DEFAULTVAULT=$AINVENTORY/$TARGETENV/group_vars/all/vault.yml

## @var VALIDROLES
## @brief Valid Splunk Server Role names
## @details these are in use everwhere in PORS, i.e. in playbooks, target groups as well. Fully static. do NOT touch these.
declare VALIDROLES="activeinput deployer deploymentserver generic heavyforwarder httpeventcollector licensemaster logstream_leader logstream_worker masternode monitoringconsole peernode searchhead shcmember universalforwarder"

#################################################################################################
# NO CHANGES BEHIND THIS POINT | NO CHANGES BEHIND THIS POINT | NO CHANGES BEHIND THIS POINT 
#################################################################################################

# test all playbooks
# gen: egrep '^declare \w+=|^export \w+=' pors |cut -d = -f1 |grep PB | cut -d " " -f2 | sed 's/^/$/g' | egrep -v "DIR|PBDEPLAPP" |tr "\n" " "
PBS="$PBENAPP $PBREGENDEPLOY $PBDEPLSYSC $PBGETTARGETS $PBUPGRADE $PBSHINSTALL $PBSHRELOAD $PBSPLACT $PBINSTALL $PBINSTALLLOGSTREAM $PBCONFMN $PBCONFPEER $PBCONFSH $PBCONFHF $PBDLSPL $PBVCINFO $PBVCGETVHOSTSTATES $PBVCVMDEPLOY $PBVCSHOW $PBVMNEWDISK $PBVMDISKFORMAT $PBBASEINSTALL $PBSYSKERNEL $PBSYSUPGRADE $PBSSHCHK $PBSYSREBOOT $PBCREATEUSER"

for pb in $PBS;do
    #find $PBDIR -name ${pb/*\/}
    [ ! -f $pb ] && echo "ERROR: playbook missing: $pb" && exit 3 
done

## @var VAULTTEMPFILE
## @brief The temporary file holding the Ansible Vault password
## @details Only relevant if ENABLEVAULT is set to yes.
## to operate seamless the typed password gets stored locally but only until the cookie authentication has finished.
## after that the temporary file gets deleted automatically.
## If you are scared about storing a password even temporary do *not* set ENABLEVAULT=yes .
## The temporary file is placed in WORKDIR which is accessible by the PORS user only!
declare VAULTTEMPFILE="${WORKDIR}/.avtmp"

## @fn F_LOG()
## @brief Logging function
## @param 1 (required) the calling parent function
## @param 2 (required) the message to be logged
## @details Logging function
F_LOG(){
    [ ! -d $LOGDIR ] && mkdir -p $LOGDIR
    CALLER="$1"
    MSG="$2"

    if [ -z "$MSG" ]||[ -z "$CALLER" ];then
    	F_DIAERR 2 "INTERNAL ERROR: $FUNCNAME requires an arg"
    else
    	PREFIX="$(date '+%F_%T') - PORS - ($CALLER) -"
        echo -e "$PREFIX $MSG" >> $LOG
    fi
}

## @fn F_ECHOLOG()
## @brief Logging function which also echo's to the terminal
## @param 1 (required) the calling parent function
## @param 2 (required) the message to be logged
## @details Useful mostly for batch / API processing in PORS
F_ECHOLOG(){
    CALLER="$1"
    MSG="$2"
    F_LOG "$CALLER" "$MSG"
    echo "$CALLER: $MSG"
}

## @fn F_LOGROTATE()
## @brief Rotates the PORS log
## @details Rotates the PORS log
F_LOGROTATE(){
    ROTATE=no

    CURLOGCNT=$(find $LOGDIR -type f | wc -l)
    while [ "$CURLOGCNT" -gt $MAXLOG ];do
        ROTATE=yes
        CURLOGCNT=$(find $LOGDIR -type f | wc -l)
        OLDESTLOG=$(find $LOGDIR -type f -printf '%T+ %p\n' | sort | head -n 1 | cut -d " " -f 2)
        rm $OLDESTLOG 
    done

    echo "Starting new log - $(date +%Y-%m-%d_%T) - version: $VERSION" > $LOG
    F_LOG $FUNCNAME "main log has been rotated: $ROTATE"
    F_LOGROTATESIZE "$ALOG" "$ALOGMAXMB"
}

## @fn F_LOGROTATESIZE()
## @brief Rotates the PORS log by size
## @details Rotates the PORS log by a given max size
F_LOGROTATESIZE(){
    F_LOG $FUNCNAME "started with $1, $2"

    RLOG="$1"
    RLOGSIZE="$2"
    RLOGMAX=$((RLOGSIZE * 1024 * 1024))

    [ -z "$RLOGMAX" ] && F_LOG $FUNCNAME "Error occured: max size not specified for $RLOG" && return 3
    if [ -f "$RLOG" ];then
        CSIZE=$(stat --printf=%s $RLOG)

        if [ $CSIZE -ge $RLOGMAX ];then
            NLOG=$(date +%s)
            mv $RLOG ${RLOG}.${NLOG} && F_LOG $FUNCNAME "$RLOG rotated to ${RLOG}.${NLOG} successfully"
        else
            F_LOG $FUNCNAME ".. skipping log rotate for $RLOG as $CSIZE bytes is less then its limit ($RLOGMAX bytes)"
        fi
    fi
    F_LOG $FUNCNAME finished
}

## @fn F_RMVAULTPW()
## @brief removes the temporary Ansible Vault pw file
## @param 1 (optional) force/override SESSIONBASEDVAULT setting
## @details Checks for $VAULTTEMPFILE and if that exists it gets deleted.
## This should be used whenever F_VAULTPW was used before.
F_RMVAULTPW(){
    F_LOG $FUNCNAME started
    if [ -f "$VAULTTEMPFILE" ];then
        [ $DEBUG -eq 1 ] &&  F_LOG $FUNCNAME "DEBUG MODE !!! DEBUG MODE !!! skipped removing vault temp file forever!" && return 0
        [ ! -z $STEALTHMODE ] && F_LOG $FUNCNAME "skipped removing vault temp file as we are in STEALTH mode!" && return 0
        [ "$RUNMODE" == "batch" ] && F_LOG $FUNCNAME "skipped removing vault temp file as we are in BATCH mode!" && return 0
        [ "$1" == "force" ] && F_LOG $FUNCNAME "deleting vault temp file - forced" && rm $VAULTTEMPFILE && return 0
        [ "$SESSIONBASEDVAULT" != "yes" ] && F_LOG $FUNCNAME "deleting vault temp file - regular" && rm $VAULTTEMPFILE && return 0
        [ "$SESSIONBASEDVAULT" == "yes" ] && F_LOG $FUNCNAME "skipped removing vault temp file" && return 0
        F_LOG $FUNCNAME "deleting vault temp file - no SESSIONBASEDVAULT" && rm $VAULTTEMPFILE
    fi
    F_LOG $FUNCNAME ended
}

## @fn F_ENDSESS()
## @brief Clear session
## @details PORS ensures it will not be executed more then 1 time by the EXECBIT var
F_ENDSESS(){
    F_LOG $FUNCNAME started
    if [ -z $STEALTHMODE ]||[ "$RUNMODE" != "batch" ];then
        F_RMVAULTPW force
    fi
    [ -z $STEALTHMODE ] && F_LOG $FUNCNAME "deleting session file:" && rm -vf $EXECBIT 2>&1 >> $LOG
    F_LOG $FUNCNAME ended
}

## @fn F_EXIT()
## @brief regular PORS exit
## @details clean exit including clearing the session bit
F_EXIT(){
    F_LOG $FUNCNAME "started with $1"
    ERRCODE=$1

    F_ENDSESS

    # finally terminate
    F_LOG $FUNCNAME "ended with code $ERRCODE" 
    exit $ERRCODE
}

## @fn F_EXITUNCLEAN()
## @brief exit the program unclean but controlled
## @param 1 optional: exit code (default 0)
## @details will not clear the session bit so only needed in rare cases (e.g. --help)
F_EXITUNCLEAN(){
    F_LOG $FUNCNAME started
    ERRCODE=$1
    echo "$FUNCNAME: No session exit" >> $LOG
    F_LOG $FUNCNAME "ended $ERRCODE"
    #trap - SIGINT SIGHUP TERM
    exit $ERRCODE
}

# catch ctrl+c, kills etc to terminate cleanly..
trap F_EXIT SIGINT SIGHUP TERM

# check requirements first
dialog --version >> /dev/null 2>&1
if [ $? -ne 0 ];then
	echo -e "\nplease install the software <dialog> first!\n"
else
    $ABIN --version >> /dev/null 2>&1
    if [ $? -ne 0 ];then
        echo -e "\nReally?? You want to use ansible deployment without ansible??! Coooool.. Install ansible and try again..\n"
	export ERRCODE=90
        F_EXIT
    fi
    for i in $(echo $SHOWAPPS $PBNEWAPP $PBENAPP $PBDEPLSYSC);do
	if [ ! -r $i ];then 
	    echo -e "\n\tERROR. Please ensure you've done chmod +r $i first and that $i exists!\n"
	    F_EXIT
	fi
    done
fi

## @fn F_ABIN()
## @brief start ansible-playbook
## @param 1 (required) the ansible hostfile or the special "version" tag
## @param 2 (required) the ansible playbook
## @param 3 (required) the title for the progressbox of the playbook run
## @param 4 (optional) ansible extra args. space separated parameters like -e 'var1=moo var2=cow' need to be defined in JSON format<br>
## @param 5 (optional) a YAML or json formatted filename containing extra vars
## @details Main function for all ansible-playbook commands (previously 'F_A2BIN')
## example args: F_ABIN hosts myplaybook myboxtitle "-e {'var1':'moo','var2':'cow'}"
F_ABIN(){
        F_LOG $FUNCNAME started
	# returns error code of the playbook run
	#
	# requires these parameters:
	A2HOSTFILE="$1" # the ansible hostfile or the special "version" tag
	A2PB="$2"	# the ansible playbook
	BOXTITLE="$3"	# the title for the progressbox of the playbook run

	# optional:
	# ansible extra args. space separated parameters like -e 'var1=moo var2=cow' need to be defined in JSON format!!
	# e.g.: F_ABIN hosts myplaybook myboxtitle "-e {'var1':'moo','var2':'cow'}"
	A2ARGSRAW="$4"	

        # optional: extra variables defined in a file in YAML/json format
        EVARFILE="$5"

	F_LOG $FUNCNAME "ARGSRAW: $A2ARGSRAW , EVARFILE: $EVARFILE"
	
	# find space keyword
	A2ARGS=$(echo "$A2ARGSRAW" | sed 's/SPACE/ /g')
	F_LOG $FUNCNAME "ARGS: $A2ARGS"
	
        # build 
	if [ -z "$A2HOSTFILE" ]||[ -z "$A2PB" ]||[ ! -f "$A2HOSTFILE" ]||[ ! -f "$A2PB" ];then
            if [ "$A2HOSTFILE" != "version" ];then
	        if [ "$RUNMODE" == "batch" ];then
                    echo "ERROR: Missing or wrong ARGS in $FUNCNAME (A2HOSTFILE:$A2HOSTFILE,A2PB:$A2PB)!"
                    return 1
                else
                    F_DIAERR 3 "INTERNAL ERROR: Missing or wrong ARGS for $FUNCNAME (A2HOSTFILE:$A2HOSTFILE,A2PB:$A2PB)"
                fi
	        F_EXIT $FUNCNAME 3
            fi
	fi

	F_LOG $FUNCNAME "$ABIN -i $A2HOSTFILE ${A2ARGS} $A2PB"
        if [ "$A2HOSTFILE" == "version" ];then
            $ABIN --version
            A2ERR=$?
        else
            if [ "$RUNMODE" == "interactive" ];then
                [ ! -s $VAULTTEMPFILE ] && [ "$ENABLEVAULT" == "yes" ] && F_VAULTPW
                if [ ! -z "$EVARFILE" ];then
                    F_LOG $FUNCNAME "Will execute:\n$ABIN $PLAYNOISE -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG} -e @$EVARFILE"
	            $ABIN $PLAYNOISE -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG} -e "@${EVARFILE}" 2>&1 | tee -a $LOG | sed -u -r 's/(.*DEPRECATION.*)//Ig' | F_DIALOG --scrollbar --colors --progressbox "$BOXTITLE" 1000 1000
                else
                    F_LOG $FUNCNAME "Will execute:\n$ABIN $PLAYNOISE -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG}"
	            $ABIN $PLAYNOISE -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG} 2>&1 | tee -a $LOG | sed -u -r 's/(.*DEPRECATION.*)//Ig' | F_DIALOG --scrollbar --colors --progressbox "$BOXTITLE" 1000 1000
                fi
	        A2ERR="${PIPESTATUS[0]}"
            else
                $ABIN $PLAYNOISE -i $A2HOSTFILE $A2PB ${A2ARGS} ${A2VAULTARG} 2>&1 | tee -a $LOG
	        A2ERR="${PIPESTATUS[0]}"
            fi
        fi
	F_LOG $FUNCNAME "finished with errcode: $A2ERR"
	return $A2ERR
}

## @fn F_DIALOG()
## @brief main dialog form with PORS presets
F_DIALOG(){
    if [ "$RUNMODE" == "interactive" ];then
	    dialog --no-mouse --title "PORS v$VERSION/$MAXAVERSION (${TARGETENV})" "$@"
    else
        echo "$@"
    fi
}

## @fn F_HELP()
## @brief Usage/Help for PORS
F_HELP(){
cat <<_EOHELP

    USAGE/HELP for $BIN (v$VERSION)

    Interactive / GUI mode:
    ------------------------------------------
    The regular way of using PORS

    --env <environment>                         define the running environment ($AINVENTORY/[your --env setting]/, e.g. production or development, ...)
    --help                                      Will show this

    --advanced                                  Will enable/show advanced option menu
    --testing                                   Unfinished menu options
    -i|--inventory <hosts-file>                 The full path to your hosts filename
    --verbose                                   will execute all playbook commands with -vvv
    --debug                                     will execute all playbook commands with -vvvv

    Batch / API mode: !!!WORK-IN-PROGRESS!!!
    ------------------------------------------
    Enables full automated way of using PORS

    --verbose                                   will execute all playbook commands with -vvv
    --debug                                     will execute all playbook commands with -vvvv

    --batch

     MANDATORY:

       --env <environment>                      define the running environment ($AINVENTORY/[your --env setting]/, e.g. production or development, ...)
       -i|--inventory <hosts-file>              The full path to your hosts filename
       -t|--target <targetgroup>                The group name as defined in your inventory

       ACTION OR PLAYBOOK OR FUNCTION (MANDATORY)

       -p|--play <playbookname>                 available playbooks are in $PBDIR
         [--playargs "<arguments>"]             optional variables for the given playbook. must be defined as key=value.

       OR
       -f|--function <function>                 interal $BIN function name (e.g. F_ADDPEER)
         [--funcargs "<arguments>"              optional parameters for the given function

       OR
       -a|--action <predefined action>          current predefined actions are:
                                                - deploy

     OPTIONAL:

       -pa|--post-action <post-action>          The action will be performed on the defined <targetgroup> and the current predefined post-actions are: 
                                                reload-all (like a debug refresh)
                                                DS-reload (reload deploy-server on a deploymentserver)
                                                MN-apply-cb (apply cluster-bundle on a masternode)
                                                SHC-apply-cb (apply shcluster-bundle on a deployer)
       --vault-password-file <secret-file>      If you are using Ansible Vault this setting allows to specify a local file containing the
                                                secret to unlock your vault. This is of course a SECURITY ISSUE but if you using vault vars in your playbooks then
                                                ensure that the file permissions of <secret-file> are as restrictive as possible
       -1                                       will force to use ansible v1 as v2 is default
       --deployapp "<app name(s)>"              QUOTED list separated by a PIPE (|) of app names to deploy - if you do *not* want to deploy ALL apps for a target!
                                                This quoted list is egrep regex so may match unwanted things if not being careful.
                                                Example:
                                                If you set --deployapp "my-app|my-other-app" it will match my-app and my-other-app - but also my-app-bla, my-apps, etc
                                                If you want to ensure that only the name "my-app" matches use the $ char at the end: like --deployapp "my-app$|my-other-app"

_EOHELP
}

## @fn F_SHOWAPPS()
## @brief Deprecated way of parsing and showing apps<->target
## @param 1 The target group to parse for
## @return a list of all apps linked to the target
## @exception if env cant be found
## @details This is superseeded by F_LISTAPPS and should not be used anymore
F_SHOWAPPS(){
	echo "$FUNCNAME started" >> $LOG
        clear
	SEL="$1"
	[ -z "$SEL" ]&& echo ERROR missing arg for F_SHOWAPPS
	if [ "$SEL" == "ALL" ];then
		$SHOWAPPS -env $AINVENTORY/$TARGETENV
	else
		$SHOWAPPS -env $AINVENTORY/$TARGETENV "$SEL"
	fi
	echo "************************************************"
	read -p "To continue press ENTER" DUMMY
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_LISTAPPS()
## @brief Parse and show apps<->target links
## @param 1 The target group to parse for
## @return a list of all apps linked to the target in the format: "type:app-name"
## @exception if env cant be found
## @details $SHOWAPPS is able to handle one or multiple targets at the same time
F_LISTAPPS(){
        F_LOG $FUNCNAME started
        SEL="$1"
        [ -z "$SEL" ]&& F_LOG $FUNCNAME "ERROR: missing SEL arg!"
        if [ "$SEL" == "ALL" ];then
            F_LOG $FUNCNAME "will exec: $SHOWAPPS -batch -env $AINVENTORY/$TARGETENV"
            $SHOWAPPS -batch -env $AINVENTORY/$TARGETENV
        else
            F_LOG $FUNCNAME "will exec: $SHOWAPPS -batch -env $AINVENTORY/$TARGETENV $SEL"
            $SHOWAPPS -batch -env $AINVENTORY/$TARGETENV "$SEL"
        fi
        F_LOG $FUNCNAME "ended with $?"
}

## @fn F_RMAPP()
## @brief Removes an app <--> target linkage
## @exception abort by user/error on unlinking
## @details Removes an app <--> target linkage
## 1. ask for complete removal or just unlink
## 2. ask for target group
## 3. offer multi checkbox list of all apps for that group
F_RMAPP(){
    F_LOG $FUNCNAME started

    unset SELECTION RMAPPS ABORTED HOSTSELECT HOSTSELECTION
    F_HOSTFILE

    SELECTION=$(F_DIALOG --radiolist "You have to choose an action mode first\n\nThe following will be choosen for ALL apps you will select in the next steps.\n\n" 15 150 16 \
                "Remove" "completely delete app(s) (locally *AND* on remote)" "on" \
                "Disable" "keep the link in PORS but disable app(s) from PORS deployment (will *not* touch remote)" "off" \
                "Unlink" "unlink app(s) in PORS only (will *not* touch remote)" "off" \
                2>&1 >/dev/tty)
    [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

    while [ -z "$HOSTSELECT" ];do
        HOSTSELECTION=$(F_TARGETS radiolist)
        [ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && return 4
        if [ -z "$HOSTSELECTION" ];then
            F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
        else
            HOSTSELECT=1
            ABORTED=0
        fi
    done
    if [ "$ABORTED" -ne 0 ];then
        F_LOG $FUNCNAME "DEBUG: aborted by user."
        return 4
    fi

    F_LOG $FUNCNAME "Choosen target group: $HOSTSELECTION"

    GETAPPS=$(F_LISTAPPS "$HOSTSELECTION")
    [ -z "$GETAPPS" ] && F_LOG $FUNCNAME "GETAPPS: $GETAPPS <-- seems to be empty?! so no linked apps.." && F_DIALOG --colors --msgbox "\nThere are no linked apps for:\n\n    \Zb$HOSTSELECTION\ZB\n\nMaybe its a good time to add some ;) ?" 20 50 && return 0

    OPTIONS=($(for i in $(echo "$GETAPPS" |cut -d ":" -f 1-2);do echo "${i/*:}" "${i/:*}" off;done))
    RMAPPS=$(F_DIALOG --checklist "\nPlease use the space-bar to make your selection:" 80 80 70 "${OPTIONS[@]}" 2>&1 >/dev/tty)
    [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

    F_LOG $FUNCNAME "choosen apps: $RMAPPS, action: $SELECTION"
    
    # in any case disable the app locally
    for app in $RMAPPS;do
        sed -i "s/\(^\s*\)\(install:\s*[Tt]rue\)/\1install: false/g" $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 2>&1 >> $LOG
        RMERR=$((RMERR + $?))
        F_LOG $FUNCNAME "disabling: $app ended with $RMERR"
    done

    case $SELECTION in
        Remove) RMERR=0
           for app in $RMAPPS;do
                # ensure migrated linked apps can be handled properly on the next step
                egrep "\s*delete:" $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app || echo "    delete: false" >> $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 
                # set removal flag
                sed -i "s/\(^\s*\)\(delete:\s*[Ff]alse\)/\1delete: true/g" $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 2>> $LOG
            done
            F_DIALOG --yesno "\nDo you want to remove the choosen apps now?\n(otherwise this will happen on next deployment run)\n\nThis will delete theses apps on $HOSTSELECTION:\n\n$RMAPPS" 15 80 
            [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

            export SHOSTFILE=$HOSTFILE
            export BTARGET="$HOSTSELECTION"
            export DEPLOYAPPSUBSET=1
            F_DEPLOYAPP auto "$RMAPPS"
            RMERR=$((RMERR + $?))
        ;;
        Disable)
            F_LOG $FUNCNAME "app has been disabled"
        ;;
        Unlink) RMERR=0
            for app in $RMAPPS;do
                rm -vf $AINVENTORY/$TARGETENV/group_vars/$HOSTSELECTION/$app 2>&1 >> $LOG
                RMERR=$((RMERR + $?))
                F_LOG $FUNCNAME "unlinking $app ended with $RMERR"
            done
        ;;
    esac
    F_PORSACTION "$SELECTION app(s)" "$FUNCNAME | $SELECTION on $HOSTSELECTION:  $RMAPPS"
    F_DIAERR $RMERR "$SELECTION $RMAPPS"
    F_LOG $FUNCNAME ended
}


## @fn F_SELECTOR()
## @brief Menu for selecting all or specific targets
F_SELECTOR(){
	F_LOG "$FUNCNAME"  started
	SELECTION=$(F_DIALOG --menu "\nChoose an option:" \
			15 100 14 \
			Choose "" \
			ALL "" \
			3>&1 1>&2 2>&3)
	echo "$SELECTION"
	F_LOG "$FUNCNAME" ended
}

## @fn F_GOAPPS()
## @brief show current apps deployment
F_GOAPPS(){
    F_LOG "$FUNCNAME" started
    unset GROUPS

    if [ "$SELECTION" == "ALL" ];then
        # FIXME
        GROUPS=$(for i in $(find $AINVENTORY/$TARGETENV/group_vars/* -maxdepth 1 -type d |egrep -v "(templates|all)" |sed s#$AINVENTORY/$TARGETENV/group_vars/##g);do echo $i;done)
    else
        if [ "$SELECTION" == "Choose" ];then
	    OPTIONS=($(for i in $(find $AINVENTORY/$TARGETENV/group_vars/* -maxdepth 1 -type d |egrep -v "(templates|all)" |sed s#$AINVENTORY/$TARGETENV/group_vars/##g);do echo $i $i off;done))
	    GROUPS=$(F_DIALOG --checklist "Select options:" 35 76 36 "${OPTIONS[@]}" 2>&1 >/dev/tty)
	else
	    F_LOG $FUNCNAME "ERROR: no selection made"
	fi
    fi
    if [ -z "$GROUPS" ];then
        F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
        return 4
    else
        APPLIST=$(for a in $GROUPS;do echo "\n\Zb$a\ZB\n---------------------------------------------------------------------------------------------"; F_LISTAPPS "$a";done)
        APPLISTPREP=$(for i in $APPLIST;do echo "${i}\n" | sed "s/:/\t\t\t\t/g" ;done)
        F_LOG $FUNCNAME "APPLIST:\n$APPLIST\n\nAPPLISTPREP:\n$APPLISTPREP"
        F_DIALOG --colors --msgbox "\n\ZbThe following apps are linked to your selected groups:\ZB\n(use PG-UP/-DOWN to scroll if needed)\n$APPLISTPREP" 60 120
    fi
    F_LOG "$FUNCNAME" finished
}

## @fn F_HOSTFILE()
## @brief Choose / check ansible inventory file
## @param 1 optional: mode (auto|\<empty\>)
## mode auto: will set hostfile by $SHOSTFILE variable
## @details
## ask for hosts filename (will list any hosts.* files as well)
## returns either the hostfile or ABORTED if the user cancels
F_HOSTFILE(){
	F_LOG $FUNCNAME started
	STARTOVER=1
	ABORT=0
    FMODE=$1

    if [ ! -z "$FORCEDHOSTFILE" ];then
         HOSTFILE="$FORCEDHOSTFILE"
    elif [ "$FMODE" == "auto" ];then
        HOSTFILE="$SHOSTFILE"
    elif  [ "$RUNMODE" == "batch" ];then
        HOSTFILE="$SHOSTFILE"
    else
	  while [ $STARTOVER -eq 1 ];do
		unset OPTIONS SELECTION HOSTFILE SHOSTFILE
		# detect available host files
		while [ -z "$SHOSTFILE" ];do
			OPTIONS=($(for i in $(find -L $AINVENTORY/$TARGETENV -maxdepth 1 -type f -name "hosts*" |grep -v template);do echo ${i##*/} file;done))
			SHOSTFILE=$(F_DIALOG --menu "Select a hosts file:" 22 76 16 "${OPTIONS[@]}" manually "type in a path" 2>&1 >/dev/tty)
			[ $? -ne 0 ] && HOSTFILE="ABORTED" && return 4
		done
		if [ "$SHOSTFILE" == "manually" ];then
			SHOSTFILE=$(F_DIALOG --inputbox 'Type in your hosts filename' 20 100 $DEFHOSTFILE 2>&1 >/dev/tty)
		fi
		# construct the full host filename
		HOSTFILE="${AINVENTORY}/${TARGETENV}/${SHOSTFILE}"
		if [ ! -r "$HOSTFILE" ];then
			F_DIALOG --msgbox "\n\nERROR: $HOSTFILE does not exist or is not readable" 10 80
			STARTOVER=1
		else
			STARTOVER=0
		fi
	  done
    fi
    if [ ! -r "$HOSTFILE" ];then
	   [ "$RUNMODE" != "batch" ] && F_DIALOG --msgbox "\n\nERROR: $HOSTFILE does not exist or is not readable" 10 80 && return 3
       [ "$RUNMODE" == "batch" ] && echo "ERROR: $HOSTFILE does not exist or is not readable" && F_EXIT
	else
	    echo "HOSTFILE=\"$HOSTFILE\"" > $AEUSRHOSTFILE
	    F_LOG $FUNCNAME "written new AEUSRHOSTFILE ($AEUSRHOSTFILE):\n$(cat $AEUSRHOSTFILE)"
    fi
	F_LOG $FUNCNAME finished
}

## @fn F_TARGETS()
## @brief identify targets/hosts of a group
## @param 1 required: dialog option (checklist/radiolist)
## @param 2 optional: automatic/non interactive mode (auto selected group name|empty)
## @return list of hosts
## @exception on error or abort: abort
## @details identify targets/hosts of a group. DEPRECATED, use F_EXPANDHOSTS instead.
## 1. filter out all vars
## 2. get all sections and 1 next line
## 3. replace [ with newline
## 4. replace ] with comma, empty lines with / and remove children tag from group name
## 5. remove all newlines
## 6. replace // with /
## 7. replace / with newline
## --> steps 4-7 are required to ensure even when 2 sections are written without a space
##     between. Example:
##     [sec1]
##     [sec2]
##     host
##     As we catch always section + 1 next line on step 2 to identify empty sections the above 
##     steps ensure we will *NOT* have a result of: "sec1" has host "sec2"
## 8. get only these lines containing a comma and something behind (means section has a value)
##    this is needed as a section can be empty which shouldnt be shown if!
F_TARGETS(){
	F_LOG "$FUNCNAME" "started with these arguments: $@"
	unset NIGRP
	NIGRP="$2"
	
	#OPTIONS=($(for i in $(egrep -v "(:vars|:children)" "$HOSTFILE" | egrep --group-separator="/" -A1 "^\[.*\]"| tr "[" "\n" |sed -e 's/\]$/,/g;s/^$/\//g'| tr -d "\n" | sed 's#//#/#g' | tr "/" "\n" | egrep ",\w+" | cut -d "," -f1);do echo $i $i off; done | sort))
	OPTIONS=($(for i in $(egrep -v "(:vars|^#)" "$HOSTFILE" | egrep --group-separator="/" -A1 "^\[.*\]"| tr "[" "\n" |sed -e 's/\]$/,/g;s/^$/\//g;s/:children//g'| tr -d "\n" | sed 's#//#/#g' | tr "/" "\n" | egrep ",\w+" | cut -d "," -f1);do echo $i $i off; done | sort -u ))
	# OPTIONS EXPLANATION ABOVE

	if [ -z "$1" ];then 
		F_LOG $FUNCNAME "ERROR! Missing F_TARGETS arg!! Cannot continue..." && return 3
	else
		DOPT="$1"
	fi

	if [ -z "$NIGRP" ];then
	    HOSTSELECTION=$(F_DIALOG --${DOPT} "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
		HERR=$?
		F_LOG "$FUNCNAME" "HERR was $HERR"
		if [ "$HERR" != "0" ];then
			echo "ABORTED"
                        return 4
		else
			echo "$HOSTSELECTION"
		fi
	else
		#echo "${OPTIONS[@]} | cut -d ' ' -f 1 |grep $NIGRP"
		echo "$NIGRP"
	fi
	F_LOG "$FUNCNAME" "finished"
}


## @fn F_GVARDIR()
## @brief group_vars dir check and initiate if needed
F_GVARDIR(){
	echo "$FUNCNAME started" >> $LOG
        unset DEPL DEPLPARSED
	INIT=0
	TG=$1
	TDIR=$AINVENTORY/$TARGETENV/group_vars/$TG
	[ -z "$TG" ]&& echo "Missing arg for $FUNCNAME!! ABORTED" && F_EXIT
	if [ -d "$TDIR" ];then
		echo "$TDIR" exists >> $LOG
		if [ -f "$TDIR/deployment.yml" ];then
			echo already initialized >> $LOG
		else
			INIT=1
		fi
	else
		INIT=1
	fi
	if [ "$INIT" -eq 1 ];then
		echo creating $TDIR >>$LOG
		mkdir $TDIR >>/dev/null 2>&1
		ERRC=0
		while [ -z "$DEPL" ]&&[ "$ERRC" -eq 0 ];do
			DEPL=$(F_DIALOG --inputbox "\nIt seems this is the first time you want to link an app to $TG (if not something is wrong).\nInitializing of:\n<$TDIR>\nis required.\n\nPlease type in where you want to deploy apps for >$TG<.\n\nValid paths are:\n - apps\n - deployment-apps\n - shcluster/apps\n - master-apps\n\n" 21 100 2>&1 >/dev/tty)
			ERRC=$?
		done
		if [ $ERRC -eq 0 ];then
                    DEPLPARSED=$(echo "${DEPL}" | sed -E 's:(-|/):_:g')
		    echo "will create deployment file with: $DEPL ($DEPLPARSED) as target dir" >> $LOG
		    # creating deployment file:
		    cat >> $TDIR/deployment.yml <<EOF_DEPL
---
#####################################################################################################################
# Configurations for Splunk deployment directory
# Keep in mind to replace "-" and "/" with an underscore "_"
#####################################################################################################################

deployment:
    dir: $DEPLPARSED
EOF_DEPL
		fi
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_DEPLSYSC()
## @brief deploy system/local configs
F_DEPLSYSC(){
	echo "$FUNCNAME started" >> $LOG
	F_HOSTFILE
	SELECTION="$1"

        # create a temporary ansible group (must be in the correct env path! otherwise variables cant be found)
        ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
        > $ITMPGRP

	if [ "$SELECTION" == "Choose" ];then
	     unset HOSTSELECT HOSTSELECTION
	     while [ -z "$HOSTSELECT" ];do
		HOSTSELECTION=$(F_TARGETS checklist)
		[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
	         if [ -z "$HOSTSELECTION" ];then
                     F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30 
                 else
                     HOSTSELECT=1
		     ABORTED=0
                 fi
	     done
	     if [ "$ABORTED" -ne 0 ];then
                echo "DEBUG: aborted by user."
	     else
		  F_DIALOG --yesno "\nAre you sure you want to continue?\n\nThis will deploy the system/local configs to:\n\n$HOSTSELECTION" 15 80
		  if [ $? -eq 1 ];then
			ABORTED=1 
		  else
		     # TODO: optimize playbook exec to just exec on group instead of for each host
			unset HOSTSELEXPANDED
			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION" $ITMPGRP clean | grep -v EMPTY |cut -d : -f 1)
			# host 1,2,3,... of shcmember
			for hex in $HOSTSELEXPANDED;do
			     F_LOG $FUNCNAME "processing host >$hex<"
			     for hgroup in $HOSTSELECTION;do
				    F_LOG $FUNCNAME "processing $hex in >$hgroup<"
				    # for shcmember, ...
			    	#F_GVARDIR "$hgroup"

				    # update task etc stuff first
                    F_LOG $FUNCNAME "roledir: $ROLEDIR"
				    F_TPLUPDATE "${ROLEDIR}/system" "$hgroup/$hex"

				    F_LOG $FUNCNAME "Will play:\n$ABIN -i $HOSTFILE $PBDEPLSYSC -e \"target=$hgroup exp_host=$hex\""
				    $ABIN -i $HOSTFILE $PBDEPLSYSC -e "target=$hgroup exp_host=$hex"
				    ERR=$?
				    F_DIAERR "$ERR" "on \Zb\Z1<$hex>\Zn"
				    [ $ERR -ne 0 ]&& F_MSG "ERROR: ABORTED deployment!" && break 2 >>$LOG
			     done
		     done
		  fi
	     fi
	else
		F_DIALOG --msgbox "ERROR: Deploying to ALL is not supported yet" 10 100
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_SSHORNOT()
## @brief let the user choose to either catch existing conf from another host or locally (system/local related)
F_SSHORNOT(){
	echo "$FUNCNAME started" >> $LOG
	unset ANS
	while [ -z "$ANS" ];do
		#ANS=$(F_DIALOG --radiolist "\nDo you want to active pull the current config or use a local copy instead?\n(use the space-bar to select)" 15 80 3 Pull "Pull existing conf from a host (copy by SCP)" on Local "Choose a local dir for importing conf" off Skip "Use the local copy (POTENTIAL DANGEROUS. Will overwrite remote changes if any)" off 2>&1 >/dev/tty)
		ANS=$(F_DIALOG --radiolist "\nDo you want to active pull the current config or use a local copy instead?\n(use the space-bar to select)" 15 100 5 Pull "(RECOMMENDED) Pull current active conf" on ---- "--------------------------------------" off DANGEROUS-Import "OVERWRITES REMOTE! Import configs from a LOCAL directory" off DANGEROUS-Skip "OVERWRITES REMOTE! Just use the LOCAL(!!) existing files" off 2>&1 >/dev/tty)
		ERR=$?
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			echo "$FUNCNAME: err was $ERR" >> $LOG
			ANS="ABORTED"
		fi
		# reset ans when the user has selected the hint text...
		[ "$ANS" == "----" ]&&unset ANS
	done
	echo "$FUNCNAME finished" >> $LOG
	echo $ANS
}

## @fn F_DIMPORT()
## @brief import by ssh from an existing host (system/local related)
## @param 1 (required): Target host system where to pull from
## @param 2 (required): Target host path to fetch
## @param 3 (required): Local path to pull into
## @param 4 (optional): Target host become user
F_DIMPORT(){
	echo "$FUNCNAME started" >> $LOG
	FTARGETHOST="$1"
	SSHPATH="$2"
	LOCTMP="$3"
        FFUSER="$4"
        [ -z "$FFUSER" ] && FFUSER=$(F_GETANSIBLEVAR splunk_install_user)

	[ -d $LOCTMP ]&& rm -R $LOCTMP
	mkdir -p $LOCTMP

        F_ABIN "$HOSTFILE" "$PBFETCHFILES" "fetching ..." "-e {'target':'$FTARGETHOST','fetch_src':'$SSHPATH','fetch_dest':'$LOCTMP','filefetch_user':'$FFUSER'}" 2>> $LOG 1>> /dev/null
	ERR=$?
        F_PORSACTION "pulled system/local" "$FUNCNAME | fetched system/local confs from ${SSHHOST}"

#	SIMP=$(F_DIALOG --inputbox "$TPLMSG\nNow initialize the deployment directory by copying your initial config files you want to deploy.\n\n\nWhere should I copy the initial configs from:" 15 80 2>&1 >/dev/tty)
	echo "$FUNCNAME finished" >> $LOG
        echo $?
        return $ERR
}

## @fn F_DBROWSE()
## @brief file browser (system/local related)
F_DBROWSE(){
	echo "$FUNCNAME started" >> $LOG
	unset SDIR
        SDIR=$(F_DIALOG --colors --inputbox "\nSource path (full path) where to copy the initial configs from\n(on host \Zb\Z1<$1>\Zn):" 15 80 $2 2>&1 >/dev/tty)
	if [ $? -ne 0 ];then
            SDIR=999
        fi
	echo $SDIR
	echo "$FUNCNAME finished" >> $LOG
}
## @fn F_LOCSRC()
## @brief List and choose local repository files 
## @param 1 (required) Target group
## @return choosen local hosted files
F_LOCSRC(){
    F_LOG $FUNCNAME "started with $1"
    unset SDIR OPTIONS
    TG="$1"
    [ ! -d "$REPODIR" ]&& F_LOG $FUNCNAME "Cannot determine repo dir <$REPODIR>!! ABORTED" && return 3

    # ensure only apps that are not already linked will be shown
    LINKEDAPPS=$(F_LISTAPPS "$TG" | grep pors-hosted| cut -d ":" -f 2-3)
    AVAILAPPSFP=$(for tgzf in $(find $REPODIR -type f |egrep "(tar|tgz|spl)");do echo "$tgzf";done)
    AVAILAPPNAMES=$(for tgz in $AVAILAPPSFP;do APPN=$(tar tf "$tgz" 2> /dev/null |head -n1 | cut -d '/' -f1) ; echo "${APPN}:${tgz##*/}" ;done)
    UNLINKEDAPPS=$(echo "$LINKEDAPPS" "$AVAILAPPNAMES" | tr " " "\n" | sort | uniq -u)

    F_LOG $FUNCNAME "linked: $LINKEDAPPS\n\navail: ${AVAILAPPNAMES}\n\nunlinked: $UNLINKEDAPPS"

    OPTIONS=($(for tgz in $UNLINKEDAPPS;do echo "${tgz/*:}" "${tgz/:*}" off; done | sort))
    SDIR=$(F_DIALOG --checklist "Please use the space-bar to make your selection:" 40 100 40 "${OPTIONS[@]}" 2>&1 >/dev/tty)
    if [ $? -ne 0 ]||[ -z "$SDIR" ];then
        SDIR=EMPTY
    fi
    echo "$SDIR"
    F_LOG $FUNCNAME ended
}

## @fn F_EXPANDHOSTS()
## @brief create an expanded list of hostnames
## @param 1 target group name
## @param 2 optional: expandfile (file where the hosts will be written)
## @param 3 optional: requires param2. force a clean file write (removes any prev hosts). Can be specified also as an environment variable: CLEANHOSTFILE=clean
## @return space delimited list with the expanded list of hostnames
## @details expands a target group to a list of hostnames/ips defined in the users host file
F_EXPANDHOSTS(){
	F_LOG "$FUNCNAME" "started with these arguments: $1,$2,$3"
	unset RET TGFILE TGROUP CLEAN

	TGROUP="$1"
        CLEAN="$3"

        # check cleaning environment variable
        [ ! -z "$CLEANHOSTFILE" ] && CLEAN=clean

	source "$AEUSRHOSTFILE"

	if [ -f "$HOSTFILE" ];then
            TGFILE="$2"
	    [ -z "$TGFILE" ] && TGFILE="$AINVENTORY/$TARGETENV/${FUNCNAME}_${TGROUP}"

            [ "$CLEAN" == "clean" ] && CLEANVAR="clean_tmp='yes'" && F_LOG $FUNCNAME "Will CLEAN $TGFILE because CLEAN = $CLEAN, CLEANHOSTFILE = $CLEANHOSTFILE"

	    # get all hosts via playbook (will expand groups in groups etc)
            [ ! -s $VAULTTEMPFILE ] && [ "$ENABLEVAULT" == "yes" ] && F_VAULTPW
	    F_LOG $FUNCNAME "$ABIN -i $HOSTFILE $PBGETTARGETS -e target=$TGROUP expandfile=$TGFILE"
	    $ABIN -i $HOSTFILE $PBGETTARGETS -e "target=$TGROUP expandfile=$TGFILE $CLEANVAR" 2>&1 | sort >> $LOG
            F_RMVAULTPW

	    # parse the resulted FILE and massage its content
	    if [ -r "$TGFILE" ];then
                RET=$(sort -u ${TGFILE}.nogrp)
            else
	      	# bark no error to the calling function but an error message in log
              	F_LOG $FUNCNAME "WARNING: cant read/find $TGFILE! Empty group??"
	      	RET="EMPTY"
            fi
	else
		F_LOG $FUNCNAME "ERROR: HOSTFILE $HOSTFILE NOT FOUND!"
	fi
	echo "$RET"
	F_LOG "$FUNCNAME" finished
}

## @fn F_VALCONF()
## @brief validate a dir if it contains conf files (system/local related)
F_VALCONF(){
	echo "$FUNCNAME started" >> $LOG
	find $1 -type f |grep -q "\.conf"
	if [ $? -ne 0 ];then
		F_DIALOG --msgbox "ERROR:\n\nThe path >$1< contains no single conf file!" 10 50
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_CLEANCONF()
## @brief delete empty conf files (system/local related)
F_CLEANCONF(){
	echo "$FUNCNAME started" >> $LOG
	CDIR=$1
	for cfile in $(find $CDIR -type f -name *.conf);do
		[ ! -s "$cfile" ]&& echo "$cfile is empty! Will remove it" >> $LOG && rm -v "$cfile" >> $LOG
	done
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_DIAERR()
## @brief dialog box providing errorcode
F_DIAERR(){
	echo "$FUNCNAME started with args: $@" >> $LOG
	ERRC="$1"
	TASK="$2"

	[ -z "$ERRC" ]&&echo ERRORCODE MISSING for $FUNCNAME && F_EXIT

	if [ "$ERRC" != "0" ];then
		F_DIALOG --colors --msgbox "ERROR:\n\nTask\n\n$TASK\n\nended with errorcode >$ERRC<!" 50 150
		# TODO: option to abort completely?
	else
		F_DIALOG --colors --msgbox "SUCCESS:\n\nTask\n\n$TASK\n\nended successfully" 20 100
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_ERRLOG()
## @brief dialog box very similar to F_DIAERR but givin an option to display a given logfile
## @param1 required: error code number
## @param2 required: task name / description to show
## @param3 optional: full path to the log file to show (defaults to $LOG)
F_ERRLOG(){
        echo "$FUNCNAME started" >> $LOG
        ERRC="$1"
        TASK="$2"
	DLOG="$3"

        [ -z "$DLOG" ] && DLOG=$LOG

        [ -z "$ERRC" ]&&echo ERRORCODE MISSING for $FUNCNAME && F_EXIT

        if [ "$ERRC" != "0" ];then
                F_DIALOG --colors --extra-button --extra-label "Inspect" --msgbox "ERROR:\n\nTask:\n\n${TASK}\n\nended with errorcode >$ERRC<!" 20 150
                # TODO: option to abort completely?
		exit_status=$?
        else
                F_DIALOG --colors --extra-button --extra-label "Inspect" --msgbox "SUCCESS:\n\nTask:\n\n${TASK}\n\nended successfully" 20 150
		exit_status=$?
        fi
	if [ $exit_status -eq 3 ]; then
		F_DIALOG --colors --textbox "$DLOG" 50 200
	fi
        echo "$FUNCNAME finished" >> $LOG

}

## @fn F_WAITBOX()
## @brief display a wait box (very useful when something is done in the background)
## @param 1: a short message to display
## @details allows a 1-line (!) message where the wait box width gets sized dynamically based on the text length
F_WAITBOX(){
        unset MSG
	MSG="$1"
        MINLENGTH=$(F_MSGLEN "PORS v$VERSION/$MAXAVERSION (${TARGETENV})")
        MSGLENGTH=$(F_MSGLEN "$MSG")
        [ "$MSGLENGTH" -lt "$MINLENGTH" ] && MSGLENGTH=$MINLENGTH
	F_DIALOG --infobox "\n$MSG" 5 $MSGLENGTH
}

## @fn F_MSGLEN()
## @brief specify the length of a message
## @return Message length
## @param1 required: the message length
F_MSGLEN(){
    F_LOG $FUNCNAME "started with $1"
    MSG="$1"
    MSGLENGTH=$((${#MSG} + 6))
    F_LOG $FUNCNAME "calculated a message length of: $MSGLENGTH"
    echo $MSGLENGTH
    F_LOG $FUNCNAME ended
}

## @fn F_SETREPODIR()
## @brief Set the local repository variable in PORS 
## @return The directory name where the local repository is defined. On error it will return nothing.
## @details Set the local repository variable in PORS
F_SETREPODIR(){  
    F_LOG $FUNCNAME started
    # local repository definition configuration file for tgz's  
    REPODEF=$AINVENTORY/$TARGETENV/group_vars/all/splunk_repository.yml

    # extract repo dir for apps
    REPODIR="$(grep ^repo_base $REPODEF|cut -d ":" -f 2|tr -d " ")"
    if [ -z "$REPODIR" ];then
        REPODIR="$(grep ^repo_base $DEFAULTSYML |cut -d ":" -f 2|tr -d " ")"
    fi
    REPODIRS="${REPODIR}/${TARGETENV}/apps/splunk ${REPODIR}/${TARGETENV}/apps/other"
    for d in $REPODIRS;do [ ! -d "$d" ] && mkdir -p $d;done

    # return only the repo dir when its a valid directory
    if [ -d "$REPODIR" ];then
        echo "$REPODIR"
    fi

    F_LOG $FUNCNAME "repo dir: $REPODIR"
    F_LOG $FUNCNAME ended
}

## @fn F_ENAPP()
## @brief links an app for a host/target in PORS
F_ENAPP(){
	echo "$FUNCNAME started" >> $LOG
	unset HOSTFILE
	F_HOSTFILE
	unset HOSTSELEXPANDED ABORTED HTARGETS HOSTSELECT OPTIONS

	# extract repo dir for apps
	#REPODIR="$(grep repository_root $REPODEF|cut -d ":" -f 2|tr -d " ")/apps"

        REPODIR="$(F_SETREPODIR)/${TARGETENV}/apps"
        [ ! -d "$REPODIR" ] && mkdir -p $REPODIR && F_LOG $FUNCNAME "REPODIR: $REPODIR has been created"

        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS radiolist)
		[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
                 if [ -z "$HOSTSELECTION" ];then
                     F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
                 else
                     HOSTSELECT=1
                     ABORTED=0
                 fi
        done
        if [ "$ABORTED" -ne 0 ];then
                echo "DEBUG: aborted by user."
        else
		# LOCAL or GIT
		ENSRC=$(F_DIALOG --menu "\nChoose an option:" \
                        15 76 14 \
                        github "choose app(s) from a github server" \
                        gitlab "choose app(s) from a gitlab server" \
                        local "choose app(s) from a local file on the PORS server" \
                        3>&1 1>&2 2>&3)
		
		case $ENSRC in
			local)
			unset SELAPPS
			# TODO: select apps then choose hosts
			SELAPPS=$(F_LOCSRC "$HOSTSELECTION")
                        [ $? -ne 0 ] && F_ERRLOG 3 "issue occured while parsing local apps" $LOG  && return 3
		        if [ -z "$SELAPPS" ]||[ "$SELAPPS" == "EMPTY" ];then
                            F_DIALOG --msgbox "\n\nEither\n$REPODIR\nis empty or all local available apps are linked to $HOSTSELECTION already ..." 15 76
                        else
			    # atm we have to use group otherwise we have to switch group_vars to targetgroup/host/ as well	
                	    #SELHOSTS=$(F_SHOWHOSTS "checklist" "$HOSTSELEXPANDED")
	               	    #HOSTSELEXPANDED="$(F_EXPANDHOSTS "$HOSTSELECTION")"
			    # enable app for each target group
			    for tapp in $SELAPPS;do
				    F_WAITBOX "... linking $tapp ..."
				    app_fulldir=$(find $REPODIR -type f -name $tapp |egrep "(tar|tgz|spl)")
				    app_dir=${app_fulldir%/*}
				    app_type=$(echo "$app_dir" | egrep -o '(/other$|/splunk$)')
				    F_LOG $FUNCNAME "app_fulldir: $app_fulldir, app_dir: $app_dir, app_type: $app_type"
				    if [ "$app_type" == "/other" -o "$app_type" == "/splunk" ];then
				        app_name=$(tar tf "$app_fulldir" 2> /dev/null |head -n1 | cut -d '/' -f1)
				    else
				        app_name=${app_dir##*/}
				        app_type="/${app_name}"
				    fi
				    for tgroup in $HOSTSELECTION;do
					    F_GVARDIR $tgroup
                                            F_APPTPLUPDATE "${ROLEDIR}/apps/app.template" "$DATADIR/custom/roles/apps" "$app_name"
					    echo -e "will start playbook:\n$ABIN -i $HOSTFILE $PBENAPP -e \"app_type=$app_type app_name=$app_name app2group=$tgroup filename=$tapp git_url='' git_branch='' pors_data_dir=$DATADIR\":\n" >>$LOG
					    $ABIN -i $HOSTFILE $PBENAPP -e "app_type=$app_type app_name=$app_name app2group=$tgroup filename=$tapp git_url='' git_branch='' pors_data_dir=$DATADIR" 2>> $LOG 1>> /dev/null
					    [ $? -ne 0 ] && F_ERRLOG "1" "linking $app_name to $tgroup\n\n" "$LOG"
				    done
			    done
			    F_ERRLOG 0 "Linking apps finished" "$LOG"
                        fi
			;;
                        github|gitlab)
                        unset SELAPPS CSELAPPS OPTIONS PREAPPS RMAPPS LAPPS GITAPP
                        # get git repos
                        F_WAITBOX "Please standby until all $ENSRC locations have been parsed..."
                        CSELAPPS=$(F_FETCHGITREPOS $ENSRC | tr ',' '\n' ; return ${PIPESTATUS[0]})
                        REPERR="$?"
                        [ $REPERR -ne 0 ] && F_ERRLOG $REPERR "parsing repos" $LOG && return 3

                        # ensure only apps that are not already linked will be shown
                        PREAPPS="${CSELAPPS}"
                        RMAPPS=$(for gh in $(F_LISTAPPS "$HOSTSELECTION" | grep git-hosted | cut -d ":" -f 2);do echo "$gh\n";done)
                        LAPPS=$(for papp in $PREAPPS;do prea="$(echo ${papp##*/}| cut -d '=' -f 1)"; echo "${prea/\.git/}" ;done)
                        SELAPPS=$(echo -e "${LAPPS}\n${RMAPPS}" | sort |uniq -u)

                        F_LOG $FUNCNAME "RMS: $RMAPPS\n\nPREAPPS: ${PREAPPS}\n\nSELAPPS: $SELAPPS\n\nCSELAPPS: $CSELAPPS\n\nLAPPS: $LAPPS"
                        OPTIONS=($(for gapp in $SELAPPS;do prea="$(echo ${gapp##*/} | cut -d '=' -f 1)"; echo "${prea/\.git*/}" "$ENSRC" off; done))
                        GITAPP=$(F_DIALOG --checklist "\nPlease use the space-bar to make your selection:" 80 80 70 "${OPTIONS[@]}" 2>&1 >/dev/tty)
                        if [ $? -eq 0 ]&&[ ! -z "$GITAPP" ];then
                            for gapp in $GITAPP;do
				F_WAITBOX "... linking $gapp ..."
                                app_full=$(echo -e "$CSELAPPS" | cut -d "=" -f 1 | egrep "(/${gapp}$|/${gapp}\.git$)")
#                                git_url=$(echo "$app_full" | sed 's#://#://{{ vault_git_ro_user }}:x-oauth-basic@#g')
                                git_branch=$(echo -e "$CSELAPPS" | egrep "$app_full" | cut -d "=" -f 2)
                                app_dir=${app_full%/*}
                                app_namespace=${app_dir##*/}
                                F_LOG $FUNCNAME "gapp: $gapp, app_full: $app_full, app_dir: $app_dir, appnamespace: $app_namespace" 
                                for tgroup in $HOSTSELECTION;do
                                    F_GVARDIR $tgroup
                                    F_APPTPLUPDATE "${ROLEDIR}/apps/app.template" "$DATADIR/custom/roles/apps" "$gapp"
                                    LERR=$?
                                    [ $LERR -ne 0 ] && F_ERRLOG "$LERR" "Linking app template" $LOG && return $LERR
                                    # TODO: may have an option for choosing branch?!
                                    F_ABIN $HOSTFILE $PBENAPP "Enable App" "-e {'app_name':'$gapp','app2group':'$tgroup','filename':'','git_url':'$app_full','git_branch':'$git_branch','pors_data_dir':'$DATADIR'}"  2>> $LOG 1>> /dev/null
                                    LASTERR=$?
                                    [ $LASTERR != 0 ] && F_ERRLOG "$LASTERR" "linking\n\n$gapp\n\nto $tgroup\n\n" "$LOG" && return $LASTERR
                                done
                            done
                            F_ERRLOG 0 "linking $GITAPP to $tgroup\n\n" "$LOG"
                            F_PORSACTION "linking app(s)" "$FUNCNAME | linked $GITAPP to $tgroup"
                        else
                            F_DIAERR 4 "Aborted by user"
                        fi
                        ;;
			*)
			echo NO SELECTION MADE..
			;;
		esac
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_FETCHGITREPOS()
## @brief get all available git repos
## param1: required: git server type (gitlab, github)
## @details fetches all repositories accessible by a defined token (vault)
F_FETCHGITREPOS(){
    F_LOG $FUNCNAME "started with $1"

    unset STYPE PLAYBOOK
    STYPE="$1"
    REPOFILE="/tmp/pors/${STYPE}.repos"

    case $STYPE in
        github) PLAYBOOK="$PBGHFETCHREPOS" ;;
        gitlab) PLAYBOOK="$PBGLFETCHREPOS" ;;
        *) F_LOG $FUNCNAME "git server type missing or unsupported: $STYPE" && return 3 ;;
    esac

    F_ABIN "$HOSTFILE" "$PLAYBOOK" "\Za\Z1Collecting repositories...\Z\n" "--limit pors_server -e {'git_tmp_repos_file':'${REPOFILE}'}" 2>> $LOG 1>> /dev/null
    RET=$?
    [ $RET -ne 0 ] && F_LOG $FUNCNAME "Error while collecting repos" && return $RET

    # output all repo locations to the calling function
    sort -u ${REPOFILE} || return $?
    F_LOG $FUNCNAME ended
}

## @fn F_MSG()
## @brief Just showing a simple message box
## param 1: required: message to show
## param 2: optional: window width
## param 3: optional: window height
F_MSG(){
        F_LOG $FUNCNAME "started with $1, $2, $3"
        unset MSG MSGWIDTH MSGHEIGHT
	MSG="$1"
        MSGHEIGHT=$2
        MSGWIDTH=$3
        [ -z $MSGWIDTH ] && MSGWIDTH=100
        [ -z $MSGHEIGHT ] && MSGHEIGHT=10

	[ -z "$MSG" ]&& echo "FATAL: missing req arg in $FUNCNAME! ABORTED!" && F_EXIT
	F_DIALOG --msgbox "$MSG" $MSGHEIGHT $MSGWIDTH
	F_LOG $FUNCNAME "finished"
}

## @fn F_TPLUPDATE()
## @brief updating target dirs based on the template dir
## @details ensures consistent & updated tasks for all config folders
F_TPLUPDATE(){
	echo "$FUNCNAME started with: $1, $2" >> $LOG
	# required argument: targetgroup/hostname
	unset ROLEPATH
	
	FRPATH="$1"
	ROLEPATH="$2"

	if [ -z "$ROLEPATH" ]||[ ! -d "$FRPATH" ];then
		echo "FATAL: missing req arg in $FUNCNAME! $ROLEPATH and $FRPATH. ABORTED!" && F_EXIT
	fi

	if [ -d $FRPATH/$ROLEPATH ];then
		for i in $ROLEPATH;do
			cp -av $FRPATH/template/* $FRPATH/$i/ >>$LOG
			[ $? -ne 0 ]&&echo "FATAL: Cannot copy template to $FRPATH/$i/ !" && F_EXIT
		done
	else
		F_LOG $FUNCNAME "ERROR: cannot find specified path: $ROLEPATH!"
                return 3
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_APPTPLUPDATE()
## @brief updating target dirs based on the APP template dir
## @param 1 required: app.template path
## @param 2 required: custom data path (usually /opt/pors_data)
## @param 3 required: app name
## @details ensures consistent tasks for all config folders
F_APPTPLUPDATE(){
        F_LOG "$FUNCNAME" "started with $1,$2,$3"
        unset ROLEPATH FRPATH APPNAME LINKDIR TROLEPATH

        FRPATH="$1"
        ROLEPATH="$2"
        APPNAME="$3"

        if [ -z "$ROLEPATH" ]||[ ! -d "$FRPATH" ];then
                echo "FATAL: missing req arg in $FUNCNAME! $ROLEPATH and $FRPATH. ABORTED!" && F_EXIT
        fi

        TROLEPATH="${ROLEPATH}/${APPNAME}"
        [ ! -d "$TROLEPATH" ] && mkdir -p $TROLEPATH && F_LOG $FUNCNAME "created $TROLEPATH"

        F_LOG $FUNCNAME "target: $TROLEPATH"

        # copy whats needed but link tasks only because other then with vars etc they are never app specific
        for d in $(find "$FRPATH" -maxdepth 1 -mindepth 1 -type d);do
            dshort="${d/*\//}"
            LINKDIR="$TROLEPATH/${dshort}"
            F_LOG $FUNCNAME "processing: $LINKDIR"
            case $dshort in
                tasks)
                    [ -L "$LINKDIR" ] && F_LOG "$FUNCNAME" "link to $LINKDIR already set" && continue
                    [ -d "$LINKDIR" ] && F_LOG "$FUNCNAME" "removing deprecated dir: $LINKDIR as we are using links now" && rm -rvf "$LINKDIR" >> $LOG 2>&1
                    ln -vsf $d $LINKDIR >> $LOG 2>&1 && F_LOG $FUNCNAME "link from $d to $LINKDIR created"
                ;;
                *)
                    [ -d "$LINKDIR" ] && F_LOG "$FUNCNAME" "clean dir: $LINKDIR" && rm -rvf "$LINKDIR" >> $LOG 2>&1
                    cp -avf $d $LINKDIR 1> /dev/null 2>> $LOG ;;
            esac
        done
        if [ -L "$TROLEPATH/defaults" ];then
            F_LOG "$FUNCNAME" "link to $TROLEPATH/defaults already set"
        else
            ln -fvs $ADIR/roles/defaults $TROLEPATH >> $LOG 2>&1 && F_LOG $FUNCNAME "created roles/defaults in $TROLEPATH dir"
        fi
        F_PORSACTION "app template enrolled" "$FUNCNAME | app template enrolled to $TROLEPATH"
        [ $? -ne 0 ] && F_LOG $FUNCNAME "FATAL: Cannot link template to $ROLEPATH !" && return 3
        F_LOG "$FUNCNAME" "finished"
}

## @fn F_PULLSYSC()
## @brief pull system/local configs for remote server (system/local related)
F_PULLSYSC(){
	echo "$FUNCNAME started" >> $LOG
	ABORTED=0
	AUTO="$1"
        FSYSDIR="$2"

        # create a temporary ansible group (must be in the correct env path! otherwise variables cant be found)
        ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
        > $ITMPGRP

	if [ -z "$AUTO" ];then
		[ -z "$HOSTFILE" ]&& F_HOSTFILE
		unset HOSTSELEXPANDED ABORTED SYScDIR HOSTSELECT HOSTSELECTION
       		while [ -z "$HOSTSELECT" ];do
			HOSTSELECTION=$(F_TARGETS radiolist)
			[ $HOSTSELECTION == "ABORTED" ] && ABORTED=1 && break
       	        	if [ -z "$HOSTSELECTION" ];then
       	              		F_DIALOG --msgbox "ERROR: no selection made. Choose 1 or more targets with space bar." 10 30
       	          	else
       	              		HOSTSELECT=1
			     	ABORTED=0
       	          	fi
        	done
	fi

	if [ "$ABORTED" -ne 0 ];then
		echo "$FUNCNAME: aborted by user." >>$LOG
		echo ABORTED
	else
		if [ -z "$AUTO" ];then
			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION" $ITMPGRP clean)
			[ "$HOSTSELEXPANDED" == "ERROR" ]&& echo "FATAL: problem with expanding hosts for $HOSTSELECTION" && F_EXIT
			[ "$HOSTSELEXPANDED" == "EMPTY" ]&& F_LOG $FUNCNAME "Warning $HOSTSELECTION is empty?!"
		else
			HOSTSELEXPANDED="$AUTO"
		fi

		# set temporarly to always pull.
		# TODO: decide to make this configurable as a general user defined setting
		#ANS=$(F_SSHORNOT)
		ANS=Pull

		case "$ANS" in
			ABORTED)
			# return abort state
			echo ABORTED
			break
			;;
			DANGEROUS-Skip)
			echo SKIPPED
			;;
			DANGEROUS-Import|Pull)
	  		    for host in $(echo "$HOSTSELEXPANDED"| cut -d : -f1);do
				OWNDIR=$HOSTSELECTION/$host
                                if [ -z "$FSYSDIR" ];then
				    SYScDIR=${DATADIR}/system/$OWNDIR
                                else
                                    SYScDIR="$FSYSDIR"
                                fi
				if [ ! -d "$SYScDIR/files" ];then
				    mkdir -p "$SYScDIR"
		    		TPLMSG="Base directory structure created!"
				else
                                    rm -vf "$SYScDIR" && mkdir -p "$SYScDIR"
				    TPLMSG="Target dir exists already. CLEANED!"
				fi
	
				# this initiates the template files but also ensures that we keep all tasks and stuff current!
				F_TPLUPDATE "${ROLEDIR}/system" $OWNDIR
	
				# do stuff based on user selection
				if [ "$ANS" == "DANGEROUS-Import" ];then
				   SELDIR=$(F_DBROWSE "$host" /TYPE-IN-LOCAL-DIR)
				   [ "$SELDIR" == "999" ] && echo "breakout!" && break
				   while [ ! -d "$SELDIR" ]&&[ "$SELDIR" -ne 999 ];do
					F_DIALOG --msgbox "ERROR:\n\nThe path you entered is not a directory!" 10 50
					SELDIR=$(F_DBROWSE $host /TYPE-IN-LOCAL-DIR)
				   done
				   [ "$SELDIR" == "999" ] && break
				else
				    if [ ! -z "$REMDIR" ];then
					REMPATH="$REMDIR"
				    else
					REMPATH="/opt/splunk/etc/system/local/"
				    fi
				    # disabled user conf temporarly
				    # TODO: put this into a general setting store instead?
				    #REMDIR=$(F_DBROWSE "$host" "$REMPATH")
				    REMDIR=$REMPATH

				    echo "$FUNCNAME remdir: $REMDIR" >> $LOG
				    if [ "$REMDIR" == "999" ];then
					echo "$FUNCNAME: aborted!" >> $LOG
					ABORTED=1
				    else
					    SELDIR="/tmp/$host"
                                            [ -d "$SELDIR" ] && rm -rf $SELDIR
					    F_DIMPORT $host "$REMDIR" "$SELDIR"
                                            SCPERR=$?
					    echo "$FUNCNAME: SCPERR was $SCPERR" >> $LOG
					    [ $SCPERR -ne 0 ]&& F_MSG "ERROR: Problem while importing from >$host<"
				    fi
				fi
				if [ "$ABORTED" != "1" ];then
					F_VALCONF "$SELDIR"
					F_CLEANCONF "$SELDIR"
					# again! because clean could had cleaned all..
					F_VALCONF "$SELDIR"
					cp -v $SELDIR/*.conf $SYScDIR/system_local_configs/files/system/local/ >> $LOG 2>&1
					CPERR=$?
					echo "$FUNCNAME: CPERR was $CPERR" >> $LOG
					# ask if you want to manage all files or a subset only
					#F_ASKMANAGE "$SYScDIR"
				fi
			    done
			    if [ "$SELDIR" != "999" ]&&[ "$ABORTED" != "1" ];then
				echo "$FUNCNAME: not aborted" >> $LOG
				if [ $CPERR -eq 0 ]&&[ $SCPERR -eq 0 ] ;then
					echo "$FUNCNAME: all files copied fine" >> $LOG
					#F_DIALOG --msgbox "DONE:\n\nAll files copied successfully." 15 80
				else
					F_LOG $FUNCNAME "ERROR: A problem occurred while copying your source files\nsrc: $SELDIR/*.conf\ndst: $SYScDIR/system_local_configs/files/system/local/"
					echo "ERROR"
					#F_DIALOG --msgbox "ERROR:\n\nA problem occurred while copying your source files!" 10 50
				fi
			    else
				echo "$FUNCNAME: ABORTED" >> $LOG
				echo "ABORTED"
			    fi
			;;
			*) # this should never happen
			echo "$FUNCNAME - ERROR: No valid arg for case ($ANS)" >> $LOG
			echo "$FUNCNAME:ERROR"
			F_EXIT
			;;
		esac
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_SHOWHOSTS()
## @brief shows hostnames in an expanded target group
F_SHOWHOSTS(){
	F_LOG $FUNCNAME "started"
	unset OPTIONS HTARGETS HOSTSELEXPANDED host ABORTED DIAOPT
	DIAOPT="$1"
	HOSTSELEXPANDED="$2"
	[ -z "$DIAOPT" ]&& echo "ABORTED! Missing arg for dialog in $FUNCNAME!" && return 1
	[ -z "$HOSTSELEXPANDED" ]&& echo "ABORTED! Missing arg for target group in $FUNCNAME!" && return 2

	OPTIONS=($(for host in $HOSTSELEXPANDED;do echo "$host $host off";done))

        while [ -z "$HTARGETS" ];do
	      ABORTED=0
              HTARGETS=$(F_DIALOG --${DIAOPT} "\nThe following are members of the choosen target group(s)\n<$HOSTSELECTION>\n\nMake your selection:" 30 80 50 "${OPTIONS[@]}" 2>&1 >/dev/tty)
              [ $? -ne 0 ] && return 4
	      F_LOG $FUNCNAME "HTARGETS (while): >$HTARGETS<"
        done
	F_LOG $FUNCNAME "HTARGETS (end): $HTARGETS"
	F_LOG $FUNCNAME "finished"
	# return host objects to the calling function
	[ "$ABORTED" -eq 0 ] && echo "$HTARGETS"
}

## @fn F_CHOOSEENV()
## @brief show available target environments to the user and let the user select one
F_CHOOSEENV(){
	# returns the choosen environment so call this function like:
	# ENVCHOICE="$(F_CHOOSEENV)"
	F_LOG $FUNCNAME "started"

        OPTIONS=($(for inv in $(find $AINVENTORY/* -maxdepth 0 -type d);do echo "${inv##*/} $inv off";done | sort -r))

        while [ -z "$ENVTARGET" ];do
              ABORTED=0
              ENVTARGET=$(F_DIALOG --radiolist "\nYou HAVE TO choose an environment first.\n\nThe following are the available environment(s) based on\n<$AINVENTORY>\n\nMake your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
              [ $? -eq 1 ] && ABORTED=1 && break
              F_LOG $FUNCNAME "ENVTARGET (while): >$ENVTARGET<"
        done
        F_LOG $FUNCNAME "ENVTARGET (end): $ENVTARGET"
        F_LOG $FUNCNAME "finished"
        # return objects to the calling function
        [ "$ABORTED" -ne 0 ] && ENVTARGET="ABORTED"
	echo "$ENVTARGET"
}

## @fn F_EDITSYSC()
## @brief manage local conf files (system/local related)
F_EDITSYSC(){
	echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED SYScDIR HOSTSELECT EDITHOST host
	F_HOSTFILE

        # create a temporary ansible group (must be in the correct env path! otherwise variables cant be found)
        ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
        > $ITMPGRP

        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS radiolist)
		if [ "$HOSTSELECTION" == "ABORTED" ];then
			ABORTED=1 && break
		else
                 	if [ -z "$HOSTSELECTION" ];then
                     		F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                 	else
                     		HOSTSELECT=1
                     		ABORTED=0
                 	fi
		fi
        done
        if [ "$ABORTED" -eq 1 ];then
                echo "$FUNCNAME: aborted by user." >> $LOG
        else
		HABORTED=0
		while [ $HABORTED -ne 1 ];do
			#TODO: ask if the user want to edit/open a path or manage previously pulled conf files
			# e.g. to say for the shc group do not manage authorize.conf

			HOSTSELEXPANDED=$(F_EXPANDHOSTS "$HOSTSELECTION" $ITMPGRP clean |cut -d : -f1)
			EDITHOST="$(F_SHOWHOSTS radiolist "$HOSTSELEXPANDED")"
			[ $? -eq 1 ] && HABORTED=1 && break

			SYSBASEDIR=${DATADIR}/system_local/$HOSTSELECTION/$EDITHOST
			SYSDIR=${SYSBASEDIR}/system_local_configs/files/system/local
                        mkdir -p $SYSDIR

			PERR=$(F_PULLSYSC "$EDITHOST" "$SYSBASEDIR")
			[ "$PERR" == "ABORTED" -o "$PERR" == "ERROR" ] && HABORTED=1 && unset SELECTION &&break 
			
			echo "$FUNCNAME: Continuing after pull selection ($PERR)" >> $LOG

			unset OPTIONS
       			OPTIONS=($(for hostfile in $(find $SYSDIR -type f) ;do echo "${hostfile##*/}" "file";done|sort -f))
		        while [ -z "$FTARGET" ];do
				unset DIROPENED
        	      		FTARGET=$(F_DIALOG --colors --extra-button --ok-label "Open file" --extra-label "Open directory" --cancel-label "Finish" --menu "\nThe following are files currently active for the given host\n\n\Zb\Z1<$EDITHOST>\Zn\n\nChoose one file for editing:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
				FERR=$?
				if [ $FERR -eq 1 ];then
					ABORTED=1
					unset FTARGET && break
				else
					# if the user uses the extra button we open a dir on CLI
					if [ $FERR -eq 3 ];then
						DIROPENED=1
						unset FTARGET
						clear
						echo -e "\n\nSwitching to directory: $SYSDIR"
						echo -e "\n***********************************************************************"
						echo -e "** Go back by typing <exit> or <CTRL+D>"
						echo -e "***********************************************************************\n"
						bash --rcfile <(echo "PS1=\"$EDITHOST/system/local \$>\";cd $SYSDIR/ && ls -la")
                                                F_PORSACTION "system/local changed" "$FUNCNAME | system/local changed on $EDITHOST"
					else
						if [ -z "$FTARGET" ];then
               	           		      F_DIALOG --msgbox "ERROR: no selection made. Choose a file." 10 30
			                                ABORTED=1
               				        else
               	             			#FTARGET=1
			                                ABORTED=0
               	 		        fi
					fi
				fi
				# open file for editing
				if [ "$ABORTED" -eq 0 ]&&[ -z "$DIROPENED" ]&&[ "$HABORTED" -ne 1 ];then
					if [ -f $SYSDIR/${FTARGET} ];then
						$EDITBIN $SYSDIR/${FTARGET}
                                                F_PORSACTION "system/local changed" "$FUNCNAME | $EDITHOST -> $SYSDIR/${FTARGET} changed"
					else
						F_DIALOG --msgbox "NO FILES THERE?! Directory seems to be empty try a pull first" 10 30
						break
					fi
					unset FTARGET
				fi	
        		done
		done
	fi
	echo "$FUNCNAME finished" >> $LOG
}

## @fn F_SHELPER()
## @brief shelper UI
## @details Tasks using the shelper utility (incl. cluster-bundle deploy etc)
F_SHELPER(){
	F_LOG "$FUNCNAME" started
 	while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" \
			--menu "\nshelper the splunk helper tool.\n\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
			16 100 16 \
			"" "" \
			"Upgrade/Install" "Will install or upgrade shelper on given machines" \
			Exec "Will execute certain shelper commands on given machines" \
			"" "" \
			"" "" \
			3>&1 1>&2 2>&3)
		if [ "$?" != "0" ]; then
		    MENUDONE=1
		    echo "$0: finished."
		    return 4
		fi
		case "$SELECTION" in
			"Upgrade/Install")
			F_SHUPGRADE
			;;
			Exec)
			F_SHEXEC
			;;
		esac
	done
}

## @fn F_CALCTGROUP()
## @brief create a temporary target group with selected hosts
## @param 1 required: temporary filename
## @param 2 optional: temporary target group-name within the hosts file
## @param 3 optional: a given target group for just generating host names
## @exception when param1 missing
## @details calculate a temporary group based on user selected values
## the result is a list of hosts all added to one group which allows easy
## handling when running playbooks
F_CALCTGROUP(){
    F_LOG "$FUNCNAME" started
    unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup
    TMPGRP=aetmpgrp

	[ -z $1 ] && F_LOG $FUNCNAME "ERROR: missing filename for temp hosts file" && F_EXIT

    if [ ! -z "$3" ];then
        TMPGRP="$2"
        HOSTSELECT=1
        HOSTSELECTION="$3"
    else
        [ ! -z "$2" ] && TMPGRP="$2"
    fi

	CALCGRPF=${AINVENTORY}/${TARGETENV}/$1
        > $CALCGRPF

        F_HOSTFILE
    ABORTED=0
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS checklist)
                if [ "$HOSTSELECTION" == "ABORTED" ];then
			[ $? -ne 0 ] && return 4
                else
                        if [ -z "$HOSTSELECTION" ];then
                                [ $RUNMODE != "batch" ] && F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                                [ $RUNMODE == "batch" ] && F_EXIT 9
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	[ $ABORTED -eq 1 ] && return 4

	# ask for specific hosts or target group?
	unset HOSTLIST['expanded'] GRPSTATE
        #FIXME: 
        declare -A GRPSTATE

	[ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
	for hostlist in $HOSTSELECTION;do

                # FIXME: not needed anymore? -> avoid duplicated entries
                F_LOG $FUNCNAME "array is: ${GRPSTATE[$hostlist]}"
                [ ! -z "${GRPSTATE[$hostlist]}" ] && F_LOG $FUNCNAME "$hostlist already added, skipping.." && continue
                F_LOG "$FUNCNAME" "expanding $hostlist"

                NEWENT=$(F_EXPANDHOSTS $hostlist "$CALCGRPF" clean | egrep -v "(EMPTY|$hostlist)")
		if [ -z "${HOSTLIST['expanded']}" ];then
		    HOSTLIST['expanded']+="$NEWENT"
		else
		    HOSTLIST['expanded']+=" $NEWENT"
		fi
                GRPSTATE["$hostlist"]=1
	done

	unset EDITHOST
        if [ $RUNMODE != "batch" ];then
	    while [ -z "$EDITHOST" ];do
	        EDITHOST=$(F_SHOWHOSTS checklist "${HOSTLIST['expanded']}")
                [ $? -ne 0 ] && return $?
		if [ -z "$EDITHOST" ];then
			F_DIALOG --yesno "No selection made! Retry?" 10 40
			[ $? -ne 0 ] && return $?
		fi
	    done
        else
            EDITHOST="${HOSTLIST['expanded']}"
        fi
        F_LOG $FUNCNAME "using $EDITHOST as calc base"

	# make host list unique to avoid duplicated upgrades when a host is in multiple groups
	# number each entry,sort by name and remove dups, sort by num
	CALCEDHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	CALCEDHOSTST="$(echo "$CALCEDHOSTS" | sed 's/ /\\n/g')"
	UPGRADEHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\\n/g')"

	F_LOG "$FUNCNAME" "Will do action on: <$CALCEDHOSTS>"
	[ $? -ne 0 ] && return $?

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	echo '['$TMPGRP']' > ${CALCGRPF}
	for h in $CALCEDHOSTS;do echo "$h" >> $CALCGRPF && echo $h >> ${CALCGRPF}_nogrp ; done
	F_LOG "$FUNCNAME" "Temporary group: $(cat $CALCGRPF)"
}

## @fn F_NOGROUPUNIQ()
## @brief remove all group tags from a hosts file
## @details Removes all group stanza's, sort alphabetical and just write unique entries
## @param1 required: source host file name
## @param2 required: target file name
## @return 0: when everything is ok
## @return 3: when param1 is not a valid file
## @return any-other: grep errors
F_NOGROUPUNIQ(){
    F_LOG "$FUNCNAME" started
    unset SRCF TRGF

    SRCF="$1"
    TRGF="$2"

    if [ ! -f "$SRCF" ] || [ -z "$TRGF" ];then
        F_LOG $FUNCNAME "ERROR: missing SRCF or TRGF ($SRCF,$TRGF)"
        return 3
    fi

    egrep -v '^\[.*\]' $SRCF | sort -u > $TRGF
    RET=$?

    F_LOG $FUNCNAME "target file:\n$(cat $TRGF)"
    F_LOG "$FUNCNAME" "ended with $RET"
    return $RET
}

## @fn F_SPLACT()
## @brief splunk action/task/command
## @details will exec a (predefined) splunk action/task/command
## splunk_action=X (where X must be defined in common/handlers)
F_SPLACT(){ 
        F_LOG "$FUNCNAME" started
	unset SPLEXE HOSTSELECT SHEXE FLATHOSTS HOSTSELECTION SELHOSTS

        # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
        ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
        > $ITMPGRP

	while [ -z "$SPLEXE" ];do
		SPLEXE=$(F_DIALOG --radiolist "\nSelect with the space-bar an action:\n(pro tip: jump to an entry with the highlighted key shortcut)" 18 100 6 \
			stop "stop splunk>" off \
			start "start splunk>" off \
			restart "restart splunk>" off \
			restartweb "restart splunk> webservice only" off \
			custom "type any parameter you like (results in: bin/splunk <custom parapms>)" off \
			2>&1 >/dev/tty)
		ERR=$?
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			F_LOG "$FUNCNAME" "ABORTED due to err $ERR"
			return $ERR
		fi
	done

        if [ $SPLEXE == "custom" ];then
            while [ -z "$ACUST" ];do
                [ -z "$ACUST" ] && [ ! -z "$ECUST" ] && ACUST="$ECUST"
                ACUST=$(F_DIALOG --inputbox '\n\nType your custom splunk arguments.\ne.g. "btool --debug server list"' 20 100 "" 2>&1 >/dev/tty)
                [ $? -ne 0 ] && return $?
            done
            #ECUST=$(echo "$ACUST" | sed 's/ /SPACE/g')
            ECUST="$ACUST"
            # filter non ascii sed 's/[\d128-\d255]//g'
            unset ACUST
            SHEXE="custom"
        fi

        while [ -z "$HOSTSELECT" ];do
            HOSTSELECTION=$(F_TARGETS checklist)
            [ $? -ne 0 ] && return $?
            if [ "$HOSTSELECTION" == "ABORTED" ];then
                ABORTED=1 && break
            else
                if [ -z "$HOSTSELECTION" ];then
                    F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                else
                    HOSTSELECT=1
                    ABORTED=0
                fi
            fi
        done
        [ $ABORTED -eq 1 ] && return 4

        ACTGRP=aedosomething
        FINISHED=0

        [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
        for i in $HOSTSELECTION;do
            F_EXPANDHOSTS $i "$ITMPGRP" clean 1> /dev/null 2>>$LOG && echo -e "\n" >> $ITMPGRP
        done

        # make a flat and unique list without groups
        F_NOGROUPUNIQ $ITMPGRP ${ITMPGRP}_nogrp
        NERR=$?
        [ $NERR -ne 0 ] && F_ERRLOG "$NERR" "internal error while calculating 'nogrp' file" $LOG && return 3
        FLATHOSTS=$(cat ${ITMPGRP}_nogrp |tr '\n' ' ')

        # ask user which hosts he/she wants
        while [ -z "$SELHOSTS" ];do
            SELHOSTS=$(F_SHOWHOSTS checklist "${FLATHOSTS}")
            WERR=$?
            [ $WERR -eq 0 ] && [ ! -z "$SELHOSTS" ] && continue
            [ $WERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
        done

        unset PBH
        for i in ${SELHOSTS};do 
            if [ -z "$PBH" ];then
                PBH="${i/:*}"
            else
                PBH="$PBH:${i/:*}"
            fi  
        done
        PBARGS="--limit $PBH"
 
        EVARFILE=/tmp/pors_${FUNCNAME}
        echo -e "splunk_action: \"$SPLEXE\"\nsplunk_cmdparams: \"$ECUST\"\n" > $EVARFILE

        F_ABIN "$ITMPGRP" "$PBSPLACT" "running splunk $SPLEXE on $SELHOSTS ..." "$PBARGS" "$EVARFILE"
        LASTERR=$?
        F_ERRLOG "$LASTERR" "splunk <${SPLEXE}> ${ECUST} for:\n\n$SELHOSTS" "$LOG"
	F_LOG $FUNCNAME "ended with $LASTERR"
        F_PORSACTION "nogit" "$FUNCNAME | executed splunk $SPLEXE on $SELHOSTS"
        return $LASTERR
}

## @fn F_SHEXEC()
## @brief splunkhelper actions
## @details execute splunk helper commands
F_SHEXEC(){ 
    F_LOG "$FUNCNAME" started
    unset ANS TMPGRP ADDIGRP SCNDGRP LIMITLIST CLEANHOSTFILE

    # force cleaning the temp hosts file in F_EXPANDHOSTS()
    # must be explicitly unset for any subsequent tasks
    export CLEANHOSTFILE=yes

    if [ $RUNMODE != "batch" ];then
	while [ -z "$ANS" ];do
		ANS=$(F_DIALOG --radiolist "\nSelect with the space-bar your shelper action:\n(pro tip: jump to an entry with the highlighted key shortcut)" 15 100 6 \
			reload-all "shelperreload all - like a 'debug refresh'" on \
			DS-reload "reloads the serverclass on a DS (deploymentserver)" off \
			SHC-apply-cb "apply cluster-bundle on a DEP (deployer)" off \
			MN-apply-cb "apply cluster-bundle on a MN (masternode)" off \
			2>&1 >/dev/tty)
		ERR=$?
		#FIXME: disabled as it is nothing a regular user want to do actually:
                #	custom-reload "define your own reload command" off \
		echo "$FUNCNAME: err was $ERR" >> $LOG
		if [ $ERR -ne 0 ];then
			echo "$FUNCNAME: err was $ERR" >> $LOG
			ANS="ABORTED"
		fi
		# reset ans when the user has selected the hint text...
		[ "$ANS" == "----" ]&&unset ANS
	done
    else
        # use the batch parameter to set the action type
        ANS=$BATCHACT
        F_LOG "$FUNCNAME" "Using cli param $ANS for action type"
    fi

    case $ANS in
		custom-reload)
			unset SHCUST
			while [ -z "$SHCUST" ];do
                	  SHCUST=$(F_DIALOG --inputbox '\n\nType your custom reload arguments (space separated).\ne.g. "apps panels transforms searches"' 20 100 "" 2>&1 >/dev/tty)
                	  [ $? -ne 0 ] && return $?
        		done
			SHEXE="reload_custom"
			#SHCUST=$(echo $SHCUSTRAW | sed 's/ /SPACE/g')
		;;
		reload-all) SHEXE="reload_all" ;;
                DS-reload) SHEXE="reload_deploy_server" ;TMPGRP=deploymentserver ;;
                MN-apply-cb) SHEXE="apply_cluster_bundle" ; TMPGRP=masternode ;;
                SHC-apply-cb) SHEXE="apply_shcluster_bundle"; TMPGRP=deployer ;;
		*)	# TODO: do not exit but go to MAIN
			F_LOG $FUNCNAME "no answer given! aborted!"
			return 6
		;;
    esac

    if [ $RUNMODE == "batch" ];then
        TMPGRP=$BTARGET
        SITESEL=$TARGETSITE
    else
        if [ "$TMPGRP" == "deployer" ];then
            ASITES=$(F_GETSITES)
            OPTIONS=($(for i in $ASITES;do echo "${i} use_space-bar_to_select off"; done))
            SITESEL=$(F_DIALOG --radiolist "Please choose a site first.\n\nNOTE: It is not possible to exec on multiple sites in one run." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
            [ $? -ne 0 ] && return $?
            TMPGRP="${SITESEL}_deployer"
        fi
    fi
    F_LOG $FUNCNAME "Starting calc with $TMPGRP"

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
    if [ -z "$TMPGRP" ];then
        SHOSTS=$(LISTTYPE=checklist F_SELHOST)
    else
        SHOSTS=$(F_EXPANDHOSTS $TMPGRP)
    fi
    [ "$SHOSTS" == ABORTED ] && return 4

    # split ssh port from host
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g' | cut -d ':' -f 1)"
    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$SHOSTST" | tr '\n' ':' | sed 's/:$//g')
    if [ -z "$LIMITLIST" ];then
        if [ $RUNMODE != "batch" ];then
            F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3
        else
            F_ECHOLOG $FUNCNAME "ERROR: empty LIMITLIST! ABORTED"
            return 3
        fi
    fi

    if [ $RUNMODE != "batch" ];then
        F_DIALOG --colors --yesno "\nWill ${SHEXE}${SHCUST} on\n\n  \Zb$LIMITLIST\ZB\n\nOk?" 20 50
        [ $? -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && return 4
    fi

    ARGS="{'target':'$LIMITLIST','shelper_action':'$SHEXE','shelper_custom':'$SHCUST','shc_site':'$SITESEL'}"
    F_ABIN "${HOSTFILE}" "$PBSHRELOAD" "executing ${SHEXE}${SHCUST} ..." "--limit $LIMITLIST -e $ARGS"
    AERR=$?
    [ $RUNMODE != "batch" ] && F_ERRLOG "$AERR" "$SHEXE $SHCUST for:\n\n$SHOSTST" "$LOG"
    [ $RUNMODE == "batch" ] && F_ECHOLOG "$FUNCNAME" "$SHEXE $SHCUST for: $SHOSTST"
    F_PORSACTION "nogit" "$FUNCNAME | executed splunk $SHEXE on $SHOSTS"
    return $AERR
}

## @fn F_SHUPGRADE()
## @brief install/upgrade/use shelper
F_SHUPGRADE(){
        echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup
        F_HOSTFILE
        while [ -z "$HOSTSELECT" ];do
                HOSTSELECTION=$(F_TARGETS checklist)
                [ $? -ne 0 ] && return $?
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
                else
                        if [ -z "$HOSTSELECTION" ];then
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	[ $ABORTED -eq 1 ] && return 4

	PLPW=""
	SPLPWR=fail

	# ask for specific hosts or target group?
	unset HOSTLIST['expanded']
	F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
	for hostlist in $HOSTSELECTION;do
		if [ -z "${HOSTLIST['expanded']}" ];then
			HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		else
			HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
		fi
	done

	unset EDITHOST	
	while [ -z "$EDITHOST" ];do
	        EDITHOST=$(F_SHOWHOSTS checklist "${HOSTLIST['expanded']}")
		if [ -z "$EDITHOST" ];then
			F_DIALOG --yesno "No selection made! Retry?" 10 40
			[ $? -ne 0 ] && return $?
		fi
	done

	# make host list unique to avoid duplicated upgrades when a host is in multiple groups
	# number each entry,sort by name and remove dups, sort by num
	UPGRADEHOSTS=$(echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' ')
	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\\n/g')"

	F_LOG "$FUNCNAME" "Will upgrade/install shelper on: <$UPGRADEHOSTS>"
	F_DIALOG --scrollbar --yesno "\n\nWill upgrade/install shelper on these hosts:\n\n$UPGRADEHOSTST\n\nAre you sure?" 30 100
	[ $? -ne 0 ] && return $?

	# create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
	UTMPGRP=${AINVENTORY}/${TARGETENV}/shelperhosts
	echo '[tmpshmaint]' > $UTMPGRP
	for h in $UPGRADEHOSTS;do echo "$h" >> $UTMPGRP; done
	F_LOG "$FUNCNAME" "Temporary group: $(cat $UTMPGRP)"

 	F_LOG $FUNCNAME "F_ABIN $UTMPGRP $PBSHINSTALL '--limit tmpshmaint" | tee -a $LOG

	# do it
	F_ABIN "$UTMPGRP" "$PBSHINSTALL" "\Za\Z1UPGRADING/INSTALLING ...\Z\n" "--limit tmpshmaint" 
        F_ERRLOG "${PIPESTATUS[0]}" "shelper upgrade/install for:\n\n$UPGRADEHOSTST" "$LOG"
        F_PORSACTION "nogit" "$FUNCNAME | upgraded/installed splunk on $UPGRADEHOSTS"
}

## @fn F_GETAPICREDS()
## @brief ask for splunk_user and splunk_password vars - DEPRECATED - use VAULT instead
F_GETAPICREDS(){
	PLPW=""
	SPLPWR=fail

	while [ "$SPLPW" != "$SPLPWR" ];do
		[ -z "$PREUSR" ] && PREUSR=$DEFSPLAPIADMIN

		SPLUSR=$(F_DIALOG --inputbox '\n\nADMIN username for splunk API\n(only required for Indexer peer nodes - leave empty otherwise)' 20 100 $PREUSR 2>&1 >/dev/tty)
		[ $? -ne 0 ] && return $?
		PREUSR=$SPLUSR
		SPLPW=$(F_DIALOG --passwordbox '\n\nADMIN password for splunk API\n(supports only these special chars for sure: -,_,%,@)\nYOU WILL SEE NOTHING WHILE TYPING!' 20 100 2>&1 >/dev/tty)
		[ $? -ne 0 ] && return $?
		SPLPWR=$(F_DIALOG --passwordbox '\n\nTo verify the ADMIN password for splunk API write it again' 20 100 2>&1 >/dev/tty)
		[ $? -ne 0 ] && return $?
		[ "$SPLPW" != "$SPLPWR" ] && F_DIAERR "3" "ERROR: Passwords doesn't match!"
	done

	[ -z "$SPLPW" ]&& F_LOG $FUNCNAME "No password set!"
	echo "$SPLUSR:$SPLPW"
}

## @fn F_LISTSPLREPO()
## @brief Lists splunk versions in the local repo
## @param 1 optional: set splunk type (e.g. splunkforwarder)
## @return a list of splunk packages (filenames) ordered by version top-level down
## @details Lists available splunk versions in the local repository
F_LISTSPLREPO() { 
    F_LOG $FUNCNAME started
    unset SPLTYPE
    SPLTYPE=$1
    [ -z "$SPLTYPE" ] && SPLTYPE=splunk

    REPODIR="$(F_SETREPODIR)/common/packages/$SPLTYPE"
    find ${REPODIR} -maxdepth 1 -type f -name ${SPLTYPE}*tgz | tac | sed 's#.*/##g'
    F_LOG $FUNCNAME ended
}

## @fn F_DLSPLUNK()
## @brief Downloads a specific splunk release
## @param 1 required: set splunk type (e.g. splunkforwarder)
## @return success/error
## @details Takes an URL parses the relevant parts out of it and downloads splunk to the local repo
F_DLSPLUNK() { 
    F_LOG $FUNCNAME started
    unset VERINFO SPLTYPE
    SPLTYPE=$1

    while [ -z "$VERINFO" ];do
        if [ "$SPLTYPE" == "splunkforwarder" ];then
            VERINFO=$(F_DIALOG --colors --inputbox "This will download splunkforwarder based on a valid filename.\nGuide to get the valid filename:\n\n1) open (select the URL and use CTRL+SHIFT+C to copy / CTRL+SHIFT+mouseclick might work too):\n   \Zuhttps://www.splunk.com/en_us/download/previous-releases/universalforwarder.html#tabs/linux\ZU\n2) find the version you want and choose to download\n3) Cancel the download but identify the full file name including version and hash from the package name\n\nExample:\n\n\Zb${SPLTYPE}-7.0.1-2b5b15c4ee89-Linux-x86_64.tgz\ZB\n\n\nType or paste in the full file name ONLY (i.e. \Zbnot\ZB the full URL) and ensure it matches exact the format: \Zrsplunk-X.X.X-xxxxxxxxxxxx-Linux-x86_64.tgz (X.X.X = version, xxxxxxxxxxxx = hash)\ZR\n\n" 23 110 2>&1 >>/dev/tty || echo 1)
        else
            VERINFO=$(F_DIALOG --colors --inputbox "This will download splunk based on a valid filename.\nGuide to get the valid filename:\n\n1) open (select the URL and use CTRL+SHIFT+C to copy / CTRL+SHIFT+mouseclick might work too):\n   \Zuhttps://www.splunk.com/en_us/download/previous-releases.html#tabs/linux\ZU\n2) find the version you want and choose to download\n3) Cancel the download but identify the full file name including version and hash from the package name\n\nExample:\n\n\Zbsplunk-7.0.1-2b5b15c4ee89-Linux-x86_64.tgz\ZB\n\n\nType or paste in the full file name ONLY (i.e. \Zbnot\ZB the full URL) and ensure it matches exact the format: \Zrsplunk-X.X.X-xxxxxxxxxxxx-Linux-x86_64.tgz (X.X.X = version, xxxxxxxxxxxx = hash)\ZR\n\n" 23 110 2>&1 >>/dev/tty || echo 1)
        fi 
        F_LOG $FUNCNAME "input was: $VERINFO"
        [ "$VERINFO" == "1" ] && unset VERINFO && return 3
        
        echo "$VERINFO" | egrep -q "\w*-[0-9]*\.[0-9]*\.[0-9]*-\w*"
        if [ $? -eq 0 ];then
            NVER=$(echo "$VERINFO" | cut -d "-" -f 2 | tr -d " ")
            NHASH=$(echo "$VERINFO" | cut -d "-" -f 3 | tr -d " ")
            if [ -z "$NVER" ];then
                unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Cannot parse the splunk version! Try again" "$LOG"
            else
                echo "$NVER" | egrep -q "^[[:digit:]]"
                [ $? -ne 0 ] && unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Version does not start with a number! Try again" "$LOG"
            fi  
            [ -z "$NHASH" ] && unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Cannot parse the splunk hash! Try again" "$LOG"
        else
            F_ERRLOG "3" "$FUNCNAME: You typed: $VERINFO which is not in the correct format!" "$LOG"
            unset VERINFO
        fi
    done
    # auto-stage the given version 
    F_STAGESPL $SPLTYPE "${NVER}:${NHASH}"
   
    F_LOG $FUNCNAME "Parsed version: $NVER, parsed hash: $NHASH"
    
    # download the auto-staged version
    [ ! -s $VAULTTEMPFILE ] && [ "$ENABLEVAULT" == "yes" ] && F_VAULTPW
    F_ABIN $HOSTFILE $PBDLSPL "Downloading splunk <$NVER>..." "-e spltype=$SPLTYPE"
    ERR=$?
    F_RMVAULTPW
    F_DIAERR $ERR "Downloading splunk version: $NVER"
    [ $ERR -eq 0 ] && F_DIALOG --infobox "\nSplunk $NVER has been staged automatically." 5 80
    F_PORSACTION "nogit" "$FUNCNAME | downloaded splunk version $NVER - $NHASH"
    F_LOG $FUNCNAME ended
}

## @fn F_GETSTAGEDSPL()
## @brief Get the current staged splunk version
## @param 1 optional: set splunk type (e.g. splunkforwarder)
## @return version string of the current staged splunk package
## @details Parses the local global var to identify the current staged splunk version
F_GETSTAGEDSPL(){ 
    F_LOG $FUNCNAME started
    SPLTYPE=$1

    # extract repo dir for apps
    if [ "$SPLTYPE" == "splunkforwarder" ];then
        STAGEDVER="$(grep ^globversion "$AINVENTORY/$TARGETENV/group_vars/universal_forwarder/$INSTDEF" |cut -d ":" -f 2 | grep -Po '\d+\.\d+\.\d+(\.\d+)?')"
    else
        STAGEDVER="$(grep ^globversion "$AINVENTORY/$TARGETENV/group_vars/all/$INSTDEF" |cut -d ":" -f 2 | grep -Po '\d+\.\d+\.\d+(\.\d+)?')"
    fi
 
    if [ ! -z "$STAGEDVER" ];then
        echo "$STAGEDVER"
    fi
    F_LOG $FUNCNAME "current version string: $STAGEDVER"
    F_LOG $FUNCNAME ended
}

## @fn F_STAGESPL()
## @brief Stage a specific splunk version from the local repository
## @param 1 required: set splunk type (e.g. splunkforwarder)
## @param 2 optional: splunk version:hash -> will auto-stage the given version + hash
## @return success/error
## @details Parses the local repository for available splunk versions, let the user choose and stage that version for the PORS upgrade function
F_STAGESPL(){ 
    F_LOG $FUNCNAME "started with $1,$2"
    unset FVER VER VERHASH SELECTION AUTOVER SPLTYPE
    SPLTYPE="$1"
    AUTOVER="$2"
    STAGEDSPLVER=$(F_GETSTAGEDSPL $SPLTYPE)
    
    if [ -z "$AUTOVER" ];then
        # get the local avail versions
        if [ "$SPLTYPE" == "splunkforwarder" ];then
            SPLNAME=$SPLTYPE
        else
            SPLNAME=splunk
        fi
        OPTIONS=($(for i in $(F_LISTSPLREPO $SPLTYPE | grep -P -o "${SPLNAME}-(\d+\.\d+\.\d+(\.\d+)?)-(\w+)");do VER=$(echo "${i}" | cut -d "-" -f 2); VHASH=$(echo "${i}"| cut -d "-" -f 3); echo "$VER" "$VHASH" off;done))

	F_LOG $FUNCNAME "splunk packages found in local repo:\n$(F_LISTSPLREPO)"

        F_LOG $FUNCNAME "OPTIONS:\n$OPTIONS"

        SELECTION=$(F_DIALOG --colors --ok-label "Stage" --radiolist "\nThe following shows your local repository for splunk $SPLTYPE packages\n\nCurrently active/staged splunk version:\n\n \Zb\Zu${STAGEDSPLVER}\ZB\ZU\n\nTo stage another version simply select (space bar) and choose select.\n\n" \
                40 80 40 \
                "${OPTIONS[@]}" \
                2>&1 >/dev/tty)

        [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

        FVER=$(echo "${OPTIONS[@]}" | egrep -o "$SELECTION.*" | cut -d " " -f 1-2)
        VER=$(echo "${FVER}" | cut -d " " -f 1)
        VERHASH=$(echo "${FVER}" | cut -d " " -f 2)
    else
        SELECTION="$AUTOVER"
        VER="${SELECTION/:*}"
        VERHASH="${SELECTION/*:}"
    fi
    if [ "$SPLTYPE" == "splunkforwarder" ];then
        F_LOG $FUNCNAME "s/^globversion:.*/globversion: \"$VER\"/g;s/^globhash:.*/globhash: \"$VERHASH\"/g $AINVENTORY/$TARGETENV/group_vars/universal_forwarder/$INSTDEF"
        sed -i "s/^globversion:.*/globversion: \"$VER\"/g;s/^globhash:.*/globhash: \"$VERHASH\"/g" $AINVENTORY/$TARGETENV/group_vars/universal_forwarder/$INSTDEF
    else
        F_LOG $FUNCNAME "s/^globversion:.*/globversion: \"$VER\"/g;s/^globhash:.*/globhash: \"$VERHASH\"/g $AINVENTORY/$TARGETENV/group_vars/all/$INSTDEF"
        sed -i "s/^globversion:.*/globversion: \"$VER\"/g;s/^globhash:.*/globhash: \"$VERHASH\"/g" $AINVENTORY/$TARGETENV/group_vars/all/$INSTDEF
    fi
    [ -z "$AUTOVER" ] && F_DIAERR $? "Staging splunk (VER: $VER, VERHASH: $VERHASH)"

    F_LOG $FUNCNAME "staged version: $SELECTION (FVER: $FVER, VER: $VER, VERHASH: $VERHASH)"
    F_PORSACTION "staged splunk $VER" "$FUNCNAME | staged splunk version $VER - $VERHASH"
    F_LOG $FUNCNAME ended
}

## @fn F_UPGRADESPLC()
## @brief WIP - upgrading splunk cluster env
## @details WIP - upgrading splunk cluster env
F_UPGRADESPLC(){ 
    F_LOG $FUNCNAME started
	# ask:
	#   test? -> Major release? then: no splunk offline!
	#
	#   Upgrade all tiers at once?
	# 	Stop the master.
	#	Stop all the peers and search heads. 
	#	When bringing down the peers, use the splunk stop command, not splunk offline.
	#	Upgrade the master node, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual. 
	#	Do not upgrade the peers yet.
	#	Start the master
	#	Run splunk enable maintenance-mode on the master. 
	#	To confirm that the master is in maintenance mode, run splunk show maintenance-mode
	#	Upgrade the peer nodes and search heads, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual. 
	#	Start the peer nodes and search heads
	#	Run splunk disable maintenance-mode on the master. To confirm that the master is not in maintenance mode, run splunk show maintenance-mode.

	#   Upgrade each tier separately
	#	Upgrade the master node.
	#	Upgrade the search head tier:
	#		Stop all cluster members.
	#		Upgrade all members.
	#		Stop the deployer.
	#		Upgrade the deployer.
	#		Start the deployer.
	#		Start the members.
	#		Wait one to two minutes for captain election to complete. The cluster will then begin functioning.
	#	Upgrade the peer node tier
	#		Run splunk enable maintenance-mode on the master. 
	#		To confirm that the master is in maintenance mode, run splunk show maintenance-mode on the master. 
	#		Stop all the peer nodes. 
	#		When bringing down the peers, use the splunk stop command, not splunk offline.
	#		Upgrade the peer nodes, following the normal procedure for any Splunk Enterprise upgrade, as described in How to upgrade Splunk Enterprise in the Installation Manual.
	#		Start the peer nodes, if they are not already running.
	#		Run splunk disable maintenance-mode on the master.  

	# 1) MN
	# 2) SH cluster
	# 3) DEP
	# 4) Maintenance mode on
	# 5) IX cluster
	# 6) Maintenance mode off
	# 7) DS, DMC, HF, AI, LM, dev SH's
	# 8) specials: old AI (xxxxxxxxxxxxxxxxxx05), CDC SH
	# 

	F_LOG $FUNCNAME ended
}

## @fn F_DLLOGSTREAM()
## @brief Downloads a specific cribl logstream release
## @return success/error
## @details Takes an URL parses the relevant parts out of it and downloads to the local repo
F_DLLOGSTREAM() { 
    F_LOG $FUNCNAME started
    unset VERINFO

    while [ -z "$VERINFO" ];do
        VERINFO=$(F_DIALOG --colors --inputbox '\nThis will download logstream based on just the version number & the hash value.\nGuide to get version and hash:\n\n1) open https://cribl.io/download/logstream-past-releases\n   (select the URL and use your terminal copy-hotkey)\n2) find the wanted version but do not click on it\n3) identify the version and hash from the package name\n\nExample:\ncribl-\Zb2.4.1-070b9e2b\ZB-linux-x64.tgz\n\nResult: \n2.4.1 (version), 070b9e2b (hash)\n\nType or paste in the version + hash ONLY.\nThe format must be exactly like this: 2.4.1-070b9e2b (version-hash):\n' 30 100 2>&1 >>/dev/tty || echo 1)
        F_LOG $FUNCNAME "input was: $VERINFO"
        [ "$VERINFO" == "1" ] && unset VERINFO && return 3
        
        echo "$VERINFO" | egrep -q "[0-9]*\.[0-9]*\.[0-9]*-\w*"
        if [ $? -eq 0 ];then
            NVER=$(echo "$VERINFO" | cut -d "-" -f 1 | tr -d " ")
            NHASH=$(echo "$VERINFO" | cut -d "-" -f 2 | tr -d " ")
            if [ -z "$NVER" ];then
                unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Cannot parse version! Try again" "$LOG"
            else
                echo "$NVER" | egrep -q "^[[:digit:]]"
                [ $? -ne 0 ] && unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Version does not start with a number! Try again" "$LOG"
            fi  
            [ -z "$NHASH" ] && unset VERINFO && F_ERRLOG "3" "$FUNCNAME: Cannot parse hash! Try again" "$LOG"
        else
            F_ERRLOG "3" "$FUNCNAME: You typed: $VERINFO which is not in the correct format!" "$LOG"
            unset VERINFO
        fi
    done
    # auto-stage the given version 
    F_STAGELS "${NVER}:${NHASH}"
   
    F_LOG $FUNCNAME "Parsed version: $NVER, parsed hash: $NHASH"
    
    # download the auto-staged version
    [ ! -s $VAULTTEMPFILE ] && [ "$ENABLEVAULT" == "yes" ] && F_VAULTPW
    F_ABIN $HOSTFILE $PBDLLOGSTREAM "Downloading cribl logstream <$NVER>..."
    ERR=$?
    F_RMVAULTPW
    F_DIAERR $ERR "Downloading cribl logstream version: $NVER"
    [ $ERR -eq 0 ] && F_DIALOG --infobox "\ncribl logstream $NVER has been staged automatically." 5 80
    F_PORSACTION "nogit" "$FUNCNAME | downloaded cribl logstream version $NVER - $NHASH"    
    F_LOG $FUNCNAME ended
}

## @fn F_GETSTAGEDLS()
## @brief Get the current staged cribl logstream version
## @return version string of the current staged cribl logstream package
## @details Parses the local global var to identify the current staged cribl logstream version
F_GETSTAGEDLS(){ 
    F_LOG $FUNCNAME started
    # extract repo dir for apps
    STAGEDVER="$(grep ^logstream_globversion "$AINVENTORY/$TARGETENV/group_vars/all/$INSTDEFLS" |cut -d ":" -f 2 | grep -Po '\d+\.\d+\.\d+(\.\d+)?')"
 
    if [ ! -z "$STAGEDVER" ];then
        echo "$STAGEDVER"
    fi
    F_LOG $FUNCNAME "current version string: $STAGEDVER"
    F_LOG $FUNCNAME ended
}

## @fn F_LISTCRIBLREPO()
## @brief Lists cribl packages in the local repo
## @return a list of cribl packages (filenames) ordered by version top-level down
## @details Lists available cribl packages in the local repository
F_LISTCRIBLREPO() {
    F_LOG $FUNCNAME started
    REPODIR="$(F_SETREPODIR)/common/packages/cribl"
    find ${REPODIR} -maxdepth 1 -type f -name cribl*tgz | tac | sed 's#.*/##g'
    F_LOG $FUNCNAME ended
}

## @fn F_STAGELS()
## @brief Stage a specific cribl logstream version from the local repository
## @param 1 OPTIONAL: logstream version:hash -> will auto-stage the given version + hash
## @return success/error
## @details Parses the local repository for available logstream versions, let the user choose and stage that version for the PORS upgrade function
F_STAGELS(){ 
    F_LOG $FUNCNAME "started with $1"
    unset FVER VER VERHASH SELECTION AUTOVER
    AUTOVER="$1"
    STAGEDSPLVER=$(F_GETSTAGEDLS)
    
    if [ -z "$AUTOVER" ];then
        # get the local avail versions
        OPTIONS=($(for i in $(F_LISTCRIBLREPO | grep -P -o "cribl-(\d+\.\d+\.\d+(\.\d+)?)-(\w+)");do VER=$(echo "${i}" | cut -d "-" -f 2); VHASH=$(echo "${i}"| cut -d "-" -f 3); echo "$VER" "$VHASH" off;done))

	F_LOG $FUNCNAME "cribl logstream packages found in local repo:\n$(F_LISTCRIBLREPO)"

        F_LOG $FUNCNAME "OPTIONS:\n$OPTIONS"

        SELECTION=$(F_DIALOG --colors --ok-label "Stage" --radiolist "\nThe following shows your local repository for CRIBL logstream packages\n\nCurrently active/staged version:\n\n \Zb\Zu${STAGEDSPLVER}\ZB\ZU\n\nTo stage another version simply select (space bar) and choose select.\n\n" \
                40 80 40 \
                "${OPTIONS[@]}" \
                2>&1 >/dev/tty)

        [ $? -ne 0 ] && F_LOG $FUNCNAME "aborted by user" && return 4

        FVER=$(echo "${OPTIONS[@]}" | egrep -o "$SELECTION.*" | cut -d " " -f 1-2)
        VER=$(echo "${FVER}" | cut -d " " -f 1)
        VERHASH=$(echo "${FVER}" | cut -d " " -f 2)
    else
        SELECTION="$AUTOVER"
        VER="${SELECTION/:*}"
        VERHASH="${SELECTION/*:}"
    fi
    F_LOG $FUNCNAME "s/^logstream_globversion:.*/logstream_globversion: \"$VER\"/g;s/^logstream_globhash:.*/logstream_globhash: \"$VERHASH\"/g $AINVENTORY/$TARGETENV/group_vars/all/$INSTDEFLS"
    sed -i "s/^logstream_globversion:.*/logstream_globversion: \"$VER\"/g;s/^logstream_globhash:.*/logstream_globhash: \"$VERHASH\"/g" $AINVENTORY/$TARGETENV/group_vars/all/$INSTDEFLS
    [ -z "$AUTOVER" ] && F_DIAERR $? "Staging splunk (VER: $VER, VERHASH: $VERHASH)"

    F_LOG $FUNCNAME "staged version: $SELECTION (FVER: $FVER, VER: $VER, VERHASH: $VERHASH)"
    F_PORSACTION "staged logstream $VER" "$FUNCNAME | staged cribl logstream version $VER - $VERHASH"
    F_LOG $FUNCNAME ended
}


## @fn F_SELHOST()
## @brief Show and choose host(s)
## @param 1 specify a target group directly (non interactive - will just output ALL(!) the host(s) of a group)
## @details Parsing the inventory, offering all groups found, parsing groups including childs, remove dups, offer host list and let the user choose
## @exception on abort: return 4, on failure: error dialog
F_SELHOST(){
        F_LOG $FUNCNAME started
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup TGRP PREFILTER
	TGRP="$1"
        PREFILTER="$2"

        F_LOG $FUNCNAME "LISTTYPE=$LISTTYPE"
        [ -z "$LISTTYPE" ] && LISTTYPE=checklist && F_LOG $FUNCNAME "Using default list type: $LISTTYPE"

	if [ -z "$TGRP" ]||[ ! -z $PREFILTER ];then
	  source $AEUSRHOSTFILE
          [ -f "$HOSTFILE" ] || F_HOSTFILE
          while [ -z "$HOSTSELECT" ];do
                if [ -z $PREFILTER ];then
                    HOSTSELECTION=$(F_TARGETS $LISTTYPE)
                else
                    HOSTSELECTION="$(F_TARGETS $LISTTYPE) | grep $PREFILTER"
                fi
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
                else
                        if [ -z "$HOSTSELECTION" ];then
				F_LOG $FUNCNAME "No selection made / HOSTSELECTION empty!"
#                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
          done
	else
		HOSTSELECTION="$TGRP"
		ABORTED=0
	fi

	if [ $ABORTED -eq 1 ];then
        F_LOG $FUNCNAME "aborted by user"
		echo ABORTED
	else
		# ask for specific hosts or target group?
		unset HOSTLIST['expanded']
		if [ -z "$TGRP" ];then
			  F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80 2>&1 > /dev/tty
		fi
			  for hostlist in $HOSTSELECTION;do
				if [ -z "${HOSTLIST['expanded']}" ];then
					HOSTLIST['expanded']+="$(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
				else
					HOSTLIST['expanded']+=" $(F_EXPANDHOSTS $hostlist | grep -v EMPTY)"
				fi
			  done

		unset EDITHOST
		# select hosts interactive or not depending on how we get called
		if [ -z "$TGRP" ];then
			  while [ -z "$EDITHOST" ];do
			        EDITHOST=$(F_SHOWHOSTS $LISTTYPE "${HOSTLIST['expanded']}")
                                [ $? -eq 4 ] && F_LOG $FUNCNAME "Aborted by user" && return 4
				if [ -z "$EDITHOST" ];then
					F_LOG $FUNCNAME "No selection made / EDITHOST empty!"
					F_DIALOG --yesno "No selection made! Retry?" 10 40
					[ $? -ne 0 ] && return $?
				fi
			  done
		else
			EDITHOST=$(echo "${HOSTLIST['expanded']}")
		fi
			  # make host list unique to avoid duplicated task runs when a host is in multiple groups
			  # number each entry,sort by name and remove dups, sort by num
			  echo "$EDITHOST" | tr ' ' '\n' | nl| sort -u -k2|sort -n| cut -f2-|tr '\n' ' '
	  fi
}

## @fn F_INSTALLSPL()
## @brief Install splunk on ansible prepared servers
## @param 1 optional: set install type (e.g. splunkforwarder)
## @exception on abort: return 4, on failure: F_ERRLOG dialog
F_INSTALLSPL(){
    F_LOG $FUNCNAME started

    SPLTYPE="$1"
    # this installs pure splunk (i.e. with common configuration but without any specific configuration)

    # force cleaning the temp hosts file in F_EXPANDHOSTS()
    # must be explicitly unset for any subsequent tasks
    export CLEANHOSTFILE=yes
	
    SHOSTS="$(LISTTYPE=checklist F_SELHOST)"
    [ $? -eq 4 ] && return 4
    [ "$SHOSTS" == ABORTED ] && return 4
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g' | cut -d ':' -f 1)"

    if  [ -z "$SHOSTS" ] || [ -z "$SHOSTST" ];then
        F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
        F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
        F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    CURVER=$(F_GETSTAGEDSPL "$SPLTYPE")

    if [ "$SPLTYPE" == "splunkforwarder" ];then
        F_LOG "$FUNCNAME" "Will install splunkforwarder on <$SHOSTS>"
        F_DIALOG --colors --scrollbar --yesno "Will install splunkforwarder\n\n\Zbv${CURVER}\ZB\n\non these host(s):\n\n\Zb$SHOSTST\ZB\n\nAre you sure?" 30 100
    else
        SPLTYPE=splunk
        F_LOG "$FUNCNAME" "Will install splunk on <$SHOSTS>"
        F_DIALOG --colors --scrollbar --yesno "Will install splunk\n\n\Zbv${CURVER}\ZB\n\non these host(s):\n\n\Zb$SHOSTST\ZB\n\nAre you sure?" 30 100
    fi
    [ $? -ne 0 ] && return $?

    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$SHOSTST" | tr "\n" : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3

    # doit
    F_ABIN "$HOSTFILE" "$PBINSTALL" "\Za\Z1Installing $SPLTYPE ...\Z\n" "--limit $LIMITLIST -e {'target':'$LIMITLIST','splunk_type':'$SPLTYPE'}"
    F_ERRLOG $? "Installing splunk on:\n\n$SHOSTST" "$LOG"
    F_PORSACTION "nogit" "$FUNCNAME | installed $SPLTYPE v${CURVER} on $SHOSTS"

    # cleanup
    [ -f $ITMPGRP ] && F_LOG $FUNCNAME "deleting temp hosts file: $(rm -vf $ITMPGRP 2>&1)"

    F_LOG $FUNCNAME ended
}

## @fn F_INSTALLLOGSTREAM()
## @brief Install cribl logstream on ansible prepared servers
## @exception on abort: return 4, on failure: F_ERRLOG dialog
F_INSTALLLOGSTREAM(){
    F_LOG $FUNCNAME started
    unset HOSTSELECT HOSTSELECTION SHOSTS SHOSTST
    ABORTED=0

    # create a temporary ansible group (must be in the correct env path! otherwise variables cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
    > $ITMPGRP

    # force cleaning the temp hosts file in F_EXPANDHOSTS()
    # must be explicitly unset for any subsequent tasks
    export CLEANHOSTFILE=yes

    F_WAITBOX "Collecting hostnames ..."

    SHOSTS="$(LISTTYPE=checklist F_EXPANDHOSTS logstream_all $ITMPGRP clean)"

    [ $? -eq 4 ] && return 4
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g' | cut -d ':' -f 1)"

    if  [ -z "$SHOSTS" ] || [ -z "$SHOSTST" ];then
        F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
        F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
        F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi
    CURVER=$(F_GETSTAGEDLS)

    while [ -z "$HOSTSELECT" ];do
            OPTIONS=($(for i in $(echo "${SHOSTST}" );do echo ${i/:*} "(space_to_select)" off; done | sort -u ))
            HOSTSELECTION=$(F_DIALOG --colors --checklist "\nPlease use the space-bar to make your selection to install cribl \Zb\Zuv${CURVER}\ZB\ZU\n" 50 100 100 "${OPTIONS[@]}" 2>&1 >/dev/tty)
            [ $? -ne 0 ] && ABORTED=1
            F_LOG $FUNCNAME "HOSTSELECTION=$HOSTSELECTION, ABORTED=$ABORTED"
            if [ "$HOSTSELECTION" == "ABORTED" ]||[ $ABORTED -eq 1 ];then
                ABORTED=1 && break
            else
                if [ -z "$HOSTSELECTION" ];then
                    F_LOG $FUNCNAME "No selection made / HOSTSELECTION empty!"
                    F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                else
                    HOSTSELECT=1
                    ABORTED=0
                fi
            fi
    done
    [ $ABORTED -eq 1 ] && return 4

    F_LOG "$FUNCNAME" "Will install cribl logstream on <$HOSTSELECTION>"
    F_DIALOG --colors --scrollbar --yesno "\n\nWill install cribl logstream\n\n\Zbv${CURVER}\ZB\n\non these host(s):\n\n\Zb$HOSTSELECTION\ZB\n\nAre you sure?" 30 100
    [ $? -ne 0 ] && return $?

    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$HOSTSELECTION" | tr "\n" : | tr " " : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3

    # doit
    F_ABIN "$HOSTFILE" "$PBINSTALLLOGSTREAM" "\Za\Z1Installing cribl logstream ...\Z\n" "-e target='$LIMITLIST'"
    F_ERRLOG $? "Installing cribl logstream on:\n\n$HOSTSELECTION" "$LOG"
    F_PORSACTION "nogit" "$FUNCNAME | installed cribl logstream v${CURVER} on $HOSTSELECTION"

    # cleanup
    [ -f $ITMPGRP ] && F_LOG $FUNCNAME "deleting temp hosts file: $(rm -vf $ITMPGRP 2>&1)"

    F_LOG $FUNCNAME ended
}

## @fn F_CONFLOGSTREAM()
## @brief Configures cribl logstream on ansible prepared servers
## @param 1: type (leader | worker)
## @exception on abort: return 4, on failure: F_ERRLOG dialog
F_CONFLOGSTREAM(){
    F_LOG $FUNCNAME started
    unset HOSTSELECT HOSTSELECTION SHOSTS SHOSTST
    ABORTED=0
    LSTYPE=$1

    [ -z "$LSTYPE" ] && F_LOG $FUNCNAME "ERROR: missing LSTYPE" && return 3

    # create a temporary ansible group (must be in the correct env path! otherwise variables cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
    > $ITMPGRP

    # force cleaning the temp hosts file in F_EXPANDHOSTS()
    # must be explicitly unset for any subsequent tasks
    export CLEANHOSTFILE=yes

    F_WAITBOX "Collecting hostnames ..."

    SHOSTS="$(LISTTYPE=checklist F_EXPANDHOSTS $LSTYPE $ITMPGRP clean)"

    [ $? -eq 4 ] && return 4
    SHOSTST="$(echo "$SHOSTS" | sed 's/ /\n/g' | cut -d ':' -f 1)"

    if  [ -z "$SHOSTS" ] || [ -z "$SHOSTST" ];then
        F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
        F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
    else
        F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    while [ -z "$HOSTSELECT" ];do
            OPTIONS=($(for i in $(echo "${SHOSTST}" );do echo ${i/:*} "(space_to_select)" off; done | sort -u ))
            HOSTSELECTION=$(F_DIALOG --colors --checklist "\nPlease use the space-bar to make your selection to configure cribl logstream\n" 50 100 100 "${OPTIONS[@]}" 2>&1 >/dev/tty)
            [ $? -ne 0 ] && ABORTED=1
            F_LOG $FUNCNAME "HOSTSELECTION=$HOSTSELECTION, ABORTED=$ABORTED"
            if [ "$HOSTSELECTION" == "ABORTED" ]||[ $ABORTED -eq 1 ];then
                ABORTED=1 && break
            else
                if [ -z "$HOSTSELECTION" ];then
                    F_LOG $FUNCNAME "No selection made / HOSTSELECTION empty!"
                    F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                else
                    HOSTSELECT=1
                    ABORTED=0
                fi
            fi
    done
    [ $ABORTED -eq 1 ] && return 4

    F_LOG "$FUNCNAME" "Will configure cribl logstream on <$HOSTSELECTION>"
    F_DIALOG --colors --scrollbar --yesno "\n\nWill (re-)configure cribl logstream on these host(s):\n\n\Zb$HOSTSELECTION\ZB\n\nAre you sure?" 30 100
    [ $? -ne 0 ] && return $?

    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$HOSTSELECTION" | tr "\n" : | tr " " : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3

    # doit
    F_ABIN "$HOSTFILE" "$PBCONFLOGSTREAM" "\Za\Z1Configuring cribl logstream ...\Z\n" "-e target='$LIMITLIST'"
    F_ERRLOG $? "Configuring cribl logstream on:\n\n$HOSTSELECTION" "$LOG"
    F_PORSACTION "nogit" "$FUNCNAME | configured cribl logstream on $HOSTSELECTION"

    # cleanup
    [ -f $ITMPGRP ] && F_LOG $FUNCNAME "deleting temp hosts file: $(rm -vf $ITMPGRP 2>&1)"
    F_LOG $FUNCNAME ended
}

## @fn F_ADDSERVICEUSER()
## @brief Creates the OS_SERVICE_USER linux user account and add any extra groups needed
## @param1 (required) the remote hostname where the user should be created
## @param2 (required) the username to be added
## @param3 (required) the linux group name 
## @return success|fail
## @details The user created will get a random strong password which does not get stored anywhere
## because pubkey authentication is the way to go.
F_ADDSERVICEUSER(){
    F_LOG $FUNCNAME started
    _HOST=$1

    if [ -z "$_HOST" ];then
        F_LOG $FUNCNAME "HOST, USER, GRP or PASS missing: $_HOST, $_USER, $_GRP, $_PASS"
        return 3
    fi

    if [ ! -z "$OS_SERVICE_USER" ];then
        [ ! -z $OS_SERVICE_USER_EXTRAGROUPS ] && _GRP="$OS_SERVICE_USER_EXTRAGROUPS"
        F_ADDSYSUSER "$_HOST" "$OS_SERVICE_USER" "$OS_SERVICE_USER_EXTRAGROUPS"
        F_PORSACTION "nogit" "$FUNCNAME | OS service account $OS_SERVICE_USER created on $HOST"
        return $?
    else
        F_LOG $FUNCNAME "SKIPPING: No OS_SERVICE_USER specified"
    fi
    F_LOG $FUNCNAME ended
}

## @fn F_ADDSYSUSER()
## @brief Creates a linux user account and add it to a group
## @param1 (required) the remote hostname where the user should be created
## @param2 (required) the username to be added
## @param3 (required) the (extra) linux group names (comma separated)
## @return success|fail
## @details The user created will get a random strong password which does not get stored anywhere
## because pubkey authentication is the way to go.
F_ADDSYSUSER(){
    F_LOG $FUNCNAME started
    _HOST=$1
    _USER=$2
    _GRP=$3
    _PASS=$(pwgen -1 40)

    if [ -z $_HOST ]||[ -z $_USER ]||[ -z "$_GRP" ]||[ -z "$_PASS" ];then
        F_LOG $FUNCNAME "HOST, USER, GRP or PASS missing: $_HOST, $_USER, $_GRP, $_PASS"
        return 3
    fi

    F_ABIN $HOSTFILE $PBCREATEUSER "\Za\Z1Adding Linux user ($_USER) ...\Z\n" "--limit $_HOST -e {'target':'$_HOST','user_name':'$_USER','user_pass':'$_PASS','appadm':'$_GRP'}"
    CERR=$?
    F_PORSACTION "nogit" "$FUNCNAME | linux user $_USER created on $_HOST"
    return $CERR
}

## @fn F_UPGRADEMENU()
## @brief A submenu for upgrade tasks
## @param 1 Specify menu type (logstream|splunk)
## @return a submenu action
## @details Shows several upgrade tasks in an own submenu
F_UPGRADEMENU(){ 
    F_LOG $FUNCNAME "started with $1"
    unset SELECTION MENUTYPE
    MENUTYPE=$1
    [ -z "$MENUTYPE" ] && F_LOG $FUNCNAME "ERROR: missing arg for $FUNCNAME" && return 3

    SELECTION=$(F_DIALOG --ok-label "Select an entry" --cancel-label "Back" --colors \
                    --menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
                        20 90 80 \
                        '' '\Zb\ZuUpgrade Tasks\ZB\ZU'\
                        "" "" \
                        "Download ${MENUTYPE}" "Downloads a specific $MENUTYPE version" \
                        "Stage ${MENUTYPE}" "Shows and sets a specific version for the upgrade tasks" \
                        "Upgrade ${MENUTYPE}" "upgrade without a specific order (if multiple targets: in parallel)" \
                        Guided-Upgrade "of splunk instance(s) in a specific order (sequentially)" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

    F_LOG $FUNCNAME "selected upgrade task: $SELECTION"
    if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              return 4
    else
        case "$SELECTION" in
            "Download splunk")
                F_DLSPLUNK splunk
                F_UPGRADEMENU $MENUTYPE
            ;;
            "Stage splunk")
                F_STAGESPL splunk
                F_UPGRADEMENU $MENUTYPE
            ;;
            "Upgrade $MENUTYPE")
                F_UPGRADE $MENUTYPE
                F_UPGRADEMENU $MENUTYPE
            ;;
            "Download splunkforwarder")
                F_DLSPLUNK splunkforwarder
                F_UPGRADEMENU $MENUTYPE
            ;;
            "Stage splunkforwarder")
                F_STAGESPL splunkforwarder
                F_UPGRADEMENU $MENUTYPE
            ;;
            "Upgrade $MENUTYPE")
                F_UPGRADE $MENUTYPE
                F_UPGRADEMENU $MENUTYPE
            ;;
            "Download logstream")
                F_DLLOGSTREAM
                F_UPGRADEMENU $MENUTYPE
            ;;
            "Stage logstream")
                F_STAGELS
                F_UPGRADEMENU $MENUTYPE
            ;;
            Guided-Upgrade)
                F_GUIDEDUPGRADE $MENUTYPE
                F_UPGRADEMENU
            ;;
           *)
                return 3
            ;;
        esac
    fi
    F_LOG $FUNCNAME ended
}

## @fn F_UPGRADE()
## @brief Upgrade splunk|logstream
## @param 1 required. upgrade type: splunk|logstream
## @param 2 optional. when set: non-interactive upgrade of all hosts specified within this param
F_UPGRADE(){
    F_LOG $FUNCNAME "started with: $1"
    unset AUTOMODE PARENTPID
    UPGTYPE=$1
    AUTOMODE="$2"

    # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
    > $ITMPGRP
    
    export PARENTPID=$BASHPID

    case $UPGTYPE in
        splunk)
            STAGEDVER=$(F_GETSTAGEDSPL)
            PLAYB=$PBUPGRADE
        ;;
        logstream)
            STAGEDVER=$(F_GETSTAGEDLS)
            PLAYB=$PBUPGRADELOGSTREAM
        ;;
        splunkforwarder)
            STAGEDVER=$(F_GETSTAGEDSPL $UPGTYPE)
            PLAYB=$PBUPGRADE
        ;;
        *)
        F_ERRLOG 3 "INTERNAL ERROR: unknown or empty upgrade type specified ($UPGTYPE)" && return 3
        ;;
    esac

    if [ -z "$AUTOMODE" ];then
    	UPGRADEHOSTS="$(F_SELHOST)"
        RET=$?
        [ $RET -ne 0 ] && return $RET
        [ "$UPGRADEHOSTS" == ABORTED ] && return 4
    else
        UPGRADEHOSTS="$AUTOMODE"
    fi

	UPGRADEHOSTST="$(echo "$UPGRADEHOSTS" | sed 's/ /\n/g')"

	if  [ -z "$UPGRADEHOSTS" ] || [ -z $UPGRADEHOSTST ];then
		F_LOG $FUNCNAME "UPGRADEHOSTS ($UPGRADEHOSTS) or UPGRADEHOSTSST ($UPGRADEHOSTST) empty"
		F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
                return 3
	else
		F_LOG $FUNCNAME "UPGRADEHOSTS and UPGRADEHOSTST are both set"
	fi

	F_LOG "$FUNCNAME" "Will upgrade <$UPGRADEHOSTS>"

    if [ -z "$AUTOMODE" ];then
            F_DIALOG --scrollbar --yesno "\n\nWill upgrade $UPGTYPE $STAGEDVER on these hosts IN PARALLEL(!!):\n\n$UPGRADEHOSTST\n\nAre you sure?" 30 100
	    if [ $? -ne 0 ];then
                return $?
            else
	        # create a temporary ansible group (must be in the correct env path! otherwise variables cant be found)
	        UTMPGRP=${AINVENTORY}/${TARGETENV}/upgrhosts

                # target environment must be set always
                echo -e "\n[all:vars]\ntarget_env=${TARGETENV}\n" > $UTMPGRP

	        echo '[tmpupgrade]' >> $UTMPGRP
	        for h in $UPGRADEHOSTS;do echo "$h" >> $UTMPGRP; done

                # always set the logstream_all grp as otherwise vars will not load
                if [ "$UPGTYPE" == "logstream" ];then
                    echo -e '\n[logstream_all:children]\ntmpupgrade\n' >> $UTMPGRP
                fi
	        if [ $? -ne 0 ];then
                    F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
                    return 3
                else
    	            F_LOG "$FUNCNAME" "Temporary upgrade group: $(cat $UTMPGRP)"
	            # upgrade
	            F_ABIN "$UTMPGRP" "$PLAYB" "\Za\Z1UPGRADING $UPGTYPE ...\Z\n" "--limit tmpupgrade -e spltype=$UPGTYPE" 
                    F_ERRLOG "${PIPESTATUS[0]}" "Upgrade $UPGTYPE to $STAGEDVER for:\n\n$UPGRADEHOSTST" "$LOG"
                    F_PORSACTION "nogit" "$FUNCNAME | upgraded $UPGTYPE to $STAGEDVER on $UPGRADEHOSTST"
                fi
            fi
            SHOWREBHINT=$(F_GETANSIBLEVAR "system.upgrade_os")
            if [ $? -eq 0 ] && [ "$SHOWREBHINT" == "True" ];then
                F_LOG $FUNCNAME "System packages or upgrade(s) have been installed for:\n$UPGRADEHOSTST\n\nA REBOOT IS REQUIRED!\nReboot handler will be initiated ..."
                F_SYSREBOOT "$UPGRADEHOSTS"
                LASTERR=$?
            else
                F_LOG $FUNCNAME "ERR: $? SHOWREBHINT: $SHOWREBHINT"
            fi
    else
            F_ABIN "$HOSTFILE" "$PLAYB" "\Za\Z1UPGRADING $UPGTYPE ...\Z\n" "--limit $AUTOMODE -e {'splunk_user':'$SPLUSR','splunk_password':'$SPLPW'}"
            UPERR=${PIPESTATUS[0]}
            F_LOG $FUNCNAME "Upgrade $UPGTYPE for:\n\n$UPGRADEHOSTST ended with: $UPERR"
            F_PORSACTION "nogit" "$FUNCNAME | upgraded $UPGTYPE to $STAGEDVER on $UPGRADEHOSTST"
            return $UPERR
    fi
    F_LOG $FUNCNAME ended
}

## @fn F_GUIDEDUPGRADE()
## @brief Guided upgrade of splunk|logstream on multiple servers at once (sequentiel and ordered)
## @param 1 required. upgrade type: splunk|logstream
## @param 2 optional. hostnames to upgrade
## @exception on abort: return 4, internal failure: 3
## @details Prepare your very own upgrade order
F_GUIDEDUPGRADE(){
    F_LOG $FUNCNAME started

    unset HOSTSELECT UHOSTS
    ABORTED=0
    UPGTYPE=$1
    UHOSTS="$2"

    # create a temporary ansible group (must be in the correct env path! otherwise variables cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
    > $ITMPGRP

    # force cleaning the temp hosts file in F_EXPANDHOSTS()
    # must be explicitly unset for any subsequent tasks
    export CLEANHOSTFILE=yes

    case $UPGTYPE in
        splunk)
            STAGEDVER=$(F_GETSTAGEDSPL)
        ;;
        logstream)
            STAGEDVER=$(F_GETSTAGEDLS)
        ;;
        *)
        F_ERRLOG 3 "INTERNAL ERROR: no upgrade type specified" && return 3
        ;;
    esac

    if [ -z "$UHOSTS" ];then
        F_WAITBOX "Collecting hostnames ..."
    
        SHOSTS="$(LISTTYPE=checklist F_EXPANDHOSTS all $ITMPGRP clean | egrep -v localhost)"
        [ "$SHOSTS" == ABORTED ] && return 4

        while [ -z "$HOSTSELECT" ];do
	    OPTIONS=($(for i in $(echo "${SHOSTS}" );do echo ${i/:*} "(space_to_select)" off; done | sort -u ))
            HOSTSELECTION=$(F_DIALOG --colors --checklist "\nPlease use the space-bar to make your selection to upgrade $UPGTYPE \Zb\Zuv${STAGEDVER}\ZB\ZU\n" 50 100 100 "${OPTIONS[@]}" 2>&1 >/dev/tty)
            [ $? -ne 0 ] && ABORTED=1
            F_LOG $FUNCNAME "HOSTSELECTION=$HOSTSELECTION, ABORTED=$ABORTED"
            if [ "$HOSTSELECTION" == "ABORTED" ]||[ $ABORTED -eq 1 ];then
                ABORTED=1 && break
            else
                if [ -z "$HOSTSELECTION" ];then
                    F_LOG $FUNCNAME "No selection made / HOSTSELECTION empty!"
                    F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                else
                    HOSTSELECT=1
                    ABORTED=0
                fi
            fi
        done
        [ $ABORTED -eq 1 ] && return 4
    else
        HOSTSELECTION="$UHOSTS"
        ABORTED=0
    fi
    
    SHOSTST="$(echo "$HOSTSELECTION" | sed 's/ /\n/g')"

    if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ] || [ -z "$HOSTSELECTION" ];then
                F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) or HOSTSELECTION ($HOSTSELECTION) empty"
                F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
                return 3
    else
                F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG $FUNCNAME "hostsel: $HOSTSELECTION"

    FORMARGS='50 100 35 '      # height, width, form height

    FLINE=1
    for tg in $HOSTSELECTION;do
        FORMARGS+=' '"$tg"' '$FLINE' 1 1 '$FLINE' 40 4 3'
        FLINE=$((FLINE + 1))
    done

    F_LOG $FUNCNAME "FORMARGS: $FORMARGS"

    UPGORDER=$(F_DIALOG --colors --form "\nPuzzle your custom order for upgrading $UPGTYPE to \Zb\Zuv${STAGEDVER}\ZB\ZU\n\nHowto:\nweight each target group with a number from 001-999 (or 1-9, 01-99, 001-999).\nThe upgrade will be done from LOW to HIGH based on these numbers.\n\n\nNote: upgrades do NOT happen in parallel but \Zbsequentially\ZB.\n\nWARNING:\n\ZbTHERE IS NO WAIT BETWEEN EACH HOST SO JUST SELECT WHAT YOU WANT TO UPGRADE IN ONE RUN!!!\ZB\n" \
               $FORMARGS \
               3>&1 1>&2 2>&3 )
    if [ $? -ne 0 ];then
        F_LOG $FUNCNAME "aborted on user request"
        return 4
    fi
    SORTED=$(for num in $UPGORDER;do \
                F_LOG $FUNCNAME "prehostsel: $HOSTSELECTION"; \
                CURSEL=$(echo "$HOSTSELECTION" |cut -d ' ' -f1); \
                echo "${num}:${CURSEL}"; \
                HOSTSELECTION=$(echo "$HOSTSELECTION" | sed "s/$CURSEL //g" ); \
                F_LOG $FUNCNAME "posthostsel: $HOSTSELECTION CURSEL $CURSEL"; \
             done | sort -u |sort -n)
    
    F_LOG $FUNCNAME "UPGORDER=$UPGORDER\nSORTED: $SORTED"
    SORTO=$(echo -e "$SORTED" | sed 's/\n/,/g')
    F_LOG $FUNCNAME "$SORTO"

    F_DIALOG --colors --scrollbar --yesno "\n\nWill upgrade $UPGTYPE \Zb\Zuv${STAGEDVER}\ZB\ZU in this order:\n\n${SORTO}\n\nAre you sure?" 30 100
    RET=$?
    if [ $RET -ne 0 ];then
        F_LOG $FUNCNAME "aborted on user request"
        return $RET
    else	
        for utg in $SORTED;do
            F_UPGRADE "$UPGTYPE" "${utg/*:/}"
            UPERR=$?
            [ $UPERR -ne 0 ] && break
        done
        F_ERRLOG "$UPERR" "Upgrade to $UPGTYPE v${STAGEDSPLVER} for:\n\n$SORTED" "$LOG"
    fi

    F_LOG $FUNCNAME ended
}

## @fn F_DEPLOYMENU()
## @brief A submenu for app deployment tasks
## @return a submenu action
## @details Shows several deployment tasks in an own submenu
F_DEPLOYMENU(){ 
    F_LOG $FUNCNAME started
    unset SELECTION DEPLOYAPPSUBSET
    SELECTION=$(F_DIALOG --ok-label "Select an entry" --cancel-label "Back" --colors \
                    --menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
                        20 90 80 \
                        '' '\Zb\ZuApp-Deployment Tasks\ZB\ZU'\
                        "" "" \
                        Choose "(Re-)Deploy only specific App(s) on a target" \
                        ALL-Apps "Deploy all linked Apps of a target" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

    F_LOG $FUNCNAME "selected task: $SELECTION"
    if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              return 4
    else
        case "$SELECTION" in
            Choose)
                export DEPLOYAPPSUBSET=1
                F_DEPLOYAPP
                F_DEPLOYMENU
            ;;
            ALL-Apps)
                export DEPLOYAPPSUBSET=0
                F_DEPLOYAPP
                F_DEPLOYMENU
            ;;
            *)
                return 3
            ;;
        esac
    fi
    F_LOG $FUNCNAME ended
}


## @fn F_DEPLOYAPP()
## @brief Deploy Apps to (a) specified target(s)
## @details Deploy Apps to (a) specified target(s)
## 1. Ask for hostfile
## 2. update all apps based on template
## 3. re-create deploy playbook to reflect manual changes like deleting an app
## 4. Ask for target group(s) to deploy
## 5. Deploy
F_DEPLOYAPP(){ 
        F_LOG $FUNCNAME "started with: $1 $2"
	# Ask for hostfile
	# update all apps based on template
	# re-create deploy playbook to reflect manual changes like deleting an app
	# Ask for target group(s) to deploy
	# Deploy
        echo "$FUNCNAME started" >> $LOG
        unset HOSTSELEXPANDED ABORTED HOSTSELECT HOSTFILE tgroup FMODE FAPPS

        F_LOG $FUNCNAME "DEPLOYAPPSUBSET=$DEPLOYAPPSUBSET"
        FMODE=$1
        FAPPS="$2"

        F_HOSTFILE $FMODE
        while [ -z "$HOSTSELECT" ];do
            if [ "$RUNMODE" == "interactive" ]&&[ -z "$FMODE" ];then 
                HOSTSELECTION=$(F_TARGETS checklist)
            else
                HOSTSELECTION=$(F_TARGETS checklist $BTARGET)
                SUBSETAPPS="$BDEPAPP"
            fi
            
                if [ "$HOSTSELECTION" == "ABORTED" ];then
                        ABORTED=1 && break
                else
                        if [ -z "$HOSTSELECTION" ];then
                                F_DIALOG --msgbox "ERROR: no selection made. Choose a target with space bar." 10 30
                        else
                                HOSTSELECT=1
                                ABORTED=0
                        fi
                fi
        done
	if [ "$ABORTED" -eq 0 ];then
	    F_LOG "$FUNCNAME" "Re-creating deployment playbook to reflect any manual changes.. "

            [ $DEPLOYAPPSUBSET == 0 ] && DEPTYPE="'deploy_type':'all'" && SUBSETAPPS=".*"
            if [ $DEPLOYAPPSUBSET == 1 ];then 
                LNKAPPS=$(F_LISTAPPS "$HOSTSELECTION" | cut -d ":" -f 2)
                F_LOG $FUNCNAME "Linked apps:\n$LNKAPPS"
                OPTIONS=($(for gapp in $LNKAPPS;do prapp="${gapp##*/}"; echo "${prapp/\.yml/}" "App" off; done))
                unset APPANS
                if [ "$RUNMODE" == "interactive" ]&&[ "$FMODE" != "auto" ];then
                    while [ -z "$APPANS" ];do
                        APPANS=$(F_DIALOG --checklist "\nPlease use the space-bar to make your selection:" 80 80 70 "${OPTIONS[@]}" 2>&1 >/dev/tty)
                        [ $? -ne 0 ] && F_LOG $FUNCNAME "Aborted on app selection" && return 9
                        [ ! -z "$APPANS" ] && SUBSETAPPS=$(echo "$APPANS" | sed 's/$/$/g;s/\ /|/g')
                    done
                else
                    F_LOG $FUNCNAME "running in automatic or non-interactive mode ($RUNMODE, $FMODE)"
                    [ ! -z $FAPPS ] && SUBSETAPPS="$FAPPS"
                fi

                F_LOG $FUNCNAME "Selected apps for deploy:\n$SUBSETAPPS"
                DEPTYPE="'deploy_type':'custom','deploy_sub_apps':'$SUBSETAPPS'"
                DEPAPPS="$SUBSETAPPS"
            fi
            # CLEAN previous deploy app playbook
            [ -f $AINVENTORY/$TARGETENV/$PBDEPLAPP ] && rm $AINVENTORY/$TARGETENV/$PBDEPLAPP && F_LOG "$FUNCNAME" "Deleted previous temp playbook"

#            F_LOG $FUNCNAME "will exec: $ABIN -i $HOSTFILE $PBREGENDEPLOY -e \"target=repository target_env=$TARGETENV $DEPTYPE\""
            F_ABIN $HOSTFILE $PBREGENDEPLOY "Regenerating temporary deploy-app playbook.." "-e {'target':'repository','target_env':'$TARGETENV',$DEPTYPE,'data_dir':'$DATADIR'}"
            LASTERR=$?; [ $LASTERR -ne 0 ] && F_LOG $FUNCNAME "ended with $LASTERR" && return $LASTERR

            DEPAPPS=$(F_LISTAPPS "$HOSTSELECTION" | cut -d ":" -f 1-2 | egrep "($SUBSETAPPS)" | sed 's/^/\\n - /g')
            [ -z "$DEPAPPS" ] && F_LOG $FUNCNAME "ERROR: No app found for deployment" && return 99
            F_LOG $FUNCNAME "Will deploy these apps on $HOSTSELECTION:\n$DEPAPPS"

            [ "$RUNMODE" == "interactive" ] && F_DIALOG --scrollbar --colors --yesno "PORS will process on\Zb\Z1\n\n   $HOSTSELECTION\n\n\Znthe following apps (use Page-up/-down to scroll, select <yes> to proceed):\Zb\Z4\n$DEPAPPS\n\n\ZnAre you sure?" 40 100
            LASTERR=$?
            if [ $LASTERR -eq 0 ]||[ "$RUNMODE" == "batch" ];then
		    for tgroup in $HOSTSELECTION;do
			F_LOG $FUNCNAME "will exec: $ABIN --check -i $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP -e 'target=$tgroup accept_hostkey=true' --tags $tgroup"
			F_ABIN $HOSTFILE $AINVENTORY/$TARGETENV/$PBDEPLAPP "Processing <$tgroup>..." "-e {'target':'$tgroup','accept_hostkey':'true'} --tags $tgroup"
                        LASTERR=$?; [ $LASTERR -ne 0 ] && F_LOG $FUNCNAME "ended with $LASTERR" && return $LASTERR
                        for ad in $(F_LISTAPPS "$HOSTSELECTION" | cut -d ":" -f 2 | tr -d '$');do
                            if [ -L "$DATADIR/custom/roles/apps/$ad/defaults" ];then 
                                F_LOG "$FUNCNAME" "link to $DATADIR/custom/roles/apps/$ad/defaults already set" 
                            else
                                ln -fvs $ADIR/roles/defaults $DATADIR/custom/roles/apps/$ad/ >> $LOG 2>&1 && F_LOG $FUNCNAME "created roles/defaults in $DATADIR/custom/roles/apps/$ad dir" 
                            fi
                        done
                        LASTERR=$?
                        F_LOG $FUNCNAME "Processing\n\n$DEPAPPS\n\nto $tgroup ended with $LASTERR"
                        if [ $LASTERR -eq 0 ];then    
                            for app in $(F_LISTAPPS "$HOSTSELECTION" | cut -d ":" -f 2 | tr -d '$');do
                                APPP="$AINVENTORY/$TARGETENV/group_vars/$tgroup/$app"
                                egrep -ql "^\s*delete:\s*[Tt]rue" $APPP && F_LOG $FUNCNAME "$app has been removed on $tgroup. removing local link..." && rm -vf $APPP 2>&1 >> $LOG
                            done
		            [ "$RUNMODE" == "interactive" ] && F_ERRLOG "$LASTERR" "<processing apps on $tgroup>" "$LOG"
                            # always end with errcode 0
                            true
                        else
		            [ "$RUNMODE" == "interactive" ] && F_ERRLOG "$LASTERR" "<processing apps on $tgroup>" "$LOG"
                        fi
		    done
                    F_PORSACTION "nogit" "$FUNCNAME | deployed/removed/unlinked these apps on $HOSTSELECTION: $DEPAPPS"
            else
                F_ERRLOG 3 "Aborted by user\n" "$LOG"
            fi
	fi
        F_LOG $FUNCNAME "ended with $LASTERR"
        return $LASTERR
}


## @fn F_CLUSTER()
## @brief Indexer cluster menu
## @exception When no valid answer given returning to MAIN menu
## @details Provides a menu for several cluster tasks 
F_CLUSTER(){ 
        F_LOG $FUNCNAME started
	unset SELECTION
	SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
                   --menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
                    	20 90 80 \
                        '' '\Zb\ZuMaintenance\ZB\ZU'\
                        "" "" \
                        OfflinePeer "NOT-READY-YET" \
                        RemovePeer "NOT-READY-YET" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

        if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              return 4
        else
                case "$SELECTION" in
                        *)
                        return 3
                        ;;
		esac
	fi
    F_LOG $FUNCNAME ended
}


## @fn F_VMMENU()
## @brief Menu for doing VM tasks
## @exception ..
## @details Provides a menu to deploy VM's and/or configure them
F_VMMENU(){
        F_LOG $FUNCNAME started
        unset SELECTION
        SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
                   --menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
                        20 90 80 \
                        '' '\Zb\ZuVM operations\ZB\ZU'\
                        "" "" \
                        VM-Deploy "Deploy a new blank VM (OS + ansible-ready)" \
                        Add_newDisk "WIP: add a new disk to an existing VM" \
                        Format_newDisk "WIP: format a (usually) blank disk of an existing VM" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

        if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              return 4
        else
                case "$SELECTION" in
                        VM-Deploy)
                        F_DEPLOYVM
                        ;;
                        Add_newDisk)
                        F_ADDDISK
                        ;;
                        Format_newDisk)
                        F_FSDISK
                        ;;
                        *)
                        return 4
                        ;;
                esac
        fi
    F_LOG $FUNCNAME ended
}


## @fn F_CONFMENU()
## @brief Configure splunk server roles
## @exception ..
## @details Provides a menu to configure several splunk server roles
F_CONFMENU(){ 
        F_LOG $FUNCNAME started
        unset SELECTION
        SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
                   --menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
                        30 100 80 \
                        '' '\Zb\ZuConfigure splunk\ZB\ZU'\
                        "" "" \
                        LicenseMaster "(re-)apply LicenseMaster configuration" \
                        MasterNode "(re-)apply Indexer MasterNode configuration" \
                        PeerNode "(re-)apply Indexer peernode configuration" \
                        DeploymentServer "(re-)apply DeploymentServer configuration" \
                        SearchHead "(re-)apply Standalone (i.e not-clustered) SearchHead configuration" \
                        HeavyForwarder "(re-)apply HeavyForwarder configuration" \
                        Deployer "(re-)apply Deployer configuration" \
                        SHCmember "(re-)apply SearchHead Cluster member configuration" \
                        MonitoringConsole "(re-)apply MonitoringConsole configuration" \
                        "" "" \
                        '' '\Zb\ZuConfigure cribl logstream\ZB\ZU'\
                        "" "" \
                        LogstreamLeader "(re-)apply logstream leader configuration" \
                        LogstreamWorker "(re-)apply logstream worker configuration" \
                        "" "" \
                        "" "" \
                        3>&1 1>&2 2>&3)

        if [ "$?" != "0" ]; then
              MENUDONE=1
              F_LOG $FUNCNAME "aborted by user"
              return 4
        else
                case "$SELECTION" in
                        SearchHead)        F_ADDSH ;;
                        PeerNode)          F_ADDPEER ;;
                        MasterNode)        F_ADDMN ;;
                        MonitoringConsole) F_ADDMC ;;
                        HeavyForwarder)    F_ADDHF ;;
                        LicenseMaster)     F_ADDLM ;;
                        Deployer)          F_ADDDEP ;;
                        DeploymentServer)  F_ADDDS ;;
                        SHCmember)         F_ADDSHCMEMBER ;;
                        LogstreamLeader)   F_CONFLOGSTREAM logstream_leader;;
                        LogstreamWorker)   F_CONFLOGSTREAM logstream_worker;;
                        *) return 3;;
                esac
        fi
    F_LOG $FUNCNAME ended
}

## @fn F_DEPLOYKEY()
## @brief Deploy a splunk server key to one or multiple targets
## @param1 source hostname (as in ansible hosts file)
## @param2 destination target group
## @exception ..
## @details Deploys the public key into etc/auth/distServerKeys/{source}.
## This allows to add the remote host as a search peer.
F_DEPLOYKEY(){
    F_LOG $FUNCNAME started
    unset SRCNAME
    
    SRCNAME="$1"
    DESTGRP="$2"

    if [ -z "$SRCNAME" ]||[ -z "$DESTGRP" ];then
        F_LOG $FUNCNAME "ERROR: Missing param ($SRCNAME, $DESTGRP)"
        return 3
    fi
    
    F_ABIN "$HOSTFILE" "$PBDEPLOYKEY" "\Za\Z1Key deployment running ...\Z\n" "-e {'target_group':'$DESTGRP'} --limit $SRCNAME"
    LERR="${PIPESTATUS[0]}"
    [ $LERR -ne 0 ] && F_ERRLOG "$LERR" "Deploying key of: $SRCNAME" "$LOG" && return $LERR
    F_PORSACTION "nogit" "$FUNCNAME | deployed splunk key of $SRCNAME to $DESTGRP"
    F_LOG $FUNCNAME ended
} 


## @fn F_ADDDEP()
## @brief Configures splunk to be a SHC Deployer
## @exception ..
## @details ..
F_ADDDEP(){
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST HOSTSELECTION LIMITLIST
    export LISTTYPE=radiolist

    # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
    > $ITMPGRP

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
    SHOSTS="$(F_EXPANDHOSTS deployer $ITMPGRP clean | sed 's/.*deployer//g')"
    [ $? -ne 0 ] && return $?
    [ "$SHOSTS" == ABORTED ] && return 4

    OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
    HOSTSELECTION=$(F_DIALOG --${LISTTYPE} "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
    [ $? -ne 0 ] && return $?

    SHOSTST="$(echo "$HOSTSELECTION" | sed 's/ /\n/g' | cut -d ':' -f 1)"
    [ "$SHOSTS" == ABORTED ] && return 4

    if  [ -z "$HOSTSELECTION" ] || [ -z $SHOSTST ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
            return 3
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG "$FUNCNAME" "Will configure deployer on <$SHOSTS>"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas SHC Deployer. Are you sure?" 30 100
    [ $? -ne 0 ] && return $?

    # check ssh first
    F_CHECKSSH "$SHOSTST" "$ITMPGRP"

    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$SHOSTST" | tr "\n" : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3

    # doit
    F_ABIN "$HOSTFILE" "$PBCONFDEP" "\Za\Z1Configure ...\Z\n" "--limit $LIMITLIST -e target='$LIMITLIST'"
    LASTERR=$?
    F_ERRLOG "$LASTERR" "configuration SHC Deployer on:\n\n$SHOSTST" "$LOG"
    F_PORSACTION "nogit" "$FUNCNAME | configured $HOSTSELECTION as SHC deployer"

    F_LOG $FUNCNAME ended
    return $LASTERR
}

## @fn F_ADDLM()
## @brief Configures splunk to be a LicenseMaster
## @exception ..
## @details ..
F_ADDLM(){
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST HOSTSELECTION LIMITLIST
    export LISTTYPE=radiolist

    # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
    > $ITMPGRP

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
    SHOSTS=$(F_EXPANDHOSTS licensemaster "$ITMPGRP" clean)
    [ $? -ne 0 ] && return $?
    [ "$SHOSTS" == ABORTED ] && return 4

    OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
    HOSTSELECTION=$(F_DIALOG --${LISTTYPE} "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
    [ $? -ne 0 ] && return $?

    SHOSTST="$(echo "$HOSTSELECTION" | sed 's/ /\n/g'| cut -d ':' -f 1)"
    [ "$SHOSTS" == ABORTED ] && return 4

    if  [ -z "$HOSTSELECTION" ] || [ -z "$SHOSTST" ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
            return 3
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG "$FUNCNAME" "Will configure LicenseMaster on <$SHOSTS>"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas license master. Are you sure?" 30 100
    [ $? -ne 0 ] && return $?

    # check ssh first
    F_CHECKSSH "$SHOSTST" "$ITMPGRP"

    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$SHOSTST" | tr "\n" : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3

    # doit
    F_ABIN "$HOSTFILE" "$PBCONFLM" "\Za\Z1Configure ...\Z\n" "--limit $LIMITLIST -e target='$LIMITLIST'"
    LERR=$?
    #[ $LERR -ne 0 ] && 
    F_ERRLOG "$LERR" "configuration LicenseMaster on:\n\n$SHOSTST" "$LOG" && return $LERR

    # FIXME: might be not needed anymore: deploy pub key for dist search
#    PEERS=$(F_EXPANDHOSTS peernode $ITMPGRP clean | sed 's/site._.*//g')
#    for p in $PEERS;do F_DEPLOYKEY ${SHOSTST/:*/} ${p/:*/} ; done
    #F_ERRLOG "$LERR" "configuration LicenseMaster on:\n\n$SHOSTST" "$LOG"

    F_PORSACTION "nogit" "$FUNCNAME | configured $HOSTSELECTION as LicenseMaster"
    unset LISTTYPE
    F_LOG $FUNCNAME ended
    return $LERR
}

## @fn F_ADDMN()
## @brief Configures splunk to be a MasterNode
## @exception ..
## @details ..
F_ADDMN(){ 
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST HOSTSELECTION LIMITLIST
    export LISTTYPE=radiolist

    # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
    > $ITMPGRP

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
    SHOSTS="$(F_EXPANDHOSTS masternode $ITMPGRP clean | sed 's/masternode//g')"
    [ "$SHOSTS" == ABORTED ] && return 4

    OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
    HOSTSELECTION=$(F_DIALOG --${LISTTYPE} "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)

    SHOSTST=$(echo "$HOSTSELECTION" | sed 's/ /\n/g' | cut -d ':' -f 1)

    if  [ -z "$HOSTSELECTION" ] || [ -z "$SHOSTST" ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
            return 3
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG "$FUNCNAME" "Will configure indexer MasterNode on <$SHOSTS>"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas indexer masternode. Are you sure?" 30 100
    [ $? -ne 0 ] && return $?

    # check ssh first
    F_CHECKSSH "$SHOSTST" "$ITMPGRP"

    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$SHOSTST" | tr "\n" : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3

    # doit
    F_ABIN "$HOSTFILE" "$PBCONFMN" "\Za\Z1Configure ...\Z\n" "--limit $LIMITLIST -e target='$LIMITLIST'"
    F_ERRLOG "${PIPESTATUS[0]}" "configuration as indexer MasterNode on:\n\n$SHOSTST" "$LOG"

    # FIXME: deploy pub key for dist search (useless here? IDX are likely not setup yet
    #PEERS=$(F_EXPANDHOSTS peernode $ITMPGRP | sed 's/site._.*//g')
    #for p in $PEERS;do F_DEPLOYKEY $SHOSTST $p ; done

    F_PORSACTION "nogit" "$FUNCNAME | configured $HOSTSELECTION as Indexer MasterNode"
    unset LISTTYPE
    F_LOG $FUNCNAME ended
}

## @fn F_GETSITES()
## @brief Get all configured sites from a host file
## @exception ..
## @details ..
F_GETSITES(){
    F_LOG $FUNCNAME started
    SITES=$(egrep '^\[site.*_.*\]' $HOSTFILE | tr -d "[" |tr -d "]" | cut -d "_" -f 1 | sort -u)

    F_LOG $FUNCNAME "found these sites: $SITES"
    echo "$SITES"

    F_LOG $FUNCNAME ended
}


## @fn F_ADDMC()
## @brief Configures a new peer as MonitoringConsole
## @exception ..
## @details ..
F_ADDMC(){
    F_LOG $FUNCNAME started
    unset SITESEL HOSTSELECTION OPTIONS SHOSTS SHOSTST ASITES SITEMON LIMITLIST

    WHAT=monitoringconsole

    # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
    > $ITMPGRP

    ASITES=$(F_GETSITES)
    while [ -z "$SITESEL" ];do
        OPTIONS=($(echo "none one_for_all_sites on";for i in $ASITES;do echo "${i} use_space-bar_to_select off"; done))
        SITESEL=$(F_DIALOG --radiolist "Please choose a site.\n\nNOTE: The $WHAT might be NOT site specific in your environment. If so choose 'none' here.\n\nIn other words: if you want to use 1 MC for all sites choose 'none'." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        WERR=$?
        [ $WERR -eq 0 ] && [ ! -z "$SITESEL" ] && continue
        [ $WERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
    if [ "$SITESEL" == "none" ];then
        TG=$WHAT
    else
        TG="${SITESEL}_${WHAT}"
    fi

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
    SHOSTS=$(F_EXPANDHOSTS ${TG} $ITMPGRP clean | sed "s/$TG//g")
    while [ -z "$HOSTSELECTION" ];do
        OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
        HOSTSELECTION=$(F_DIALOG --checklist "Please use the space-bar to make your selection." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        HERR=$?
        [ $HERR -eq 0 ] && [ ! -z "$HOSTSELECTION" ] && continue
        [ $HERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
    SHOSTST=$(echo "$HOSTSELECTION" | sed 's/ /\n/g' | cut -d ':' -f 1)

    if  [ -z "$HOSTSELECTION" ] || [ -z "$SHOSTST" ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"; F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
            return 3
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    while [ -z "$SITEMON" ];do
        OPTIONS=($(for i in $ASITES;do echo "${i} use_space-bar_to_select off"; done))
        SITEMON=$(F_DIALOG --checklist "The MC should monitor hosts in which site(s)?\n\nNOTE: The $WHAT might be used to monitor specific sites only. Select one ore more sites." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        SERR=$?
        [ $SERR -eq 0 ] && [ ! -z "$SITEMON" ] && continue
        [ $SERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done

    F_LOG "$FUNCNAME" "Will configure $WHAT on <$HOSTSELECTION>"
    [ $RUNMODE != "batch" ] && F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas ${WHAT}. Are you sure?" 30 100
    [ $? -ne 0 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\n... preparing all requirements" 5 35

    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$SHOSTST" | tr "\n" : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3

    # doit
    F_ABIN "$HOSTFILE" "$PBCONFMC" "\Za\Z1Configure ...\Z\n" "--limit $LIMITLIST -e target='$LIMITLIST'"
    CONERR=$?
    [ $CONERR -ne 0 ] && F_LOG "$FUNCNAME" "aborted due to an error on configure playbook ($CONERR)" && F_ERRLOG $CONERR "issue during configuration" $LOG && return $CONERR
    F_LOG $FUNCNAME "Finished configuration successfully.."

    # Add to monitoring
    GRPS="deployer peernode shcmember heavyforwarder deploymentserver heavyforwarder activeinput httpeventcollector masternode licensemaster"
    DERR=0
#FIXME: use all + negative $LIMITLIST ?
    for t in $GRPS;do
        F_LOG $FUNCNAME "will exec: F_ABIN $ITMPGRP $PBDEPLMONKEY 'Deploying MC key ...' -e {'target':'$t'} --limit $WHAT"
#        F_ABIN "$ITMPGRP" "$PBDEPLMONKEY" "\Za\Z1Deploying MC key ...\Z\n" "-e {'target':'$t'} --limit $WHAT"
        [ $? -ne 0 ] && F_LOG $FUNCNAME "Failed to setup monitoring for: $t" && DERR=1 && break
    done
    [ $DERR -ne 0 ] && F_ERRLOG "$DERR" "configuration as $WHAT on:\n\n$SHOSTST" "$LOG" && return $DERR

    # configure MC as MC
    DERR=0
    F_ABIN "$ITMPGRP" "$PBCONFMC" "\Za\Z1Setup MC ...\Z\n" "-e {'target':'$t'} --limit $WHAT"
    [ $DERR -ne 0 ] && F_ERRLOG "$DERR" "configuration as $WHAT on:\n\n$SHOSTST" "$LOG" && return $DERR

    # TODO: restart all GRPS
    GRPCOL=$(echo "$GRPS" | tr " " ":")
    DERR=0
    F_DIALOG --scrollbar --yesno "\n\nMonitoringConsole setup finished. To fully enable monitoring access splunk must be RESTARTED on all configured hosts: \n\n$GRPS\n\nIf you skip this step you have to configure the MC roles by yourself.\n\nSo, should I splunk restart all these hosts?" 30 100
    if [ $? -ne 0 ];then 
        F_LOG "$FUNCNAME" "Aborted by user"
        F_ERRLOG 4 "ABORTED by user - configuration as $WHAT on:\n\n$SHOSTST" "$LOG"
        return 4
    else
        F_LOG $FUNCNAME "will exec: F_ABIN $ITMPGRP $PBSPLACT 'Reloading splunk ...' -e {'splunk_action':'reload_all','shelper':'True'} --limit $GRPCOL"
        F_ABIN "$ITMPGRP" $PBSPLACT "\Za\Z1Reloading splunk ...\Z\n" "-e {'splunk_action':'reload_all','shelper':'True'} --limit $GRPCOL"
        [ $DERR -ne 0 ] && F_ERRLOG "$DERR" "configuration as $WHAT on:\n\n$SHOSTST" "$LOG" && return $DERR
        # auto-configure MC roles
        DERR=0
        F_LOG $FUNCNAME "will exec: F_ABIN $ITMPGRP $PBCONFMONROLES 'Setting up MC Roles ...' -e {'target':'$t'} --limit $WHAT"
        F_ABIN "$ITMPGRP" "$PBCONFMONROLES" "\Za\Z1Setting up MC Roles ...\Z\n" "-e {'target':'$t'} --limit $WHAT"
        [ $DERR -ne 0 ] && F_ERRLOG "$DERR" "configuration as $WHAT on:\n\n$SHOSTST" "$LOG" && return $DERR
    fi
    
    F_ERRLOG $? "configuration as $WHAT on:\n\n$SHOSTST" "$LOG"
    F_PORSACTION "nogit" "$FUNCNAME | configured $HOSTSELECTION as $WHAT"
    F_LOG $FUNCNAME ended
}

## @fn F_ADDDS()
## @brief Configures a new peer as SearchHead DeploymentServer
## @exception ..
## @details ..
F_ADDDS(){
    F_LOG $FUNCNAME started
    unset SITESEL HOSTSELECTION OPTIONS SHOSTS SHOSTST ASITES LIMITLIST

    # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
    > $ITMPGRP

    ASITES=$(F_GETSITES)
    while [ -z "$SITESEL" ];do
        OPTIONS=($(echo "none one_for_all_sites on"; for i in $ASITES;do echo "${i} use_space-bar_to_select off"; done))
        SITESEL=$(F_DIALOG --radiolist "Please choose a site you want to configure.\n\nNOTE: The DS might be not site specific in your environment. If so choose 'none' here." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        SERR=$?
        [ $SERR -eq 0 ] && [ ! -z "$SITESEL" ] && continue
        [ $SERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
    if [ "$SITESEL" == "none" ];then
        TG=deploymentserver
    else
        TG="${SITESEL}_deploymentserver"
    fi

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
    SHOSTS=$(F_EXPANDHOSTS ${TG} $ITMPGRP clean | sed "s/$TG//g")
    while [ -z "$HOSTSELECTION" ];do
        OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
        HOSTSELECTION=$(F_DIALOG --checklist "Please use the space-bar to make your selection." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        HERR=$?
        [ $HERR -eq 0 ] && [ ! -z "$HOSTSELECTION" ] && continue
        [ $HERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
    SHOSTST=$(echo "$HOSTSELECTION" | sed 's/ /\n/g' | cut -d ':' -f 1)

    if  [ -z "$HOSTSELECTION" ] || [ -z "$SHOSTST" ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"; F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
            return 3
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby.. (setting up some magic)" 5 45

    F_LOG "$FUNCNAME" "Will configure deploymentserver on <$HOSTSELECTION>"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas Deploymentserver. Are you sure?" 30 100
    [ $? -ne 0 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4

    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$SHOSTST" | tr "\n" : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3

    # doit
    F_ABIN "$HOSTFILE" "$PBCONFDS" "\Za\Z1Configure ...\Z\n" "--limit $LIMITLIST -e target='$LIMITLIST'"
    LASTERR=$?
    F_ERRLOG "$LASTERR" "configuration as Deploymentserver on:\n\n$SHOSTST" "$LOG"
    F_PORSACTION "nogit" "$FUNCNAME | configured $HOSTSELECTION as DeploymentServer"
    F_LOG $FUNCNAME ended
    return $LASTERR
}

## @fn F_ADDSHCMEMBER()
## @brief Configures a new peer as SearchHead Cluster Member
## @exception ..
## @details ..
F_ADDSHCMEMBER(){
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST HOSTSELECTION ASITES SITESEL LIMITLIST

    # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
    > $ITMPGRP

    ASITES=$(F_GETSITES)
    OPTIONS=($(for i in $ASITES;do echo "${i} use_space-bar_to_select off"; done))
    SITESEL=$(F_DIALOG --radiolist "Please choose a site you want to configure.\n\nNOTE: It is not possible to configure multiple sites in one run." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
    [ $? -ne 0 ] && return $?
    
    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
   
    SHOSTS="$(F_EXPANDHOSTS ${SITESEL}_shcmember $ITMPGRP clean | sed 's/site._.*//g')"
    [ $? -ne 0 ] && return $?
    [ "$SHOSTS" == ABORTED ] && return 4
 
    OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
    HOSTSELECTION=$(F_DIALOG --checklist "Please use the space-bar to make your selection.\n\nNOTE: It is not possible to configure multiple sites in one run so you will see here $SITESEL hosts only." 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
    [ $? -ne 0 ] && return $?
    
    SHOSTST=$(echo "$HOSTSELECTION" | sed 's/ /\n/g' | cut -d ':' -f 1)
    
    if  [ -z "$HOSTSELECTION" ] || [ -z "$SHOSTST" ];then
            F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
            return 3
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby.. (setting up some magic)" 5 45

    F_LOG "$FUNCNAME" "Will configure shc member on <$HOSTSELECTION>"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas SHC member. Are you sure?" 30 100
    [ $? -ne 0 ] && return $?
    
    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$SHOSTST" | tr "\n" : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3
  
    # doit
    F_ABIN "$HOSTFILE" "$PBCONFSHCM" "\Za\Z1Configure ...\Z\n" "--limit $LIMITLIST -e {'target':'$LIMITLIST','shc_site':'${SITESEL}'}"
    LASTERR=$?
    F_ERRLOG "$LASTERR" "configuration as SHC member on:\n\n$SHOSTST" "$LOG"
    F_PORSACTION "nogit" "$FUNCNAME | configured $HOSTSELECTION as SHC member"
    F_LOG $FUNCNAME ended
    return $LASTERR
}

## @fn F_ADDPEER()
## @brief Configures a new peer to an existing indexer cluster
## @exception ..
## @details Configures a new peer to an existing indexer cluster 
F_ADDPEER(){
        F_LOG $FUNCNAME started

	unset SHOSTS SHOSTST HOSTSELECTION ITMPGRP LIMITLIST

        # a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
        ITMPGRP="${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts"
        > $ITMPGRP

        [ $RUNMODE != "batch" ] && F_DIALOG --infobox "\nPlease standby until all hostnames from your target groups are generated" 5 80
        SHOSTS="$(F_EXPANDHOSTS peernode $ITMPGRP clean | sed 's/site._.*//g')"
        [ "$SHOSTS" == ABORTED ] && return 4

        OPTIONS=($(for i in ${SHOSTS};do echo "${i} use_space-bar_to_select off"; done))
        HOSTSELECTION=$(F_DIALOG --checklist "Please use the space-bar to make your selection:" 30 80 30 "${OPTIONS[@]}" 2>&1 >/dev/tty)
        [ $? -ne 0 ] && return $?

        SHOSTST=$(echo "$HOSTSELECTION" | sed 's/ /\n/g' | cut -d ':' -f 1)

        if  [ -z "$HOSTSELECTION" ] || [ -z "$SHOSTST" ];then
                F_LOG $FUNCNAME "SHOSTS ($HOSTSELECTION) or SHOSTST ($SHOSTST) empty"
                F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
            return 3
        else
                F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
        fi

        F_LOG "$FUNCNAME" "Will configure indexer peernode on <$HOSTSELECTION>"
        F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas indexer peernode(s). Are you sure?" 30 100
        [ $? -ne 0 ] && return $?

    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$SHOSTST" | tr "\n" : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3

        # doit
        F_ABIN "$HOSTFILE" "$PBCONFPEER" "\Za\Z1Configure ...\Z\n" "--limit $LIMITLIST -e target='$LIMITLIST'"
        F_ERRLOG "${PIPESTATUS[0]}" "configuration as indexer peernode on:\n\n$SHOSTST" "$LOG"
        F_PORSACTION "nogit" "$FUNCNAME | configured $HOSTSELECTION as indexer peernode"
        F_LOG $FUNCNAME ended	
}

## @fn F_ADDSH()
## @brief Configures splunk to be a SearchHead
## @exception ..
## @details ..
F_ADDSH(){ 
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST HOSTSELECTION ITMPGRP LIMITLIST

    LISTTYPE=checklist
    SHOSTS="$(F_SELHOST)"
    [ $? -ne 0 ] && return $?
    [ "$SHOSTS" == ABORTED ] && return 4
    SHOSTST=$(echo "$SHOSTS" | sed 's/ /\n/g' | cut -d ':' -f 1)

    if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ];then
            F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
            return 3
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG "$FUNCNAME" "Will configure <$SHOSTS> as a SearchHead"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas SearchHead(s). Are you sure?" 30 100
    [ $? -ne 0 ] && return $?

    # create a temporary ansible group (must be in the correct env path! otherwise varibles cant be found)
    ITMPGRP=${AINVENTORY}/${TARGETENV}/${FUNCNAME}_hosts
    > $ITMPGRP

    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$SHOSTST" | tr "\n" : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3

    # doit
    F_ABIN "$HOSTFILE" "$PBCONFSH" "\Za\Z1Configure ...\Z\n" "--limit $LIMITLIST -e target='$LIMITLIST'"
    F_ERRLOG "${PIPESTATUS[0]}" "configuration as SearchHead on:\n\n$SHOSTST" "$LOG"
    F_PORSACTION "nogit" "$FUNCNAME | configured $SHOSTS as SearchHead"
    F_LOG $FUNCNAME ended
}

## @fn F_ADDHF()
## @brief Configures splunk to be a Heavy Forwarder
## @exception ..
## @details ..
F_ADDHF(){ 
    F_LOG $FUNCNAME started
    unset SHOSTS SHOSTST LIMITLIST

    SHOSTS="$(F_SELHOST)"
    [ $? -ne 0 ] && return $?
    [ "$SHOSTS" == ABORTED ] && return 4
    SHOSTST="$(echo "${SHOSTS}" | sed 's/ /\n/g' | cut -d ':' -f 1)"

    if  [ -z "$SHOSTS" ] || [ -z $SHOSTST ];then
            F_LOG $FUNCNAME "SHOSTS ($SHOSTS) or SHOSTST ($SHOSTST) empty"
            F_ERRLOG "3" "INTERNAL ERROR OCCURED in $FUNCNAME" "$LOG"
            return 3
    else
            F_LOG $FUNCNAME "SHOSTS and SHOSTST are both set"
    fi

    F_LOG "$FUNCNAME" "Will configure <$SHOSTS> as a Heavy Forwarder"
    F_DIALOG --scrollbar --yesno "Will configure: \n\n$SHOSTST\n\nas Heavy Forwarder(s). Are you sure?" 30 100
    [ $? -ne 0 ] && return $?

    F_WAITBOX "... preparing configuration files"

    # define a valid limit group depending on the user's selection
    LIMITLIST=$(echo "$SHOSTST" | tr "\n" : | sed 's/:$//g' )
    [ -z "$LIMITLIST" ] && F_ERRLOG 3 "empty LIMITLIST in $FUNCNAME" $LOG && return 3

    # doit
    F_ABIN "$HOSTFILE" "$PBCONFHF" "\Za\Z1Configure ...\Z\n" "--limit $LIMITLIST -e target='$LIMITLIST'"
    F_ERRLOG "${PIPESTATUS[0]}" "configuration as Heavy Forwarder on:\n\n$SHOSTST" "$LOG"
    F_PORSACTION "nogit" "$FUNCNAME | configured $SHOSTS as HeavyForwarder"      
    F_LOG $FUNCNAME ended
}


## @fn F_VAULTPW()
## @brief Ask for the Vault password if required
## @exception ..
## @details Ansible Vault dialog to grab the pass and store it temporary
## After using this you HAVE TO ensure using F_RMVAULTPW after the pw file is not needed anymore.
F_VAULTPW(){ 
    F_LOG $FUNCNAME started

    RETRY=1

    # skip if we do not have vault enabled
    [ "$ENABLEVAULT" != "yes" ] && F_LOG $FUNCNAME "skipping vault request as ENABLEVAULT is not yes" && return 0

    # skip if vault tmp file exists
    [ -s "$VAULTTEMPFILE" ] && F_LOG $FUNCNAME "skipping vault request as vault temp file exists already" && return 0

    while [ $RETRY -ne 0 ];do
        FPW=$(F_DIALOG --insecure --mixedform \
                "\nAnsible Vault is enabled (ENABLEVAULT variable).\nPlease type in the Vault password to unlock protected variables:\n" 10 80 0 \
                "Password:" 1 1 '' 1 20 20 0 1 \
                 2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && clear && echo -e "\nsorry but no password - no cookies..\n" && F_EXIT 4

        # write the vault temp file
        echo "$FPW" > $VAULTTEMPFILE 2>> $LOG

        F_LOG $FUNCNAME "will test given password on: $DEFAULTVAULT"
        $VBINX view $DEFAULTVAULT --vault-password-file $VAULTTEMPFILE 1> /dev/null 2>> $LOG
        if [ $? -ne 0 ];then
            RETRY=1
            F_DIAERR 9 "Oops password is incorrect. Try again.."
            unset FPW
            rm $VAULTTEMPFILE
        else
            RETRY=0
        fi
    done

    F_LOG $FUNCNAME ended
}

## @fn F_VSPHERE_VCDEFS()
## @brief Collects every PORS relevant vCenter information
## @details Connects to a given vCenter and stores all collected stuff in 
## $AINVENTORY/$TARGETENV/vmware (defined in $PBVCINFO playbook)
F_VSPHERE_VCDEFS(){ 
    F_LOG $FUNCNAME started
    F_ABIN $HOSTFILE $PBVCSHOW "Collecting vCenter definitions..."
    LASTERR=$?
    F_LOG $FUNCNAME ended
    return $LASTERR
}

## @fn F_VSPHERE_VCGETINFO()
## @brief Collects and sets every PORS relevant vCenter information
## @details Connects to a given vCenter and stores all collected stuff in 
## $AINVENTORY/$TARGETENV/tmp (defined in $PBVCINFO playbook) and let the user choose from it
F_VSPHERE_VCGETINFO(){ 
    F_LOG $FUNCNAME started
    VCWORKDIR="$AINVENTORY/$TARGETENV/tmp"

    F_LOG $FUNCNAME $VMCPU

    # collect configured vcenter definitions
    F_VSPHERE_VCDEFS
    VERR=$?
    [ $VERR -ne 0 ] && F_DIAERR $VERR "ERROR: during F_VSPHERE_VCDEFS" && return 3

    OPTIONS=($(for i in $(cat $VCWORKDIR/vcenters.list);do echo "${i/*:}" "${i/:*}" off;done))
    VCENTER=$(F_DIALOG --radiolist \
            "\nThese are the currently defined vCenters\n($INVENTORY/$TARGETENV/group_vars/all/bare_install)\n\nPlease use the space-bar to make your selection:" \
            80 80 70 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
    [ $? -ne 0 ] && F_DIAERR 3 "During VCENTER selection" && return 4

    F_LOG $FUNCNAME "Choosen vCenter was: $VCENTER"   
 
    # check previous lists, if one of them is not here or 0 bytes a refresh will be forced
    VCLIST="$VCWORKDIR/vcenters.list"
    VCHOSTLIST="$VCWORKDIR/${VCENTER}_vchosts.list"
    VCNETLIST="$VCWORKDIR/${VCENTER}_networks.list"
    VCDCLIST="$VCWORKDIR/${VCENTER}_datacenters.list"
    VCDSLIST="$VCWORKDIR/${VCENTER}_datastores.list"
    VCREFRESH=0

    for list in $VCLIST $VCHOSTLIST $VCNETLIST $VCDCLIST $VCDSLIST; do
        LISTSAVAIL=0
        F_LOG $FUNCNAME "CHECK: $list ..."
        test -s $list || break
        F_LOG $FUNCNAME "CHECK: $list exists already and is not 0 bytes..."
        LISTSAVAIL=1
    done
    F_LOG $FUNCNAME "LISTSAVAIL ended with $LISTSAVAIL"

    if [ $LISTSAVAIL -eq 1 ];then
        F_DIALOG --colors --yesno "\nPORS has detected cached vCenter information for:\n\n     \Zb$VCENTER\ZB\n\nDo you want to use the cache (choose: yes)\nor force a refresh (choose: no)?\n" 13 80
        VCREFRESH=$?
    fi
    if [ $LISTSAVAIL -eq 0 -o $VCREFRESH -eq 1 ];then
        F_ABIN $HOSTFILE $PBVCINFO "Collecting vCenter information ..." "-e {'vsphere_var':'$VCENTER'}"
    else
        F_LOG $FUNCNAME "Using cached vCenter lists but refreshing vhosts (always)"
        F_ABIN $HOSTFILE $PBVCGETVHOSTSTATES "Collecting vhosts states ..." "-e {'vsphere_var':'$VCENTER'}"
    fi
    LASTERR=$?; [ $LASTERR -ne 0 ] && F_LOG $FUNCNAME "ended with $LASTERR" && return $LASTERR

    for list in $VCLIST $VCHOSTLIST $VCNETLIST $VCDCLIST $VCDSLIST; do
        LISTSAVAIL=0
        F_LOG $FUNCNAME "CHECK: $list ..."
        test -s $list || break
        F_LOG $FUNCNAME "CHECK: $list exists already and is not 0 bytes..."
        LISTSAVAIL=1
    done
    F_LOG $FUNCNAME "LISTSAVAIL ended with $LISTSAVAIL"

    if [ $LISTSAVAIL -ne 1 ];then
        F_ERRLOG "3" "Error collecting ESX information!" "$LOG"
        return 3
    fi

    # Target ESX
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCHOSTLIST);do echo "${i/;*}" "${i/*;}" off;done))
        VCHOST=$(F_DIALOG --colors --radiolist \
            "\nThe following ESX hosts are handled by the choosen vCenter:\n\n    \Zb$VCENTER\ZB\n\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCHOST"
        HOSTFILTER=$(echo $VCHOST | cut -d "." -f1)
        [ ! -z "$VCHOST" ] && FINISHED=1
    done

    # Target Network name
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCNETLIST );do echo "${i/;*}" "${i/;*}" off;done))
        VCNET=$(F_DIALOG --colors --radiolist \
            "\nThe following Networks are handled by the choosen vCenter:\n\n    \Zb$VCENTER\ZB\n\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCNET"   
        [ ! -z "$VCNET" ] && FINISHED=1
    done

    # Target Datacenter name
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCDCLIST );do echo "${i/;*}" "${i/;*}" off;done))
        VCDC=$(F_DIALOG --colors --radiolist \
            "\nThe following Datacenters are handled by the choosen vCenter:\n\n    \Zb$VCENTER\ZB\n\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCDC"
        [ ! -z "$VCDC" ] && FINISHED=1
    done

    # Target Datastore name
    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCDSLIST);do free_gb=$((${i/*;}/1024/1024/1024)) ; echo "${i/;*}" "Free=${free_gb}GB" off;done))
        VCDS=$(F_DIALOG --colors --radiolist \
            "\nThe following Datastorages are handled by the choosen vCenter (\Zb$VCENTER\ZB)\nWhich one of the following should be used for provisioning\n(space-bar selects)?\n\nThe datastorage to store the\n\n   \ZbOperating System\ZB\n\n should be:\n" \
            100 80 100 \
            "${OPTIONS[@]}" \
            2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_DIAERR $? "Aborted by user" && break 99
        F_LOG $FUNCNAME "Choosen: $VCDS"   
        [ ! -z "$VCDS" ] && FINISHED=1
    done

    # DEPLOY IT
    F_VSPHERE_DEPLOY
    ERR=$?
    F_LOG $FUNCNAME "F_VSPHERE_DEPLOY ended with $ERR"
    return $ERR

    F_LOG $FUNCNAME ended
} 

## @fn F_VSPHERE_SELDS()
## @brief Select a datastore of a given vCenter
## @param 1 (exported) VCENTER
## @param 2 (exported) VCDSLIST
## @param 1 (exported) VMDISKDEV
## @param 1 (exported/optional) VMDISKMNTP
## @param 1 (exported) VMDISKSIZEGB
## @return name of datastore 
## @details Select a datastore of a given vCenter for a specific disk
F_VSPHERE_SELDS(){
    F_LOG $FUNCNAME started

    FINISHED=0
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $(tail -n +2 $VCDSLIST);do free_gb=$((${i/*;}/1024/1024/1024)) ; echo "${i/;*}" "Free=${free_gb}GB" off;done))
        VCDS=$(F_DIALOG --colors --radiolist \
                "\nThe following Datastorages are handled by the choosen vCenter ($VCENTER)\n\nWhich one of the following should be used for\n\n  \Zb${!VMDISKDEV} ${!VMDISKMNTP} (${!VMDISKSIZEGB} GB)\ZB\n\n(space-bar selects)?\n" \
                100 80 100 \
                "${OPTIONS[@]}" \
                2>&1 >/dev/tty)
        [ $? -ne 0 ] && F_LOG $FUNCNAME "ERROR $? - aborted by user" && return 99
        F_LOG $FUNCNAME "Choosen: $VCDS"
        [ ! -z "$VCDS" ] && FINISHED=1
    done
    echo "$VCDS"

    F_LOG $FUNCNAME ended
}

## @fn F_VSPHERE_DEPLOY()
## @brief Deploys the vSphere VM
## @param 1 required: the full path to the hardware profile to source
## @exception ..
## @details The actual doing is done here while it all starts in F_DEPLOYVM
F_VSPHERE_DEPLOY(){ 
    F_LOG $FUNCNAME started
    unset HWP
 
    HWP=$1
    if [ -z "$HWP" ] || [ ! -f "$HWP" ];then
        F_LOG $FUNCNAME "ERROR: missing hw profile! ABORTED" && return 3
    fi
    # make all user defined settings available here
    source $HWP

    # allow empty domain
    if [ -z "$VMSDOMAIN" ];then VMHOSTF=$VMHOST; else VMHOSTF="${VMHOST}.${VMSDOMAIN}"; fi

    VCENTER="$VM_VSPHERE_VCENTER"
    VCHOST="$VM_VSPHERE_ESX"
    VCDC="$VM_VSPHERE_DC"
    VCDS="$VM_VSPHERE_DS"
    VCNET="$VM_VSPHERE_NETNAME"

    F_LOG "$FUNCNAME" "VCENTER,VMHOST,VMCPU,VMRAM_MB,VMIP,VMNETMASK,VMGW,VMDNS1,VMDNS2,VMSDOMAIN,VCHOST,VCDC,VCDS,VCNET,VMGUESTOS,VMDISK,VMDISKTYPE,VMDISKSIZEGB,VMDISKOPTS,VMDISKDEV"
    F_LOG "$FUNCNAME" "$VCENTER,$VMHOST,$VMCPU,$VMRAM_MB,$VMIP,$VMNETMASK,$VMGW,$VMDNS1,$VMDNS2,$VMSDOMAIN,$VCHOST,$VCDC,$VCDS,$VCNET,$VMGUESTOS,$VMDISK,$VMDISKTYPE,$VMDISKSIZEGB,$VMDISKOPTS,$VMDISKDEV"

    if [ -z "$VMHOST" -o -z "$VMCPU" -o -z "$VMRAM_MB" -o -z "$VMIP" -o -z "$VMNETMASK" -o -z "$VMGW" -o -z "$VMDNS1" -o -z "$VMDNS2" -o -z "$VMSDOMAIN" -o -z "$VCHOST" -o -z "$VCDC" -o -z "$VCDS" -o -z "$VCNET" ];then
        F_DIAERR 3 "A required field is missing! ABORTED."
        F_LOG $FUNCNAME "ERROR: A required field is missing!"
        return 3
    else            
        ABORTED=0
    fi

    # sum up (makes uses of real tab spaces in dialog):
    F_DIALOG --no-collapse --colors --yesno "\n\ZbPORS is about to provision a VM with the following details:\ZB\n\n    vCenter:"$'\t\t\t'"\Zb$VCENTER\ZB\n    ESX:"$'\t\t\t'"$VCHOST\n\n    Hostname:"$'\t\t\t'"${VMHOST}.${VMSDOMAIN}\n    CPU:"$'\t\t\t'"$VMCPU\n    RAM:"$'\t\t\t'"$VMRAM_GB GB ($VMRAM_MB MB)\n    IP:"$'\t\t\t'"$VMIP/$VMNETMASK\n    Gateway:"$'\t\t\t'"$VMGW\n    DNS servers:"$'\t\t'"$VMDNS1, $VMDNS2\n    Datacenter (OS disk):"$'\t'"$VCDC\n    Datastorage (OS disk):"$'\t'"$VCDS\n    Network:"$'\t\t\t'"$VCNET\n\nDo you want to continue?\n" 30 80
    DEPLOYIT=$?

    [ $DEPLOYIT -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && return 4

    F_LOG $FUNCNAME "Will start provisionining with: $PBVCVMDEPLOY -e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','server_ram_mb':'$VMRAM_MB','server_cpu_count':'$VMCPU','server_ip':'$VMIP','server_netmask':'$VMNETMASK','server_gateway':'$VMGW','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','server_net_name':'$VCNET','vsphere_datastore':'$VCDS','vsphere_guestos':'$VMGUESTOS', 'server_scnd_disk':'$VMDISK','server_disk_type':'$VMDISKTYPE','server_disk_sizegb':'$VMDISKSIZEGB'}"

    F_ABIN $HOSTFILE $PBVCVMDEPLOY "Deploying $VMHOST to $VCHOST ..." "--limit ${VMHOST}.${VMSDOMAIN} -e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','server_ram_mb':'$VMRAM_MB','server_cpu_count':'$VMCPU','server_ip':'$VMIP','server_netmask':'$VMNETMASK','server_gateway':'$VMGW','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'$VCDC','server_net_name':'$VCNET','vsphere_datastore':'$VCDS','vsphere_guestos':'$VMGUESTOS','server_scnd_disk':'$VMDISK'}" 
#2>&1 >> $LOG
    DEPERR=$?
    F_LOG $FUNCNAME "deploying ended with code: $DEPERR"
    [ $DEPERR -ne 0 ] && return 99

    if [ $DEPERR -eq 0 ]&&[ "$VMDISK" -ne 0 ];then
        # add as many disk(s) as needed

        VMDISKCNT=0
        while [ $VMDISKCNT -ne $VMDISK ];do
            VMDISKCNT=$((VMDISKCNT +1))

            # dynamic variable names..
            VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
            VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
            VMDISKDEV="VMDISK${VMDISKCNT}DEV"

            VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
            VMDISKFS="VMDISK${VMDISKCNT}FS"
            VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
            VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
            VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"
            VMDISKDS="VMDISK${VMDISKCNT}DS"
            VMDISKDC="VMDISK${VMDISKCNT}DC"

            F_LOG $FUNCNAME "adding $VMDISKMNTP"
            F_LOG $FUNCNAME "additional disk config needed. disks left: $VMDISK"

            F_ABIN $HOSTFILE $PBVMNEWDISK "Adding a new disk to $VMHOST ..." "--limit ${VMHOST}.${VMSDOMAIN} -e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOST','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'${!VMDISKDC}','vsphere_datastore':'${!VMDISKDS}','server_scnd_disk':'$VMDISK','server_disk_type':'${!VMDISKTYPE}','server_scsi_controller':'$VMSCSI','server_disk_num':'$VMDISKCNT','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_dev':'${!VMDISKDEV}'}"
            ADDERR=$?
            [ $ADDERR -ne 0 ] && F_LOG $FUNCNAME "error $ADDERR occured" && return $ADDERR

            F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))" 
        done

        F_ABIN $HOSTFILE $PBVCVMPOWERON "Powering on $VMHOST ..." "-e {'vsphere_var':'$VCENTER','server_hostname':'$VMHOSTF','vsphere_esx_host':'$VCHOST','vsphere_datacenter':'${!VMDISKDC}'}"
        ERR=$?
        [ $ERR -ne 0 ] && F_LOG $FUNCNAME "error $ERR occured" && return $ERR

        if [ "$VMDISK" -ne 0 ];then
            # format all specified disks
            F_FORMATDISK $HWP
            DEPERR=$?
            [ $DEPERR -ne 0 ] && F_ERRLOG $DEPERR "issue occured while formatting disk(s)" $LOG && return $DEPERR
        else
            F_LOG $FUNCNAME "No additional disk config needed"
        fi

    else
        F_LOG $FUNCNAME "No additional disk config needed"
    fi

    F_LOG $FUNCNAME ended
}

## @fn F_VSPHERE_DISKADD()
## @brief TODO/WIP Adds a new disk to a vSphere managed VM
## @param 1 (exported) TMPHWPROFILE
## @param 2 (exported/optional) VMDISK
## @param 3 (exported) VMHOST
## @details Adds a new disk to a vSphere managed VM 
F_VSPHERE_DISKADD(){ 
    F_LOG $FUNCNAME started

    if [ -z "$VMDISK" ];then
        DIAOUT=$(F_DIALOG --form "\nSetup new disk(s) for $VMHOST" 20 100 10  \
                            "How many disks do you want to add?" 1 1 "1" 1 42 40 40  \
                            3>&1 1>&2 2>&3)
        [ $? -ne 0 ] && F_LOG $FUNCNAME "Disk count dialog ended with $?" && return 9
        [ "$DIAOUT" -ge 0 ] && VMDISK="$DIAOUT"
        F_LOG $FUNCNAME "User wants to add: $VMDISK disk(s)"
    fi

    VMDISKCNT=0
    while [ $VMDISKCNT -ne $VMDISK ];do
        VMDISKCNT=$((VMDISKCNT +1))

        # dynamic variable names..
        VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
        VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
        VMDISKDEV="VMDISK${VMDISKCNT}DEV"

        VCDS=$(F_VSPHERE_SELDS)

        DIAOUT=$(F_DIALOG --form "\nSetup your new disk ($VMDISKCNT of $VMDISK) for $VMHOST - Use arrow keys to switch between\n(no validation so be careful what you type..)" 20 100 10  \
                            "Physical device path within the VM" 1 1 "${!VMDISKDEV}" 1 42 40 40  \
                            "Disk size in GB" 2 1 "${!VMDISKSIZEGB}" 2 42 40 20 \
                            "Disk type (thin|eagerzeroedthick|thick)" 3 1 "${!VMDISKTYPE}" 3 42 40 16 \
                            3>&1 1>&2 2>&3)

        # normalize the output so it can be parsed correctly
        NDIAOUT=$(echo -e "$DIAOUT" | tr "\n" "|")

        UVMDISKDEV=$(echo "$NDIAOUT" | cut -d "|" -f 1 | tr -d " ")
        UVMDISKSIZEGB=$(echo "$NDIAOUT" | cut -d "|" -f 3 | tr -d " ")
        UVMDISKTYPE=$(echo "$NDIAOUT" | cut -d "|" -f 4 | tr -d " ")

        echo "VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}VCDS=${VCDS}" >> $TMPHWPROFILE

        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}VCDS=${VCDS}"

        F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))"
        F_PORSACTION "hw profile updated" "$FUNCNAME | added ${!VMDISKDEV} to $VMHOST"
    done
    VMERR=$?

    F_LOG $FUNCNAME "ended with $VMERR"
    return $VMERR
}

## @fn F_VSPHERE_DISKSETUP()
## @brief TODO/WIP Formats a partition in a VM incl. setting it up
## @param 1 (exported) TMPHWPROFILE
## @param 2 (exported/optional) VMDISK
## @param 3 (exported) VMHOST
## @param 4 (exported/optional) VMDISKDEV
## @param 5 (exported/optional) VCENTER
## @details Will prepare LVM, format and add to fstab a given partition
## Only vSphere ESX is supported.
F_VSPHERE_DISKSETUP(){
    F_LOG $FUNCNAME started

    if [ -z "$VMDISK" ];then
        DIAOUT=$(F_DIALOG --form "\nSetup new disk(s) for $VMHOST" 20 100 10  \
                            "How many disks do you want to setup?" 1 1 "1" 1 42 40 40  \
                            3>&1 1>&2 2>&3)
        [ $? -ne 0 ] && F_LOG $FUNCNAME "Disk count dialog ended with $?" && return 9
        [ "$DIAOUT" -ge 0 ] && VMDISK="$DIAOUT"
        F_LOG $FUNCNAME "User wants to add: $VMDISK disk(s)"
    fi

    VMDISKCNT=0
    while [ $VMDISKCNT -ne $VMDISK ];do
        VMDISKCNT=$((VMDISKCNT +1))

        # dynamic variable names..
        VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
        VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
        VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
        VMDISKDEV="VMDISK${VMDISKCNT}DEV"
        VMDISKFS="VMDISK${VMDISKCNT}FS"
        VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
        VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
        VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"

        DIAOUT=$(F_DIALOG --form "\nSetup your new disk ($VMDISKCNT of $VMDISK) for $VMHOST - Use arrow keys to switch between\n(no validation so be careful what you type..)" 20 100 10  \
                            "Physical device path within the VM" 1 1 "${!VMDISKDEV}" 1 42 40 40  \
                            "Filesystem to use (xfs,ext4,..)" 2 1 "${!VMDISKFS}" 2 42 40 20  \
                            "Disk size in GB" 3 1 "${!VMDISKSIZEGB}" 3 42 40 20 \
                            "Disk type (thin|eagerzeroedthick|thick)" 4 1 "${!VMDISKTYPE}" 4 42 40 16 \
                            "Mountpoint" 5 1 "${!VMDISKMNTP}" 5 42 40 40 \
                            "LVM VG name" 6 1 "${!VMDISKLVMVG}" 6 42 40 40 \
                            "LVM LV name" 7 1 "${!VMDISKLVMLV}" 7 42 40 40 \
                            "Mount options" 8 1 "${!VMDISKOPTS}" 8 42 40 100 \
                            3>&1 1>&2 2>&3)

        # normalize the output so it can be parsed correctly
        NDIAOUT=$(echo -e "$DIAOUT" | tr "\n" "|")

        UVMDISKDEV=$(echo "$NDIAOUT" | cut -d "|" -f 1 | tr -d " ")
        UVMDISKFS=$(echo "$NDIAOUT" | cut -d "|" -f 2 | tr -d " ")
        UVMDISKSIZEGB=$(echo "$NDIAOUT" | cut -d "|" -f 3 | tr -d " ")
        UVMDISKTYPE=$(echo "$NDIAOUT" | cut -d "|" -f 4 | tr -d " ")
        UVMDISKMNTP=$(echo "$NDIAOUT" | cut -d "|" -f 5 | tr -d " ")
        UVMDISKLVMVG=$(echo "$NDIAOUT" | cut -d "|" -f 6 | tr -d " ")
        UVMDISKLVMLV=$(echo "$NDIAOUT" | cut -d "|" -f 7 | tr -d " ")
        UVMDISKOPTS=$(echo "$NDIAOUT" | cut -d "|" -f 8 | tr -d " ")

        echo "VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}FS=${UVMDISKFS}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}OPTS=${UVMDISKOPTS}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}MNTP=${UVMDISKMNTP}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}LVMVG=${UVMDISKLVMVG}" >> $TMPHWPROFILE
        echo "VMDISK${VMDISKCNT}LVMLV=${UVMDISKLVMLV}" >> $TMPHWPROFILE

        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}OPTS=${UVMDISKOPTS}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}FS=${UVMDISKFS}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}MNTP=${UVMDISKMNTP}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}LVMVG=${UVMDISKLVMVG}"
        F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}LVMLV=${UVMDISKLVMLV}"

        F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))"
        F_PORSACTION "hw profile updated" "$FUNCNAME | added ${!VMDISKDEV} to $VMHOST"
    done
    VMERR=$?

    F_LOG $FUNCNAME "ended with $VMERR"
    return $VMERR
}

## @fn F_DEPLOYVM()
## @brief Deploy a new blank VM based on a template
## @exception ..
## @details ..
F_DEPLOYVM(){
    F_LOG $FUNCNAME started

    unset PROVIDER RECIPES

    RECIPES=$(find $DATADIR/vm_recipes -type d -maxdepth 1 -mindepth 1 | sort)

    while [ -z "$PROVIDER" ];do
        OPTIONS=($(for i in $RECIPES;do echo "${i/*\/}" "$i" off;done))
        PROVIDER=$(F_DIALOG --colors --radiolist \
            "\nPORS hardware profile folders have been found.\nMake your choice!\n\nIf you see 'IaC' here you can re-deploy or base on an already deployed VM.\nChoose 'Empty' if you want to start with an empty template:\n" \
            50 80 100 \
            "${OPTIONS[@]}" \
            "Empty" "Empty template " off \
            2>&1 >/dev/tty)
        WERR=$?
        [ $WERR -eq 0 ] && [ ! -z "$PROVIDER" ] && continue
        [ $WERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
   
    F_STARTVMDEP "$DATADIR/vm_recipes/$PROVIDER"

    F_LOG $FUNCNAME ended
}

## @fn F_CALCCIDR()
## @brief Calculates the CIDR of a given netmask
## @param1 required: the netmask
F_CALCCIDR(){
    F_LOG $FUNCNAME "started with $1"
    unset NETMASK cidr

    NETMASK="$1"

    cidr=0
    IFS=.
    for dec in $NETMASK; do
        case $dec in
            255) let cidr+=8;;
            254) let cidr+=7 ; break ;;
            252) let cidr+=6 ; break ;;
            248) let cidr+=5 ; break ;;
            240) let cidr+=4 ; break ;;
            224) let cidr+=3 ; break ;;
            192) let cidr+=2 ; break ;;
            128) let cidr+=1 ; break ;;
            0) ;;
            *) echo "Error: $dec is not recognised"; return 3 ;;
        esac
    done

    echo "$cidr"

    F_LOG $FUNCNAME "ended with the calculated CIDR: $cidr"
}

## @fn F_CALCNETMASK()
## @brief Calculates the NETMASK of a given CIDR
## @param1 required: the CIDR
F_CALCNETMASK(){
    F_LOG $FUNCNAME "started with $1"
    unset NETMASK CIDR nm
    CIDR="$1"

    nm=$[2**(32-${CIDR})] # 2^(32-x)

    if ! [ "$[$nm/256**0]" -gt "256" ]; then
        NETMASK=$(echo "255.255.255.$[256-($nm/256**0)]")
    elif ! [ "$[$nm/256**1]" -gt "256" ]; then
        NETMASK=$(echo "255.255.$[256-($nm/256**1)].0")
    elif ! [ "$[$nm/256**2]" -gt "256" ]; then
        NETMASK=$(echo "255.$[256-($nm/256**2)].0.0")
    elif ! [ "$[$nm/256**3]" -gt "256" ]; then
        NETMASK=$(echo "$[256-($nm/256**3)].0.0.0")
    fi

    echo "$NETMASK"

    F_LOG $FUNCNAME "ended with the calculated NETMASK: $NETMASK"
}

## @fn F_STARTVMDEP()
## @brief Deploy a new blank VM based on a template
## @exception ..
## @param1 required: target profile vendor (e.g. vmware,proxmox,googlecp,custom,..)
## @details The VM template used to clone.
## should be setup and prepared in a a way that ansible is able
## to connect and work with afterwards.
F_STARTVMDEP(){ 
    F_LOG $FUNCNAME started

    unset SROLE VENDOR VMHOST VMSDOMAIN VMCPU VMRAM_GB VMIP VMNETMASK VMGW VMDNS1 VMDNS2 VM_PROVIDER

    FINISHED=0
    ABORTED=0
    IACKEEP=0

    PROVIDERDIR="$1"
    SELDIR=${PROVIDERDIR/*\/}
    F_LOG $FUNCNAME "IaC SELDIR: $SELDIR"

    HWCONFIG="$PROVIDERDIR/pors_hardware-config_"
    if [[ $SELDIR =~ .*IaC ]];then
        IACDIR="${PROVIDERDIR}"
    else
        IACDIR="${PROVIDERDIR}/../${SELDIR}_IaC"
    fi
    F_LOG $FUNCNAME "IaC DIR: $IACDIR"
    IACDIRSHORT=${IACDIR/*\/}
    IACDIRTMP="$WORKDIR/IaC"

    [ ! -d "$PROVIDERDIR" ] && F_ERRLOG 3 "ERROR: cannot find the path specified: $PROVIDER" $LOG && return 3
    [ ! -d "$IACDIRTMP" ] && mkdir $IACDIRTMP && F_LOG $FUNCNAME "created $IACDIRTMP"
    [ ! -d "$IACDIR" ] && mkdir $IACDIR && F_LOG $FUNCNAME "created $IACDIR"
    
    for srole in $(cat ${HWCONFIG}*.config |egrep "^SERVER_ROLE=" | cut -d "=" -f 2);do
        SROLE="$SROLE $srole"
    done

    F_LOG $FUNCNAME "Detected hardware profiles: $SROLE"
    
    while [ $FINISHED -eq 0 ];do
        OPTIONS=($(for i in $SROLE;do echo "$i" "$i" off;done|sort))
        HWPROFILE=$(F_DIALOG --colors --radiolist \
            "\nAvailable PORS hardware profiles will be listed here.\nSelect (space-bar) any or choose 'Empty' \nif you want to start with an empty template:\n" \
            50 100 250 \
            "${OPTIONS[@]}" \
            "Common" "Load just the common config" off \
            2>&1 >/dev/tty)
        WERR=$?
        [ $WERR -eq 0 ] && [ ! -z "$HWPROFILE" ] && FINISHED=1 && continue
        [ $WERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && return 4
    done
    F_LOG $FUNCNAME "Choosen hardware profile: $HWPROFILE"
    FINISHED=0

    # load common settings (might get overwritten by role specific ones)
    source ${HWCONFIG}common.config

    if [ "$HWPROFILE" != "Common" ];then
        if [ ! -f ${HWCONFIG}${HWPROFILE}.config ];then
            F_ERRLOG 9 "Cannot find ${HWCONFIG}${HWPROFILE}.config!"
        else
            F_LOG $FUNCNAME "Loading $HWPROFILE template.."
            source "${HWCONFIG}${HWPROFILE}.config"
        fi
    else
        ${HWCONFIG}common.config
    fi

    # default SCSI controller if not set in the HW profile
    [ -z "$VMSCSI" ] && VMSCSI=0
    # default mount options when additional disk
    [ -z "$VMDISKOPTS" ] && VMDISKOPTS="defaults"

    VALIDROLESTXT=$(for r in $VALIDROLES;do echo "$r\n";done)

    while [ $FINISHED -eq 0 ];do
        DIAOUT=$(F_DIALOG --colors --extra-button --extra-label "Available Roles" --mixedform "\nSetup your new VM - Use arrow keys to switch between\n(no validation so be careful what you type..)\n\nAvailable server role names are PREDEFINED, press \ZbAvailable Roles\ZB to find all valid role names" 30 100 20  \
                "VM Provider" 1 1 "$VM_PROVIDER" 1 25 40 10 0\
                "----------------------------------------------------------------" 2 1 "-" 2 99 0 0 2\
                "Splunk Server Role" 3 1 "$SERVER_ROLE" 3 25 40 60 0\
                "----------------------------------------------------------------" 4 1 "-" 4 99 0 0 2\
                "Hostname" 5 1 "$VMHOST" 5 25 40 60 0 \
                "Server Domain Name" 6 1 "$VMSDOMAIN" 6 25 40 60 0\
                "CPU count" 7 1 "$VMCPU" 7 25 40 4 0\
                "RAM (GB)" 8 1 "$VMRAM_GB" 8 25 40 5 0\
                "Host IP (or 'dhcp')" 9 1 "$VMIP" 9 25 40 15 0\
                "CIDR (0-32) or Netmask" 10 1 "$VMNETMASK" 10 25 40 15 0\
                "Gateway IP" 11 1 "$VMGW" 11 25 40 15 0\
                "DNS #1" 12 1 "$VMDNS1" 12 25 40 15 0\
                "DNS #2" 13 1 "$VMDNS2" 13 25 40 15 0\
                3>&1 1>&2 2>&3)
        WERR=$?
        [ $WERR -eq 3 ] && F_DIALOG --colors --cr-wrap --msgbox "\n\ZbValid Splunk Server Role Names\ZB\n(only these listed roles are supported in PORS)\n\n$VALIDROLESTXT\nTo copy press SHIFT then use the mouse to select an entry then press: CTRL+SHIFT+C\n\nGo back and paste with: CTRL+SHIFT+P" 28 52 && continue
        [ $WERR -eq 1 ] && F_LOG "$FUNCNAME" "Aborted by user" && ABORTED=1 && FINISHED=1 && return 4

        F_LOG $FUNCNAME "diaout:\n$DIAOUT"

        # normalize the output so it can be parsed correctly
        NDIAOUT=$(echo -e "$DIAOUT" | tr "\n" "|")
        
        VM_PROVIDER=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")
        SERVER_ROLE=$(echo $NDIAOUT | cut -d "|" -f2 | tr -d " ")
        VMHOST=$(echo $NDIAOUT | cut -d "|" -f3 | tr -d " ")
        VMSDOMAIN=$(echo $NDIAOUT | cut -d "|" -f4 | tr -d " ")
        VMCPU=$(echo $NDIAOUT | cut -d "|" -f5 | tr -d " ")
        VMRAM_GB=$(echo $NDIAOUT | cut -d "|" -f6 | tr -d " ")
        VMIP=$(echo $NDIAOUT | cut -d "|" -f7 | tr -d " ")
        VMNETMASK=$(echo $NDIAOUT | cut -d "|" -f8 | tr -d " ")
        VMGW=$(echo $NDIAOUT | cut -d "|" -f9 | tr -d " ")
        VMDNS1=$(echo $NDIAOUT | cut -d "|" -f10 | tr -d " ")
        VMDNS2=$(echo $NDIAOUT | cut -d "|" -f11 | tr -d " ")

        # check if the splunk server role is valid
        ROLEOK=0
        for r in $VALIDROLES;do
            [ "$r" == "$SERVER_ROLE" ] && ROLEOK=1 && break
        done
        [ "$ROLEOK" -ne 1 ] && F_LOG $FUNCNAME "Role $SERVER_ROLE is not a supported role name" && F_DIALOG --colors --cr-wrap --msgbox "\n\ZbValid Splunk Server Role Names\ZB\n(only these listed roles are supported in PORS)\n\n$VALIDROLESTXT\nTo copy press SHIFT then use the mouse to select an entry then press: CTRL+SHIFT+C\n\nGo back and paste with: CTRL+SHIFT+P" 28 52 && continue

        # calculating the CIDR/NETMASK depending on the given value
        if [ ${#VMNETMASK} -le 2 ]; then
            VMNETCIDR="$VMNETMASK"
            VMNETMASK=$(F_CALCNETMASK "$VMNETMASK")
        else
            VMNETCIDR=$(F_CALCCIDR "$VMNETMASK")
        fi

        # prepare IaC config
        VMHOSTWDATE="${VMHOST}_$(date +%Y%m%d-%H%M%S)"
        TMPHWPROFILE=$IACDIRTMP/pors_hardware-config_${VMHOSTWDATE}.config
        echo -e "### The following is sourced from: ${HWCONFIG}common.config" > $TMPHWPROFILE
        cat ${HWCONFIG}common.config $TMPHWPROFILE | egrep -v '^#|^$' >> $TMPHWPROFILE
        [ "$HWPROFILE" != "Common" ] && echo -e "\n\n### The following is sourced from: ${HWCONFIG}${HWPROFILE}.config" >> $TMPHWPROFILE && cat ${HWCONFIG}${HWPROFILE}.config | egrep -v '^#|^$' >> $TMPHWPROFILE

        F_LOG "$FUNCNAME" "VMHOST,VMCPU,VMRAM_GB,VMRAM_MB,VMIP,VMNETMASK,VMGW,VMDNS1,VMDNS2,VMSDOMAIN,VM_PROVIDER,VMNETCIDR"
        F_LOG "$FUNCNAME" "$VMHOST,$VMCPU,$VMRAM_GB,$VMRAM_MB,$VMIP,$VMNETMASK,$VMGW,$VMDNS1,$VMDNS2,$VMSDOMAIN,$VM_PROVIDER,$VMNETCIDR"

        if [ -z "$VMHOST" -o -z "$VMCPU" -o -z "$VMRAM_GB" -o -z "$VMIP" -o -z "$VMNETMASK" -o -z "$VMGW" -o -z "$VMDNS1" -o -z "$VMDNS2" -o -z "$VMNETCIDR" ];then
            F_DIAERR 3 "A required field is missing.. try again"
            F_LOG $FUNCNAME "ERROR: A required field is missing!"
            VMERR=3
        else
            FINISHED=1
            VMERR=0
            echo -e "\n\n# The following are user defined values which might override the above defaults\n" >> $TMPHWPROFILE
            case $VM_PROVIDER in
                vsphere|vmware)
                    PROVOUT=$(F_DIALOG --colors --form "\nSetup your VM Provider $VM_PROVIDER for $VMHOST - Use arrow keys to switch between\n(no validation so be careful what you type..)\n\n\ZbNote:\ZB\nDatastore and Datacenter defaults can be overwritten per disk within the hardware profile by specifying VMDISKxDS and VMDISKxDC variables.\n" 30 100 20  \
                                "vCenter" 1 1 "$VM_VSPHERE_VCENTER" 1 22 60 70 \
                                "ESXi host" 2 1 "$VM_VSPHERE_ESX" 2 22 60 70 \
                                "Datastore (OS disk)" 3 1 "$VM_VSPHERE_DS" 3 22 60 70  \
                                "Datacenter (OS disk)" 4 1 "$VM_VSPHERE_DC" 4 22 60 70  \
                                "Network Name" 5 1 "$VM_VSPHERE_NETNAME" 5 22 60 70 \
                                3>&1 1>&2 2>&3)
                    VMERR=$?
                    # normalize the output so it can be parsed correctly
                    NDIAOUT=$(echo -e "$PROVOUT" | tr "\n" "|")
                    VM_VSPHERE_VCENTER=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")              
                    VM_VSPHERE_ESX=$(echo $NDIAOUT | cut -d "|" -f2 | tr -d " ")              
                    VM_VSPHERE_DS=$(echo $NDIAOUT | cut -d "|" -f3 | tr -d " ")              
                    VM_VSPHERE_DC=$(echo $NDIAOUT | cut -d "|" -f4 | tr -d " ")              
                    VM_VSPHERE_NETNAME=$(echo $NDIAOUT | cut -d "|" -f5 | tr -d " ")

                    echo "VM_VSPHERE_VCENTER=$VM_VSPHERE_VCENTER" >> $TMPHWPROFILE
                    echo "VM_VSPHERE_ESX=$VM_VSPHERE_ESX" >> $TMPHWPROFILE
                    echo "VM_VSPHERE_DS=$VM_VSPHERE_DS" >> $TMPHWPROFILE
                    echo "VM_VSPHERE_DC=$VM_VSPHERE_DC" >> $TMPHWPROFILE
                    echo "VM_VSPHERE_NETNAME=$VM_VSPHERE_NETNAME" >> $TMPHWPROFILE
                ;;
                proxmox|pve)
		    F_DIALOG --infobox "\nParsing Ansible variables ..." 5 40
                    # collect available Nodes
                    F_ABIN $HOSTFILE $PBPVEGETNODES "Collecting Proxmox Nodes.." >> $LOG
                    LASTERR=$?; [ $LASTERR -ne 0 ] && F_LOG $FUNCNAME "ended with $LASTERR" && return $LASTERR
                    VM_PVE_NODES=$(cat ${PORS_TEMPDIR}/pve_nodes.lst | tr '\n' ',' | sed 's/,$//g')

                    PROVOUT=$(F_DIALOG --mixedform "\nSetup your VM Provider $VM_PROVIDER for $VMHOST - Use arrow keys to switch between\n(no validation so be careful what you type..)" 30 100 20  \
                                "Proxmox PORS ID" 1 1 "$VM_PROXMOX_NODE" 1 30 27 28 0 \
                                "(available IDs: $VM_PVE_NODES)" 2 1 " " 2 50 0 0 2 \
                                3>&1 1>&2 2>&3)
                    VMERR=$?
                    # normalize the output so it can be parsed correctly
                    NDIAOUT=$(echo -e "$PROVOUT" | tr "\n" "|")
                    VM_PROXMOX_NODE=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")

                    echo "VM_PROXMOX_NODE=$VM_PROXMOX_NODE" >> $TMPHWPROFILE
                ;;
                googlecp|gcp)
                    # collect ansible config
		    F_DIALOG --infobox "\nParsing Ansible variables ..." 5 40
                    F_ABIN $HOSTFILE $PBGCPGETIDS "Parsing ansible config ..." >> $LOG
                    LASTERR=$?; [ $LASTERR -ne 0 ] && F_LOG $FUNCNAME "ended with $LASTERR" && return $LASTERR
                    VM_GOOGLECP_IDS=$(cat ${PORS_TEMPDIR}/googlecp.ids | tr '\n' ',' | sed 's/,$//g')
                    [ -z "$VM_GOOGLECP_MROLE" ] && VM_GOOGLECP_MROLE=$SERVER_ROLE

                    PROVOUT=$(F_DIALOG --mixedform "\nSetup your VM Provider $VM_PROVIDER for $VMHOST - Use arrow keys to switch between\n(no validation so be careful what you type..)" 30 100 20  \
                                "GCP project id:" 1 1 "$VM_GOOGLECP_ID" 1 30 27 28 0 \
                                "(available ids: $VM_GOOGLECP_IDS)" 2 1 " " 2 50 0 0 2 \
                                "Machine Type:" 3 1 "$VM_GOOGLECP_MTYPE" 3 30 27 28 0 \
                                "Metadata Role:" 4 1 "$VM_GOOGLECP_MROLE" 4 30 27 28 0 \
                                3>&1 1>&2 2>&3)
                    VMERR=$?
                    # normalize the output so it can be parsed correctly
                    NDIAOUT=$(echo -e "$PROVOUT" | tr "\n" "|")
                    VM_GOOGLECP_ID=$(echo $NDIAOUT | cut -d "|" -f1 | tr -d " ")
                    VM_GOOGLECP_MTYPE=$(echo $NDIAOUT | cut -d "|" -f2 | tr -d " ")
                    VM_GOOGLECP_MROLE=$(echo $NDIAOUT | cut -d "|" -f3 | tr -d " ")

                    echo "VM_GOOGLECP_ID=$VM_GOOGLECP_ID" >> $TMPHWPROFILE
                    echo "VM_GOOGLECP_MTYPE=$VM_GOOGLECP_MTYPE" >> $TMPHWPROFILE
                    echo "VM_GOOGLECP_MROLE=$VM_GOOGLECP_MROLE" >> $TMPHWPROFILE
                    echo 
                ;;
                *) F_DIAERR 4 "ERROR no valid VM provider selected! Check documentation." && VMERR=4 ;;
            esac
 
            [ $VMERR -ne 0 ] && F_LOG $FUNCNAME "ERROR: VMERR=$VMERR" && ABORTED=1 && FINISHED=1 && $(rm -vf $TMPHWPROFILE >> $LOG 2>&1 &) return 99
            F_LOG $FUNCNAME "diaout:\n$DIAOUT"
        fi

        # IaC stuff to identify inheritated roles later:
        egrep -q '^SERVER_ROLE=' $TMPHWPROFILE
        if [ $? -eq 0 ];then
            sed -i "s/^SERVER_ROLE=/SELECTED_SERVER_ROLE=/g" $TMPHWPROFILE
        fi
        echo "SERVER_ROLE=$VMHOSTWDATE" >> $TMPHWPROFILE
        echo "SELECTED_SERVER_ROLE=$SERVER_ROLE" >> $TMPHWPROFILE
        echo "HW_PROFILE_BASED_ON=$HWPROFILE" >> $TMPHWPROFILE

        echo "VMHOST=$VMHOST" >> $TMPHWPROFILE
        echo "VMCPU=$VMCPU" >> $TMPHWPROFILE
        echo "VMRAM_GB=$VMRAM_GB" >> $TMPHWPROFILE
        VMRAM_MB=$((VMRAM_GB * 1024))
        echo "VMRAM_MB=$VMRAM_MB" >> $TMPHWPROFILE
        echo "VMIP=$VMIP" >> $TMPHWPROFILE
        echo "VMNETMASK=$VMNETMASK" >> $TMPHWPROFILE
        echo "VMNETCIDR=$VMNETCIDR" >> $TMPHWPROFILE
        echo "VMGW=$VMGW" >> $TMPHWPROFILE
        echo "VMDNS1=$VMDNS1" >> $TMPHWPROFILE
        echo "VMDNS2=$VMDNS2" >> $TMPHWPROFILE
        echo "VMSDOMAIN=$VMSDOMAIN" >> $TMPHWPROFILE
        echo "VM_PROVIDER=$VM_PROVIDER" >> $TMPHWPROFILE
        echo "VMDISK=$VMDISK" >> $TMPHWPROFILE

        # add as many disk(s) as needed
        if [ $VMERR -eq 0 ]&&[ "$VMDISK" -ne 0 ];then
            VMDISKCNT=0
            while [ $VMDISKCNT -ne $VMDISK ];do
                VMDISKCNT=$((VMDISKCNT +1))

                # dynamic variable names..
                VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
                VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
                VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
                VMDISKDEV="VMDISK${VMDISKCNT}DEV"
                VMDISKDEVBOOT="VMDISK${VMDISKCNT}DEVBOOT"
                VMDISKDEVAUTODEL="VMDISK${VMDISKCNT}DEVAUTODEL"
                VMDISKEXTRANAME="VMDISK${VMDISKCNT}EXTRANAME"
                VMDISKFS="VMDISK${VMDISKCNT}FS"
                VMDISKFSMOVE="VMDISK${VMDISKCNT}FSMOVE"
                VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
                VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
                VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"

                case $VM_PROVIDER in
                    vsphere|vmware)
                        VMDISKDS="VMDISK${VMDISKCNT}DS"
                        VMDISKDC="VMDISK${VMDISKCNT}DC"
                        if [ -z "${!VMDISKDS}" ];then
                            VMDISKDS=$VM_VSPHERE_DS
                        else
                            VMDISKDS=${!VMDISKDS}
                        fi
                        if [ -z "${!VMDISKDC}" ];then
                            VMDISKDC=$VM_VSPHERE_DC
                        else
                            VMDISKDC=${!VMDISKDC}
                        fi
                        DISKEXTRAARGS="vSphere_Datacenter 13 1 ${VMDISKDC} 13 42 40 40 vSphere_Datastorage 14 1 ${VMDISKDS} 14 42 40 40"
                    ;;
                    *) unset DISKEXTRAARGS ;;
                esac

                DIAOUT=$(F_DIALOG --form "\nSetup your new disk ($VMDISKCNT of $VMDISK) for $VMHOST - Use arrow keys to switch between\n(no validation so be careful what you type..)" 25 100 18\
                            "Physical device path within the VM" 1 1 "${!VMDISKDEV}" 1 42 40 40  \
                            "Filesystem to use (xfs,ext4,..)" 2 1 "${!VMDISKFS}" 2 42 40 20  \
                            "Disk size in GB" 3 1 "${!VMDISKSIZEGB}" 3 42 40 20 \
                            "Disk type (thin|eagerzeroedthick|thick)" 4 1 "${!VMDISKTYPE}" 4 42 40 16 \
                            "Mountpoint" 5 1 "${!VMDISKMNTP}" 5 42 40 40 \
                            "LVM VG name" 6 1 "${!VMDISKLVMVG}" 6 42 40 40 \
                            "LVM LV name" 7 1 "${!VMDISKLVMLV}" 7 42 40 40 \
                            "Mount options" 8 1 "${!VMDISKOPTS}" 8 42 40 100 \
                            "Boot device" 9 1 "${!VMDISKDEVBOOT}" 9 42 40 40 \
                            "Auto delete" 10 1 "${!VMDISKDEVAUTODEL}" 10 42 40 40 \
                            "Disk extra name" 11 1 "${!VMDISKEXTRANAME}" 11 42 40 40 \
                            "Copy existing fs (true or false/empty)" 12 1 "${!VMDISKFSMOVE}" 12 42 40 40 \
                            $DISKEXTRAARGS \
                            3>&1 1>&2 2>&3)
                [ $? -ne 0 ] && F_LOG $FUNCNAME "ABORTED BY USER IN DISK DIALOG" && $(rm -vf $TMPHWPROFILE >> $LOG 2>&1 &) return 99

                # normalize the output so it can be parsed correctly
                NDIAOUT=$(echo -e "$DIAOUT" | tr "\n" "|")

                UVMDISKDEV=$(echo "$NDIAOUT" | cut -d "|" -f 1 | tr -d " ")
                UVMDISKFS=$(echo "$NDIAOUT" | cut -d "|" -f 2 | tr -d " ")
                UVMDISKSIZEGB=$(echo "$NDIAOUT" | cut -d "|" -f 3 | tr -d " ")
                UVMDISKTYPE=$(echo "$NDIAOUT" | cut -d "|" -f 4 | tr -d " ")
                UVMDISKMNTP=$(echo "$NDIAOUT" | cut -d "|" -f 5 | tr -d " ")
                UVMDISKLVMVG=$(echo "$NDIAOUT" | cut -d "|" -f 6 | tr -d " ")
                UVMDISKLVMLV=$(echo "$NDIAOUT" | cut -d "|" -f 7 | tr -d " ")
                UVMDISKOPTS=$(echo "$NDIAOUT" | cut -d "|" -f 8 | tr -d " ")
                UVMDISKDEVBOOT=$(echo "$NDIAOUT" | cut -d "|" -f 9 | tr -d " ")
                UVMDISKDEVAUTODEL=$(echo "$NDIAOUT" | cut -d "|" -f 10 | tr -d " ")
                UVMDISKEXTRANAME=$(echo "$NDIAOUT" | cut -d "|" -f 11 | tr -d " ")
                UVMDISKFSMOVE=$(echo "$NDIAOUT" | cut -d "|" -f 12 | tr -d " ")
                UVMDISKDC=$(echo "$NDIAOUT" | cut -d "|" -f 13 | tr -d " ")
                UVMDISKDS=$(echo "$NDIAOUT" | cut -d "|" -f 14 | tr -d " ")

                echo "VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}FS=${UVMDISKFS}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}FSMOVE=${UVMDISKFSMOVE}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}OPTS=\"${UVMDISKOPTS}\"" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}DEVBOOT=${UVMDISKDEVBOOT}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}DEVAUTODEL=${UVMDISKDEVAUTODEL}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}EXTRANAME=${UVMDISKEXTRANAME}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}MNTP=${UVMDISKMNTP}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}LVMVG=${UVMDISKLVMVG}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}LVMLV=${UVMDISKLVMLV}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}DC=${UVMDISKDC}" >> $TMPHWPROFILE
                echo "VMDISK${VMDISKCNT}DS=${UVMDISKDS}" >> $TMPHWPROFILE

                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}TYPE=${UVMDISKTYPE}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}SIZEGB=${UVMDISKSIZEGB}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}OPTS=${UVMDISKOPTS}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}DEV=${UVMDISKDEV}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}FS=${UVMDISKFS}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}FSMOVE=${UVMDISKFSMOVE}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}MNTP=${UVMDISKMNTP}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}LVMVG=${UVMDISKLVMVG}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}LVMLV=${UVMDISKLVMLV}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}DEVBOOT=${UVMDISKDEVBOOT}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}DEVAUTODEL=${UVMDISKDEVAUTODEL}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}EXTRANAME=${UVMDISKEXTRANAME}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}DS=${UVMDISKDS}"
                F_LOG $FUNCNAME "added VMDISK${VMDISKCNT}DC=${UVMDISKDC}"
 
                F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))"
            done
            VMERR=$?
        else
            F_LOG $FUNCNAME "No additional disk config needed or a prev error occured"
        fi
        # allow empty domain
        if [ -z "$VMSDOMAIN" ];then VMHOSTF=$VMHOST; else VMHOSTF="${VMHOST}.${VMSDOMAIN}"; fi

        if [ $VMERR -eq 0 ];then
            HSETOK=99
            while [ $HSETOK -ne 0 ];do
                grep "${VMHOSTF}" "$HOSTFILE" -q
                HSETOK=$?
                if [ $HSETOK -ne 0 ];then
                    F_DIALOG --yes-label "Edit hosts file" --no-label Cancel --yesno "\nThe server is not in $HOSTFILE.\nIt must be added now before we can continue.\n\n${VMHOSTF}\n(mouse to select, ctrl+shift+C to copy)\n\nmust be added to $HOSTFILE before you can continue.\nWhen you press OK $EDITBIN will be used to open it." 16 100
                    [ $? -eq 1 ] && F_LOG $FUNCNAME "Aborted by user" && HSETOK=4 && return 4
                    $EDITBIN $HOSTFILE
                fi
            done

            # check if the target exists and offer config only if
            if [ $VMIP == "dhcp" ];then
                F_PING $VMHOST
            else
                F_PING $VMIP
            fi
            if [ $? -ne 0 ];then
                case $VM_PROVIDER in
                    vsphere|vmware)
                        # switch to vCenter information and actions
                        #VCENTER=$(F_VSPHERE_VCGETINFO 2>&1 >/dev/tty)
                        F_VSPHERE_DEPLOY "$TMPHWPROFILE"
                        VMERR=$?
                        ;;
                    proxmox|pve)
                        F_PROXMOX_DEPLOY "$TMPHWPROFILE"
                        VMERR=$?
                        ;;
                    googlecp|gcp)
                        F_GOOGLECP_DEPLOY "$TMPHWPROFILE"
                        VMERR=$?
                        ;;
                    *) F_DIAERR 3 "ERROR no valid VM provider selected! Check documentation." && return 3 ;;
                esac
            else
                F_DIALOG --yes-label "(Re-)Configure" --no-label Cancel --yesno "\n\n\nThe server $VMHOST ($VMIP) is pingable!\nWe cannot deploy on this system but we can try to configure it.\nThat means all settings of the current selected hardware profile will be set/changed/removed to this system!\nOnly proceed if you understand the impacts including the risk of loosing data!\n\nDo you want to (re-)configure an existing VM?" 16 100
                [ $? -eq 1 ] && F_LOG $FUNCNAME "Aborted by user" && return 4
            fi
        else
            [ $? -eq 1 ] && IACKEEP=0 
        fi
    done

    # install base software not in template, ensure up2date system patches
    if [ $VMERR -eq 0 ];then
        F_BASEINSTALL "${VMHOSTF}" "$TMPHWPROFILE"
        BERR=$?
        [ $BERR -ne 0 ] && F_ERRLOG $BERR "Base install" && return $BERR
        F_SYSUPGRADE "${VMHOSTF}" autoreboot
        UERR=$?
        [ $UERR -ne 0 ] && F_ERRLOG $UERR "Upgrading System" && return $UERR
        if [ ! -z "$OS_SERVICE_USER" ];then
            F_ADDSERVICEUSER "${VMHOSTF}"
            F_DIAERR $? "Adding linux service account: $OS_SERVICE_USER"
        fi
        [ $? -eq 0 ] && F_MSG "\n\nCongratulations!\n\n$VMHOSTF\n\nhas been successfully deployed and is ready to use now." 15

        [ -f "$TMPHWPROFILE" ] && F_DIALOG --yesno "\nDo you want to save the hardware profile for\n\n    $VMHOST\n\nas an IaC (Infrastructure as Code) profile?\n\nWhen you select 'yes' you can re-deploy with the same settings when choosing the '$IACDIRSHORT' folder next time." 16 100
        if [ $? -eq 1 ];then
            IACKEEP=0 
        else
            IACKEEP=1
        fi
    else
        F_ERRLOG $VMERR "VM deploying"
    fi

    if [ "$IACKEEP" -ne 1 ];then
        F_LOG $FUNCNAME "deleting IaC file due to a previous error/abort"
        rm -vf $TMPHWPROFILE >> $LOG 2>&1
    else
        mv $TMPHWPROFILE $IACDIR/
        F_PORSACTION "new IaC profile in $IACDIRSHORT" "$FUNCNAME | new profile for $VMHOSTF stored in $IACDIRSHORT ($IACDIR)"
    fi
    
    F_LOG $FUNCNAME ended
    # close function when aborted
    [ $ABORTED -eq 1 ] && F_LOG $FUNCNAME "closing func due to abort state" && return 3
}

## @fn F_GOOGLECP_DEPLOY()
## @brief Deploys a VM in GCP
## @param1 required: source file containing the hw config
## @exception ..
## @details The actual doing is done here while it all starts in F_DEPLOYVM
F_GOOGLECP_DEPLOY(){ 
    F_LOG $FUNCNAME started
    unset TMPHWPROFILE

    TMPHWPROFILE="$1"
    [ ! -f $TMPHWPROFILE ] && F_ERRLOG 3 "Missing hw config: $TMPHWPROFILE" $LOG && return 3

    # make all user defined settings available here
    source $TMPHWPROFILE

    # allow empty domain
    if [ -z "$VMSDOMAIN" ];then VMHOSTF=$VMHOST; else VMHOSTF="${VMHOST}.${VMSDOMAIN}"; fi

    # sum up (makes uses of real tab spaces in dialog):
    F_DIALOG --no-collapse --colors --yesno "\nPORS is about to provision an instance with the following details:\n\n    GCP Project:"$'\t'"\Zb$VM_GOOGLECP_ID\ZB\n\n    Hostname:"$'\t\t'"${VMHOSTF}\n    CPU:"$'\t\t'"$VMCPU\n    RAM:"$'\t\t'"$VMRAM_GB GB ($VMRAM_MB MB)\n    IP:"$'\t\t'"$VMIP/$VMNETCIDR ($VMNETMASK)\n    Machine Type:"$'\t'"$VM_GOOGLECP_MTYPE\n    Metadata Role:"$'\t'"$VM_GOOGLECP_MROLE\n    DNS servers:"$'\t'"$VMDNS1, $VMDNS2\n\nDo you want to continue?\n" 30 80
    DEPLOYIT=$?

    [ $DEPLOYIT -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && $(rm -vf $TMPHWPROFILE >> $LOG 2>&1 &) return 4

    # GCP MUST have vmdisk1 as root device and that is handled different so should not be in DISK_LIST at all
    VMDISKCNT=1
    unset DISK_LIST

    while [ $VMDISKCNT -ne $VMDISK ];do
        VMDISKCNT=$((VMDISKCNT +1))

        # dynamic variable names..
        VMDISKDEV="VMDISK${VMDISKCNT}DEV"
        VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
        VMDISKFS="VMDISK${VMDISKCNT}FS"
        VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
        VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
        VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
        VMDISKEXTRANAME="VMDISK${VMDISKCNT}EXTRANAME"
        VMDISKDEVAUTODEL="VMDISK${VMDISKCNT}DEVAUTODEL"
        VMDISKDEVBOOT="VMDISK${VMDISKCNT}DEVBOOT"

        # gen disk name from mnt point
        VMDISKNAME=$(echo "${!VMDISKMNTP}" | sed 's/.*\///g')
        [ -z "$VMDISKNAME" ] && VMDISKNAME=$(echo "${!VMDISKFS}" | sed 's/.*\///g')
        [ "${!VMDISKFS}" == "swap" ] && VMDISKNAME=swap
        
        # build the list we parsing with ansible (jinja)
        if [ -z "${DISK_LIST['all']}" ];then
            DISK_LIST['all']+="[${VMHOST},${VMDISKNAME},${!VMDISKSIZEGB},${!VMDISKTYPE},${!VMDISKEXTRANAME},${!VMDISKDEVAUTODEL},${!VMDISKDEVBOOT}]"
        else
            DISK_LIST['all']+=",[${VMHOST},${VMDISKNAME},${!VMDISKSIZEGB},${!VMDISKTYPE},${!VMDISKEXTRANAME},${!VMDISKDEVAUTODEL},${!VMDISKDEVBOOT}]"
        fi
    done
    DISK_LIST_FLAT="${DISK_LIST['all']}"
    F_LOG $FUNCNAME "DISK_LIST:\n${DISK_LIST['all']}"

    F_ABIN $HOSTFILE $PBGCPDEPLOY "Deploying $VMHOST to $VM_PROVIDER ..." "--limit pors_server -e {'project_name':'$VM_GOOGLECP_ID','server_hostname':'${VMHOSTF}','server_shortname':'${VMHOST}','server_ram_mb':'$VMRAM_MB','server_cpu_cores_count':'$VMCPU','server_ip':'$VMIP','server_netmask':'$VMNETMASK','server_gateway':'$VMGW','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN','server_machine_type':'$VM_GOOGLECP_MTYPE','server_metadata_role':'$VM_GOOGLECP_MROLE','server_disk_type':'${VMDISK1TYPE}','server_disk_num':'$VMDISKCNT','server_disk_sizegb':'${VMDISK1SIZEGB}','server_disk_dev':'${VMDISK1DEV}','server_disk_name':'$VMDISK1NAME','server_disk_gcpdevname':'$VMDISK1EXTRANAME','server_disk_autodel':'$VMDISK1DEVAUTODEL','disks':[${DISK_LIST_FLAT}],'server_disk_bootdev':'${VMDISK1DEVBOOT}'}"
    DEPERR=$?
    F_LOG $FUNCNAME "deploying ended with code: $DEPERR"

    if [ $DEPERR -eq 0 ]&&[ "$VMDISK" -ne 0 ];then
        # format all specified disks
        F_FORMATDISK $TMPHWPROFILE
        DEPERR=$?
        [ $DEPERR -ne 0 ] && F_ERRLOG $DEPERR "issue occured while formatting disk(s)" $LOG && return $DEPERR
    else
        F_LOG $FUNCNAME "No additional disk config needed"
    fi
    [ $DEPERR -ne 0 ] && F_ERRLOG $DEPERR "Deploying $VMHOST to $VM_GOOGLECP_ID" && return 99
    F_LOG $FUNCNAME ended
}

## @fn F_PROXMOX_DEPLOY()
## @brief Deploys a system to Proxmox VE
## @param1 required: source file containing the hw config
## @exception ..
## @details The actual doing is done here while it all starts in F_DEPLOYVM
F_PROXMOX_DEPLOY(){ 
    F_LOG $FUNCNAME started
    unset TMPHWPROFILE

    TMPHWPROFILE="$1"
    [ ! -f $TMPHWPROFILE ] && F_ERRLOG 3 "Missing hw config: $TMPHWPROFILE" $LOG && return 3

    # make all user defined settings available here
    source $TMPHWPROFILE
    [ $? -ne 0 ] && F_ERRLOG 3 "issue sourcing the hw config $TMPHWPROFILE" $LOG && return 3

    # allow empty domain
    if [ -z "$VMSDOMAIN" ];then VMHOSTF=$VMHOST; else VMHOSTF="${VMHOST}.${VMSDOMAIN}"; fi

    # sum up (makes uses of real tab spaces in dialog):
    F_DIALOG --no-collapse --colors --yesno "\nPORS is about to provision a VM with the following details:\n\n    Proxmox ID:"$'\t'"\Zb$VM_PROXMOX_NODE\ZB\n\n    Hostname:"$'\t\t'"${VMHOSTF}\n    CPU:"$'\t\t'"$VMCPU\n    RAM:"$'\t\t'"$VMRAM_GB GB ($VMRAM_MB MB)\n    IP:"$'\t\t'"$VMIP/$VMNETCIDR ($VMNETMASK)\n    Gateway:"$'\t\t'"$VMGW\n    DNS servers:"$'\t'"$VMDNS1, $VMDNS2\n    Network:"$'\t\t'"$VCNET\n\nDo you want to continue?\n" 30 80
    DEPLOYIT=$?

    [ $DEPLOYIT -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && return 4

    # Proxmox MUST have vmdisk1 as root device and that is handled different so should not be in DISK_LIST at all
    VMDISKCNT=0
    unset DISK_LIST

    while [ $VMDISKCNT -ne $VMDISK ];do
        VMDISKCNT=$((VMDISKCNT +1))
        F_LOG $FUNCNAME ".. parsing $VMDISKCNT"

        # dynamic variable names..
        VMDISKDEV="VMDISK${VMDISKCNT}DEV"
        VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
        VMDISKFS="VMDISK${VMDISKCNT}FS"
        VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
        VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
        VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
        VMDISKEXTRANAME="VMDISK${VMDISKCNT}EXTRANAME"
        VMDISKDEVAUTODEL="VMDISK${VMDISKCNT}DEVAUTODEL"
        VMDISKDEVBOOT="VMDISK${VMDISKCNT}DEVBOOT"

        # gen disk name from mnt point
        VMDISKNAME=$(echo "${!VMDISKMNTP}" | sed 's/.*\///g')
        [ -z "$VMDISKNAME" ] && VMDISKNAME=$(echo "${!VMDISKFS}" | sed 's/.*\///g')
        [ "$VMDISKFS" == "swap" ] && VMDISKNAME=swap
        
        # build the list we parsing with ansible (jinja)
        if [ -z "${DISK_LIST['all']}" ];then
            DISK_LIST['all']+="[${VMDISKCNT},${!VMDISKSIZEGB},${!VMDISKTYPE}]"
        else
            DISK_LIST['all']+=",[${VMDISKCNT},${!VMDISKSIZEGB},${!VMDISKTYPE}]"
        fi
    done
    DISK_LIST_FLAT="${DISK_LIST['all']}"
    F_LOG $FUNCNAME "DISK_LIST:\n${DISK_LIST['all']}"

    # set static ip or dhcp based on the profile
    if [ "$VMIP" == "dhcp" ];then
        VMIPCONF="ip=$VMIP"
    else
        VMIPCONF="ip=${VMIP}/${VMNETCIDR},gw=${VMGW}"
    fi

    F_LOG $FUNCNAME "Will use this ip config: $VMIPCONF"

    F_ABIN $HOSTFILE $PBPVEDEPLOY "Deploying $VMHOST to $VM_PROVIDER..." "--limit pors_server -e {'px_var':'$VM_PROXMOX_NODE','server_hostname':['${VMHOSTF}'],'server_shortname':'${VMHOST}','server_ram_mb':'$VMRAM_MB','server_cpu_cores_count':'$VMCPU','server_ipconfig':'$VMIPCONF','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN','server_disk_type':'${VMDISK1TYPE}','server_disk_num':'$VMDISKCNT','server_disk_sizegb':'${VMDISK1SIZEGB}','server_disk_dev':'${VMDISK1DEV}','server_disk_name':'$VMDISK1NAME','server_disk_extraname':'$VMDISK1EXTRANAME','server_disk_autodel':'$VMDISK1DEVAUTODEL','disks':[${DISK_LIST_FLAT}],'server_disk_bootdev':'${VMDISK1DEVBOOT}'}"
    DEPERR=$?
    F_LOG $FUNCNAME "deploying ended with code: $DEPERR"

    if [ $DEPERR -eq 0 ]&&[ "$VMDISK" -ne 0 ];then
        # format all specified disks
        F_FORMATDISK $TMPHWPROFILE
        DEPERR=$?
        [ $DEPERR -ne 0 ] && F_ERRLOG $DEPERR "issue occured while formatting disk(s)" $LOG && return $DEPERR
    else
        F_LOG $FUNCNAME "No additional disk config needed"
    fi
    [ $DEPERR -ne 0 ] && F_ERRLOG $DEPERR "Deploying $VMHOST to $VM_PROXMOX_NODE" && return 99
    F_LOG $FUNCNAME ended
}

## @fn F_FORMATDISK()
## @brief Formats a new added disk of a system
## @param1 required: source file containing the hw config
## @param2 optional: skip count (e.g. 1 means start from the 2nd disk or 2 means start from the 3rd ..)
## @exception Fail: when disk is formatted already
## @details Will format all disks specified in the given PORS hardware config
## Formatting new disk(s) in an existing system must ensure that param1 is
## containing just the new disk(s) or that VMDISKFS=skip is set for any existing one.
## WARNING: this will auto-reboot the target system once completed
F_FORMATDISK(){
    F_LOG $FUNCNAME started
    unset VMDISKCNT

    TMPHWPROFILE="$1"
    VMDISKCNT="$2"

    # make all user defined settings available here
    source $TMPHWPROFILE

    # allow empty domain
    if [ -z "$VMSDOMAIN" ];then VMHOSTF=$VMHOST; else VMHOSTF="${VMHOST}.${VMSDOMAIN}"; fi

    [ -z "$VMDISKCNT" ] && VMDISKCNT=0
    while [ $VMDISKCNT -ne $VMDISK ];do
        VMDISKCNT=$((VMDISKCNT +1))
        F_LOG $FUNCNAME ".. parsing disk $VMDISKCNT"
            
        # dynamic variable names..
        VMDISKDEV="VMDISK${VMDISKCNT}DEV"
        VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
        VMDISKFS="VMDISK${VMDISKCNT}FS"
        VMDISKFSMOVE="VMDISK${VMDISKCNT}FSMOVE"
        VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
        VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
        VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"
        VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
        VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
 
        # first check if we should skip this disk
        [ "${!VMDISKFS}" == "skip" ] && F_LOG "$FUNCNAME" "Will NOT format ${!VMDISKDEV} because 'skip' parameter has been set (VMDISKFS=${!VMDISKFS})" && continue

        # special default mount option for SWAP
        [ "${!VMDISKFS}" == "swap" ] && VMDISKOPTS="sw"

        if [ -z "${!VMDISKLVMLV}" ]||[ "${!VMDISKLVMLV}" == "VMDISK${VMDISKCNT}LVMLV" ];then
            F_LOG "$FUNCNAME" "Will configure without LVM.. (reason: >$VMDISKLVMLV<)"
            F_ABIN $HOSTFILE $PBSYSDISKFORMAT "Formatting \Zb${!VMDISKDEV}\ZB on $VMHOST ..." "--limit ${VMHOSTF} -e {'server_hostname':'$VMHOSTF','server_disk_type':'${!VMDISKTYPE}','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_mountopts':'${!VMDISKOPTS}','server_disk_dev':'${!VMDISKDEV}','server_disk_fs':'${!VMDISKFS}','server_disk_mountpoint':'${!VMDISKMNTP}'}"
        else
            F_LOG "$FUNCNAME" "Will configure with LVM.."
            F_ABIN $HOSTFILE $PBSYSDISKFORMAT "Formatting \Zb${!VMDISKDEV}\ZB on $VMHOST ..." "--limit ${VMHOSTF} -e {'server_hostname':'$VMHOSTF','server_disk_type':'${!VMDISKTYPE}','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_mountopts':'${!VMDISKOPTS}','server_disk_dev':'${!VMDISKDEV}','server_disk_fs':'${!VMDISKFS}','server_disk_mountpoint':'${!VMDISKMNTP}','server_lvm_vg':'${!VMDISKLVMVG}','server_lvm_lv':'${!VMDISKLVMLV}','format_disk_lvm':'true'}"
        fi
        ERR=$?
        F_PORSACTION "nogit" "$FUNCNAME | format ${!VMDISKDEV} on $VMHOST (exit code: $ERR)"
        [ $ERR -ne 0 ] && F_LOG $FUNCNAME "error $ERR occured" && return $ERR

        # FS move needed?
        if [ "${!VMDISKFSMOVE}" == "true" ] ;then
            F_LOG $FUNCNAME "... moving filesystem needed!"
            if [ -z "${!VMDISKLVMLV}" ]||[ "${!VMDISKLVMLV}" == "VMDISK${VMDISKCNT}LVMLV" ];then
                F_LOG "$FUNCNAME" "moving FS (no LVM, VMDISKLVMLV=$VMDISKLVMLV).."
                F_ABIN $HOSTFILE $PBSYSDISKFORMAT "Moving FS for \Zb${!VMDISKMNTP}\ZB on $VMHOST ..." "--limit ${VMHOSTF} -e {'server_hostname':'$VMHOSTF','server_tmp_mnt':'/mnt${!VMDISKMNTP}','server_disk_dev':'${!VMDISKDEV}','server_disk_mountpoint':'${!VMDISKMNTP}','server_fs_move':'true','format_disk':'false','server_disk_fs':'${!VMDISKFS}'}"
            else
                F_LOG "$FUNCNAME" "moving FS (LVM).."
                F_ABIN $HOSTFILE $PBSYSDISKFORMAT "Moving FS for \Zb${!VMDISKMNTP}\ZB on $VMHOST ..." "--limit ${VMHOSTF} -e {'server_hostname':'$VMHOSTF','server_tmp_mnt':'/mnt${!VMDISKMNTP}','server_disk_dev':'${!VMDISKDEV}','server_disk_mountpoint':'${!VMDISKMNTP}','server_fs_move':'true','format_disk':'false','server_disk_fs':'${!VMDISKFS}','server_lvm_vg':'${!VMDISKLVMVG}','server_lvm_lv':'${!VMDISKLVMLV}','format_disk_lvm':'true'}"
            fi
            ERR=$?
            [ $ERR -ne 0 ] && F_LOG $FUNCNAME "error $ERR occured" && return $ERR
        fi
    done
    F_SYSREBOOT "$VMHOSTF" autoreboot
    F_LOG $FUNCNAME ended
}

## @fn F_ADDDISK()
## @brief Add a new disk to a system
## @param1 required: source file containing the hw config
## @param2 optional: skip count (e.g. 1 means start from the 2nd disk or 2 means start from the 3rd ..)
## @exception TODO
## @details Will add all disks specified in the given PORS hardware config
## Adding a new single disk to an existing system must ensure that param1 is
## containing just the new disk
F_ADDDISK(){
    F_LOG $FUNCNAME started

    unset VMDISKCNT

    VMDISKCNT="$2"

    TMPHWPROFILE="$1"
    [ ! -f $TMPHWPROFILE ] && F_ERRLOG 3 "Missing hw config: $TMPHWPROFILE" $LOG && return 3

    # make all user defined settings available here
    source $TMPHWPROFILE

    # allow empty domain
    if [ -z "$VMSDOMAIN" ];then VMHOSTF=$VMHOST; else VMHOSTF="${VMHOST}.${VMSDOMAIN}"; fi

    # set specific variables based on which provider is used
    case $VM_PROVIDER in
        googlecp|gcp)
            F_LOG $FUNCNAME "ERROR: >$VM_PROVIDER< does not support adding disks to an existing instance (yet?)" ; return 3  ;;
        proxmox|pve)
            PROVIDERVARS="'px_var':'$VM_PROXMOX_NODE'"
            PROVPB=$PBPVENEWDISK
        ;;
        vsphere|vmware)
            PROVIDERVARS="'vsphere_esx_host':'$VM_VSPHERE_ESX','vsphere_datacenter':'$VM_VSPHERE_DC','vsphere_datastore':'$VM_VSPHERE_DS','server_scsi_controller':'$VMSCSI'"
            PROVPB=$PBVMNEWDISK
        ;;
        *) F_LOG $FUNCNAME "ERROR: >$VM_PROVIDER< is not supported!" ; return 3  ;;
    esac

    FPROVIDERVARS=$(echo "\ZbProvider\ZB\n----------\n$PROVIDERVARS" | sed 's/,/\\n/g' |tr -d "'")

    [ -z "$VMDISKCNT" ] && VMDISKCNT=0
    while [ $VMDISKCNT -ne $VMDISK ];do
            VMDISKCNT=$((VMDISKCNT +1))

            # dynamic variable names..
            VMDISKTYPE="VMDISK${VMDISKCNT}TYPE"
            VMDISKSIZEGB="VMDISK${VMDISKCNT}SIZEGB"
            VMDISKDEV="VMDISK${VMDISKCNT}DEV"
            VMDISKDEVBOOT="VMDISK${VMDISKCNT}DEVBOOT"
            VMDISKOPTS="VMDISK${VMDISKCNT}OPTS"
            VMDISKFS="VMDISK${VMDISKCNT}FS"
            VMDISKMNTP="VMDISK${VMDISKCNT}MNTP"
            VMDISKLVMVG="VMDISK${VMDISKCNT}LVMVG"
            VMDISKLVMLV="VMDISK${VMDISKCNT}LVMLV"

            # gen disk name from mnt point
            VMDISKNAME=$(echo "${!VMDISKMNTP}" | sed 's/.*\///g')
            [ -z "$VMDISKNAME" ] && VMDISKNAME=$(echo "${!VMDISKDEV}" | sed 's/.*\///g')

            F_LOG $FUNCNAME "VMDISKNAME: $VMDISKNAME"
            F_LOG $FUNCNAME "VMDISKLVMLV: $VMDISKLVMLV"
            F_LOG $FUNCNAME "PROVIDERVARS: $PROVIDERVARS"

            # sum up (makes uses of real tab spaces in dialog):
            if [ -z "$VMDISKLVMLV" ]||[ "$VMDISKLVMLV" == "VMDISK${VMDISKCNT}LVMLV" ];then
                F_DIALOG --no-collapse --colors --yesno "\nPORS is about to add a new disk to a system with the following details:\n\n    Target:"$'\t\t'"\Zb$VMHOSTF\ZB\n    Disk path:"$'\t'"${!VMDISKDEV}\n    Size (GB):"$'\t'"${!VMDISKSIZEGB}\n    Filesystem:"$'\t'"${!VMDISKFS}\n    Type:"$'\t\t'"${!VMDISKTYPE}\n    Mountpoint:"$'\t'"${!VMDISKMNTP}\n    Mount options:"$'\t'"${!VMDISKOPTS}\n    LVM: "$'\t'"NO\n\nDo you want to continue?\n" 50 80
            else
                F_DIALOG --no-collapse --colors --yesno "\nPORS is about to add a new disk to a system with the following details:\n\n    Target:"$'\t\t'"\Zb$VMHOSTF\ZB\n    Disk path:"$'\t'"${!VMDISKDEV}\n    Size (GB):"$'\t'"${!VMDISKSIZEGB}\n    Filesystem:"$'\t'"${!VMDISKFS}\n    Type:"$'\t\t'"${!VMDISKTYPE}\n    Mountpoint:"$'\t'"${!VMDISKMNTP}\n    Mount options:"$'\t'"${!VMDISKOPTS}\n    LVM VG name: "$'\t'"${!VMDISKLVMVG}\n    LVM LV name: "$'\t'"${!VMDISKLVMLV}\n\nDo you want to continue?\n" 50 80
            fi
            DEPLOYIT=$?
            [ $DEPLOYIT -ne 0 ] && F_LOG $FUNCNAME "Aborted by user" && return 99

            F_LOG $FUNCNAME "additional disk config needed. disks left: $VMDISK"

            F_ABIN $HOSTFILE $PROVPB "Adding a new disk to $VMHOST ..." "--limit ${VMHOSTF} -e {$PROVIDERVARS,'server_hostname':'$VMHOSTF','server_shortname':'${VMHOST}','server_scnd_disk':'$VMDISK','server_disk_type':'${!VMDISKTYPE}','server_disk_num':'$VMDISKCNT','server_disk_sizegb':'${!VMDISKSIZEGB}','server_disk_dev':'${!VMDISKDEV}','server_disk_name':'${VMDISKNAME}','server_disk_bootdev':'${!VMDISKDEVBOOT}'}"
            ADDERR=$?
            [ $ADDERR -ne 0 ] && F_LOG $FUNCNAME "error $ADDERR occured" && return $ADDERR

            F_LOG $FUNCNAME "additional disk config needed. disks left: $(($VMDISK - $VMDISKCNT))"
            F_PORSACTION "nogit" "$FUNCNAME | added ${!VMDISKDEV} to $VMHOSTF"
    done
 
    F_LOG $FUNCNAME ended
}

## @fn F_BASEINSTALL()
## @brief Doing/Ensure the base is as we want it
## param1 optional: specific hostname (as in hosts file)
## param2 optional: (but requires param1 set!) the hardware profile to be sourced
## @details This prepares or installs basic stuff we need on every system 
## as we are using a barebone template to deploy
F_BASEINSTALL(){
    F_LOG $FUNCNAME started
    GHOST="$1"
    unset AUTOMODE PARENTPID TMPHWPROFILE VMHOSTF
    export PARENTPID=$BASHPID
    AUTOMODE="$1"
    TMPHWPROFILE="$2"

    if [ -z "$AUTOMODE" ];then
        SELHOSTS="$(F_SELHOST)"
        [ "$SELHOSTS" == ABORTED ] && return 4
            CREDS=$(F_GETAPICREDS)
            SPLUSR="${CREDS/:*}"
            SPLPW="${CREDS/*:}"
    else
        SELHOSTS="$AUTOMODE"
        [ ! -f $TMPHWPROFILE ] && F_LOG $FUNCNAME "No hw config given or wrong path? $TMPHWPROFILE"
        # make all user defined settings available here
        [ -f $TMPHWPROFILE ] && source $TMPHWPROFILE
    fi
    # allow empty domain
    if [ -z "$VMSDOMAIN" ];then VMHOSTF=$VMHOST; else VMHOSTF="${VMHOST}.${VMSDOMAIN}"; fi

    F_LOG $FUNCNAME "selected hosts for upgrade: $SELHOSTS"

    [ -z "$SELHOSTS" ] && F_DIAERR 9 "missing param for $FUNCNAME" && break 99

    unset ABINARGS
    if [ -f "$TMPHWPROFILE" ];then
        ABINARGS="-e {'server_hostname':'$VMHOSTF','server_shortname':'$VMHOST','server_dns1':'$VMDNS1','server_dns2':'$VMDNS2','server_domain':'$VMSDOMAIN'}"
    fi

    # check for playbook hook
    HOOKYML=$(F_GETANSIBLEVAR hook_system_playbook)

    # install
    for uhost in $(echo "$SELHOSTS" |tr " " "\n" | cut -d ":" -f 1);do
        # check ssh first
        F_CHECKSSH "$uhost"
        if [ -z "$HOOKYML" ]|| [ "$HOOKYML" == "False" ];then
            F_LOG $FUNCNAME "No system hook defined"
        else
            F_LOG $FUNCNAME "System hook defined! Will run the following playbook(s): $HOOKYML"
            for pb in $HOOKYML;do
                F_ABIN $HOSTFILE $DATADIR/custom/playbooks/$pb "Running SYSTEM PLAYBOOK HOOK ($pb) on $uhost ..." "--limit $uhost $ABINARGS"
                LERR=$?
                [ $LERR -ne 0 ] && F_DIAERR $LERR "SYSTEM PLAYBOOK HOOK ($pb) on $uhost\n" && return 3
            done
        fi
        F_ABIN $HOSTFILE $PBBASEINSTALL "Installing base on $uhost ..." "--limit $uhost $ABINARGS"
    done
    LERR=$?
    [ "$LERR" -ne 0 ] && F_DIAERR $LERR "Base install on:\n\n$SELHOSTS\n\n"
    F_PORSACTION "nogit" "$FUNCNAME | finished base install on $SELHOSTS"
    F_LOG $FUNCNAME ended
    return $LERR
}

## @fn F_SYSUPGRADE()
## @brief system upgrade tasks
## @param1 optional: set the host for the upgrade function
## @param2 optional: (requires param1!) when set to "autoreboot" it will not ask for reboot after upgrading has finished
## @details Upgrade a system by the distribution package manager
F_SYSUPGRADE(){ 
    F_LOG $FUNCNAME started
    GHOST="$1"
    unset AUTOMODE PARENTPID
    export PARENTPID=$BASHPID
    AUTOMODE="$1"
    AUTOREBOOT=$2

    if [ -z "$AUTOMODE" ];then
        SELHOSTS="$(F_SELHOST)"
        [ "$SELHOSTS" == ABORTED ] && return 4
    else
        SELHOSTS="$AUTOMODE"
    fi

    F_LOG $FUNCNAME "selected hosts for upgrade: $SELHOSTS"

    [ -z "$SELHOSTS" ] && F_DIAERR 9 "missing param for $FUNCNAME" && return 3

    for uhost in $(echo "$SELHOSTS" |tr " " "\n" | cut -d ":" -f 1);do
        # check ssh first
        F_CHECKSSH "$uhost"
        F_ABIN $HOSTFILE $PBSYSUPGRADE "Upgrading $uhost ..." "--limit $uhost"
        FORERR=$?
        [ $FORERR -ne 0 ] && break
    done
    if [ $FORERR -eq 0 ];then
        if [ $? -eq 0 ];then
            F_LOG $FUNCNAME "System packages or upgrade(s) have been installed for:\n$SELHOSTS\n\nA REBOOT IS REQUIRED!\nReboot handler will be initiated ..."
            F_SYSREBOOT "$SELHOSTS" $AUTOREBOOT
            LASTERR=$?
        else
            F_LOG $FUNCNAME "Rebooting handling skipped by user"
        fi
    else
        LASTERR=$FORERR
    fi
    F_PORSACTION "nogit" "$FUNCNAME | System packages or upgrade(s) have been installed for: $SELHOSTS"
    F_LOG $FUNCNAME "ended with $LASTERR"
    return $LASTERR
}

## @fn F_SYSREBOOT()
## @brief reboots a remote system
## @param 1 required: the host or a list of hosts (space separated) to be rebooted
## @param 2 optional: ask for a reboot (empty) or not (when set to: "autoreboot")
## @details tbd
F_SYSREBOOT(){ 
    REBHOSTS="$1"
    ASKUSER=$2
    F_LOG $FUNCNAME "started with $REBHOSTS $ASKUSER"
    [ -z "$REBHOSTS" ] && F_LOG $FUNCNAME "ERROR: no host given" && return 3

    for host in $REBHOSTS;do
        honly=${host/:*}
        if [ $ASKUSER == "autoreboot" ];then
            F_ABIN $HOSTFILE $PBSYSREBOOT "Rebooting $honly ..." "-e {'target':'$honly'}" || break
            F_PORSACTION "nogit" "$FUNCNAME | rebooted $honly"
        else
            F_DIALOG --scrollbar --yesno "\n\nThe server\n\n$host\n\nrequires a reboot!\n\nDo you want to initiate a reboot NOW?" 20 50
            if [ $? -eq 0 ];then
                F_ABIN $HOSTFILE $PBSYSREBOOT "Rebooting $honly ..." "-e {'target':'$honly'}" || break
                F_PORSACTION "nogit" "$FUNCNAME | rebooted $honly"
            else
                F_LOG "$FUNCNAME" "Skipped rebooting $honly"
            fi
        fi
    done
    FORERR=$?
    F_LOG $FUNCNAME "ended with $FORERR"
    return $FORERR
}

## @fn F_CHECKSSH()
## @brief system upgrade tasks
## @param 1 required: the host from the inventory to be checked
## @param 2 optional: the full path to another hostfile
## @details tbd
F_CHECKSSH(){ 
    F_LOG $FUNCNAME started

    CHOST="$1"
    DHOSTF="$2"

    [ -z "$CHOST" ] && F_DIAERR 9 "missing arg in $FUNCNAME" && break 99
    [ -z "$DHOSTF" ] && DHOSTF="$HOSTFILE"

    F_ABIN $HOSTFILE $PBSSHCHK "checking $CHOST ..." "--limit $CHOST"
    LASTERR=$?; [ $LASTERR -ne 0 ] && F_LOG $FUNCNAME "ended with $LASTERR" && return $LASTERR

    F_LOG $FUNCNAME ended
}

## @fn F_GETANSIBLEVAR()
## @brief request the value of an ansible variable
## @param 1 required: the variable name you want to query
## @param 2 optional: the full path to another hostfile
## @details tbd
F_GETANSIBLEVAR(){
    F_LOG $FUNCNAME "started with $1"
    REQVAR="$1"
    VARTMP="/tmp/pors/ansible_${REQVAR}.var"

    F_LOG $FUNCNAME "REQVAR=$REQVAR, VARTMP=$VARTMP"
    [ -z "$REQVAR" ] && F_LOG $FUNCNAME "ERROR: missing required arg REQVAR" && return 3
    F_ABIN $HOSTFILE $PBLOCGETVAR "requesting ansible variable ($REQVAR)" "-e {'varname':'$REQVAR'}" 2>> $LOG 1>> /dev/null
    ERR=$?

    F_LOG $FUNCNAME "ended with $ERR"
    [ "$ERR" -eq 0 ] && echo "$(cat $VARTMP)"
    return $ERR
}

## @fn F_PORSACTION()
## @brief Do internal PORS actions when triggered
## @param 1 required: title or "nogit" to skip git commit
## @param 2 required: msg
## @details Examples: writing action log, committing pors_data changes
F_PORSACTION(){
    F_LOG $FUNCNAME "started with $1, $2"
    ATITLE="$1"
    AMSG=$(echo "$2" | tr "\n" " " | sed 's/\\n/ /g')

    [ -z "$ATITLE" ] && F_LOG $FUNCNAME "ERROR: missing action title!" && return 3
    [ -z "$AMSG" ] && F_LOG $FUNCNAME "ERROR: missing action message!" && return 3

    [ $RUNMODE != "batch" ] && F_WAITBOX "... saving changes"

    # write action log
    PREFIX="$(date '+%F_%T') | $TARGETENV | $CALLUSR"
    echo -e "$PREFIX | $ATITLE | $AMSG" >> $ALOG 

    # commit any changes in pors_data
    [ "$ATITLE" != "nogit" ] && F_DATACOMMIT "$ATITLE" "$AMSG"

    F_LOG $FUNCNAME "finished"
}

## @fn F_DATAGIT()
## @brief Check pors_data directory -> git connection
## @details tbd
F_DATAGIT(){
    F_LOG $FUNCNAME "started with $1"

    F_LOG $FUNCNAME "Checking git init"
    [ ! -d "$DATADIR/.git" ] && cd $DATADIR && git init 2>&1 >> $LOG && git branch -m main 2>&1 >> $LOG && F_LOG $FUNCNAME "$DATADIR is a git repo now!"
    [ ! -f "$DATADIR/.gitignore" ] && cat >$DATADIR/.gitignore << _EOIGN
*.pyc
F_*
ae_deploy_apps.yml
*.retry
_EOIGN
    cd $ADIR
    F_LOG $FUNCNAME "finished"
}

## @fn F_DATACHANGED()
## @brief Check if pors_data directory contain changes
## @return 0: no changes
## @return 1: changes exists
## @details tbd
F_DATACHANGED(){
    F_LOG $FUNCNAME "started with $1"
    cd $DATADIR
    git add -A . 2>&1 >> $LOG
    F_LOG $FUNCNAME "The following is the output of git diff:"
    git diff --cached --exit-code 2>&1 >> $LOG
    GERR=$?
    cd $ADIR
    F_LOG $FUNCNAME "finished"
    return $GERR
}

## @fn F_DATACOMMIT()
## @brief Commit changes within pors_data directory
## @param 1 required: a commit title (will be shorten to 50 chars)
## @param 2 required: a commit msg (will be split every 72 chars)
## @return exitcode for commit action (should be 0)
## @details When triggered by a function in PORS the current changes get committed
## and optionally pushed to a remote git repo.
F_DATACOMMIT(){
    F_LOG $FUNCNAME "started with $1, $2"
    unset CMSG CUSER CTITLE CNEED NEXT GARGS

    # shorten the title to 52 chars
    CTITLERAW="$1"
    CTITLE="${CTITLERAW:0:51}"
    CMSG=$(echo "$2" | tr "\n" " ")
    #declare -a GARGS=()

    [ -z "$CTITLE" ] && F_LOG $FUNCNAME "ERROR: missing commit title!" && return 3
    [ -z "$CMSG" ] && F_LOG $FUNCNAME "ERROR: missing commit message!" && return 3


    F_LOG $FUNCNAME "CTITLE: $CTITLE | CMSG: $CMSG"
    F_DATACHANGED
    CNEED=$?
    if [ $CNEED -eq 1 ];then
        # split long commit messages first
        NSPLIT=${#CMSG}
        if [ $NSPLIT -gt 72 ];then
            F_LOG $FUNCNAME "CMSG needs exceeds 72 chars so will be split now.."
            GARGS="-m 'the following changes have been applied by $CALLUSR:' -m '${CMSG:0:71}'"
            NEXT=${CMSG:72:2000}
            while [ "${#NEXT}" -gt 0 ]; do
                GARGS="$GARGS -m '${NEXT:0:71}'"
                NEXT=${NEXT:72:2000}
            done
        else
            F_LOG $FUNCNAME "CMSG shorter then 72 chars - using it as it is"
            GARGS="-m 'the following changes have been applied by $CALLUSR:' -m '$CMSG'"
        fi
        cd $DATADIR
        F_LOG $FUNCNAME "committing the following changes:"
        git status --porcelain 2>&1 >> $LOG
        F_LOG $FUNCNAME "Will use this git command:\ngit commit -m \"$CUSER: $CTITLE\" $GARGS\n"
        eval git commit -m "'$TARGETENV: $CTITLE'" ${GARGS} >> $LOG 2>&1
        GAERR=$?
        if [ $GAERR -ne 0 ];then
            F_LOG $FUNCNAME "Error >$GAERR< occured while committing changes!"
        else
            F_LOG $FUNCNAME "The following commit has been created:"
            git log -1 >> $LOG 2>&1 
        fi
    else
        F_LOG $FUNCNAME "no changes so no commit needed"
        GAERR=0
    fi
    cd $ADIR

    F_LOG $FUNCNAME "finished"
    return $GAERR
}

## @fn F_DATAPUSH()
## @brief Push committed pors_data changes (if enabled)
## @return Exit code for pushing the changes
## @details tbd
F_DATAPUSH(){
    F_LOG $FUNCNAME "started with $1"
    F_WAITBOX " ... checking if PORS data dir should be pushed"
    GITON=$(F_GETANSIBLEVAR git_pors_data_push)
    PERR=0

    if [ "$GITON" == "True" ];then
        F_WAITBOX " ... pushing PORS data directory changes"
        F_LOG $FUNCNAME "pushing data dir to git is enabled"
        cd $DATADIR
        git push >> $LOG 2>&1
        PERR=$?
        cd $ADIR
        F_PORSACTION "action log updated" "$FUNCNAME | pushed changes to remote git repo (ended with $PERR)"
    else
        F_LOG $FUNCNAME "skipping data dir push because it is set to ${GITON}. Consider setting 'git_pors_data_push: yes' in pors.yml"
    fi
    F_LOG $FUNCNAME "finished"
    return $PERR
}

## @fn F_PING()
## @brief Checks if a target answers to a ping
## @param 1 : the hostname or IP to ping (required)
## @return Exit code of the ping command (all non zero means the system cannot be reached)
F_PING(){
    F_LOG $FUNCNAME "started with $1"
    unset T
    T="$1"
    [ -z "$T" ] && return 3

    F_WAITBOX "... checking for $VMHOST ($VMIP)"

    ping -c 3 -W 2 $T >> $LOG 2>&1
    RET=$?
    F_LOG $FUNCNAME "finished with $RET"
    return $RET
}



########################################################################################################################################
########################################################################################################################################
########################################################################################################################################

## @fn F_MENUMAIN()
## @brief the main menu window of PORS in regular mode
F_MENUMAIN(){
    F_HOSTFILE
    F_VAULTPW
	MENUDONE=0
 	    while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --ok-label "Select Entry" --cancel-label "Exit" --colors \
			--menu "\nSelect an option:\n(pro tip: jump to an entry with the highlighted key shortcut)" \
			43 96 35 \
			'' '\Zb\ZuAPP MANAGEMENT\ZB\ZU'\
			"" "" \
			Link-app "Link an app (local file or git project) to a group" \
			Deploy-apps "Deploy linked apps for a target group" \
			Remove-app "Unlink or completely remove an app of a group" \
			Show-apps "Show all already linked apps" \
			"" "" \
			'' '\Zb\ZuMAINTENANCE\ZB\ZU' \
			"" "" \
                        "VM-Management" "Deploy and manage VMs" \
			shelper	"Execute splunk reload, apply DEP/MN/DS bundles, ..." \
			splunkd "splunk> daemon commands (restart, webrestart ,..)" \
			"" "" \
			'' '\Zb\ZuINSTALLATION / CONFIGURATION\ZB\ZU' \
			"" "" \
			'Install splunk'      "splunk> on ansible-ready server(s)" \
			'Install splunkforwarder'      "splunk> Universal forwarder on ansible-ready server(s)" \
			'Install logstream'	"cribl logstream-worker on ansible-ready server(s)" \
                        Configure "Configure splunk> on fresh installed splunk instances" \
			"" "" \
			'' '\Zb\ZuUPGRADE\ZB\ZU' \
			"" "" \
			"Upgrade/stage splunk"	"Download, upgrade, stage splunk>" \
			"Upgrade/install splunkhelper"	"Upgrade or install splunkhelper" \
			'Upgrade/stage splunkforwarder'      "Download, upgrade, stage splunk> Universal forwarder" \
			"Upgrade/stage logstream"	"Download, upgrade, stage cribl logstream" \
                        "Upgrade System" "the operating system of an ansible managed system" \
			"" "" \
			'' '\Zb\Zusystem/local/*.conf\ZB\ZU'\
			"" "" \
			"Edit system/local" "Fetch/Edit/Show/Manage remote conf files" \
			"Deploy system/local" "Deploy enabled system configs"\
			"" "" \
			"" "" \
			3>&1 1>&2 2>&3)

		if [ $? -ne 0 ]; then
                    [ -f "$VAULTTEMPFILE" ] && F_DATAPUSH
                    clear
		    echo -e "$0 closed on user request.. see you next time ;)\n"
                    F_LOG MAIN "$0 closed on user request"
                    return 4
		fi
		case "$SELECTION" in
			New-app)
                        F_LOG $FUNCNAME "F_TBD ended with $?"
			;;
			Link-app)
			F_ENAPP
                        F_LOG $FUNCNAME "F_ENAPP ended with $?"
			;;
			Deploy-apps)
			F_DEPLOYMENU
                        F_LOG $FUNCNAME "F_DEPLOYMENU ended with $?"
			;;
			Remove-app)
			F_RMAPP
                        F_LOG $FUNCNAME "F_RMAPP ended with $?"
			;;
			Show-apps)
			SELECTION=$(F_SELECTOR)
			F_GOAPPS
                        F_LOG $FUNCNAME "F_GOAPPS ended with $?"
			;;
			"Edit system/local")
			F_EDITSYSC
                        F_LOG $FUNCNAME "F_EDITSYSC ended with $?"
			;;
			"Deploy system/local")
			F_DEPLSYSC "$(F_SELECTOR)"
                        F_LOG $FUNCNAME "F_DEPLSYSC ended with $?"
			;;
			"Upgrade/stage splunk")
			F_UPGRADEMENU splunk
                        F_LOG $FUNCNAME "F_UPGRADEMENU ended with $?"
			;;
			"Upgrade splunkhelper")
			F_SHUPGRADE
                        F_LOG $FUNCNAME "F_UPGRADEMENU ended with $?"
			;;
			"Upgrade/stage splunkforwarder")
			F_UPGRADEMENU splunkforwarder
                        F_LOG $FUNCNAME "F_UPGRADEMENU ended with $?"
			;;
                        "Upgrade/stage logstream")
                        F_UPGRADEMENU logstream
                        F_LOG $FUNCNAME "F_UPGRADEMENU ended with $?"
                        ;;
			splunkd)
			F_SPLACT
                        F_LOG $FUNCNAME "F_SPLACT ended with $?"
			;;
			shelper)
			F_SHEXEC
                        F_LOG $FUNCNAME "F_SHEXEC ended with $?"
			;;
			'Install splunk')
			F_INSTALLSPL
                        F_LOG $FUNCNAME "F_INSTALLSPL ended with $?"
			;;
			'Install splunkforwarder')
			F_INSTALLSPL splunkforwarder
                        F_LOG $FUNCNAME "F_INSTALLSPL ended with $?"
			;;
			'Install logstream')
			F_INSTALLLOGSTREAM
                        F_LOG $FUNCNAME "F_INSTALLLOGSTREAM ended with $?"
			;;
			Cluster)
			F_CLUSTER
                        F_LOG $FUNCNAME "F_CLUSTER ended with $?"
			;;
                        VM-Deploy)
                        F_DEPLOYVM
                        F_LOG $FUNCNAME "F_DEPLOYVM ended with $?"
                        ;;
                        Configure)
                        F_CONFMENU
                        F_LOG $FUNCNAME "F_CONFMENU ended with $?"
                        ;;
                        VM-Management)
                        F_DEPLOYVM
                        F_LOG $FUNCNAME "F_VMMENU ended with $?"
                        ;;
                        "Upgrade System")
                        F_SYSUPGRADE
                        ;;
		esac
	     done
}

## @fn F_MENUTESTING()
## @brief the main menu window of PORS in testing mode
F_MENUTESTING(){
    F_HOSTFILE
    MENUDONE=0
    F_VAULTPW
	    while [ "$MENUDONE" == "0" ]; do
		SELECTION=$(F_DIALOG --colors --ok-label "Select Entry" --cancel-label "Exit" \
			--menu "\nStart Playbooks-On-Rails for Splunk (PORS) \n\n\Zb\Z1TESTING AREA - TESTING AREA - TESTING AREA\Zn\n\nSelect an option:" \
			25 76 25 \
			"" "" \
			3>&1 1>&2 2>&3)
		if [ "$?" != "0" ]; then
		    MENUDONE=1
		    echo "$0: finished."
		    F_EXIT
		fi
		case "$SELECTION" in
			Disable-app)
			;;
		esac
	     done

}

## @fn F_MENUADVANCED()
## @brief the main menu window of PORS in advanced mode
F_MENUADVANCED(){
	while [ "$MENUDONE" == "0" ]; do
                SELECTION=$(F_DIALOG --colors --ok-label "Select Entry" --cancel-label "Exit" \
                        --menu "\nStart \Playbooks-On-Rails for Splunk (PORS)n\n\Zb\Z1ADVANCED AREA - ADVANCED AREA - ADVANCED AREA\Zn\n\nSelect an option:" \
                        20 76 20 \
                        ______________ "ADVANCED (no daily business)  ______________" \
                        "" "" \
                        Pull-SYSC "Fetch config for a target (if Edit-SYSC fails)"\
                        gitlab  "(Re-)Initialize gitlab server authentication"\
                        3>&1 1>&2 2>&3)
                if [ "$?" != "0" ]; then
                    MENUDONE=1
                    echo "$0: finished."
		    F_EXIT
                fi
                case "$SELECTION" in
                        Pull-SYSC)
                        F_PULLSYSC
                        ;;
                esac
	done	
}

## @fn F_CHECKVERSION()
## @brief Checks for Ansible version and compares it with the required one
## @return exitcode depending on success (0) or not (3)
## @return output of detected Ansible version
## SO DO NOT ECHO ANYTHING ELSE HERE
F_CHECKVERSION(){
    # check ansible version
    unset AVERSF AVERS MAXAVERSION MREQAVERSION
    MREQAVERSION=$(echo $REQAVERSION |tr -d ".")
    if [ -f "$ABINX" ];then
        AVERSF=$(F_ABIN version |head -n 1 | egrep -o "[1-9]+\.[0-9]+\.[0-9]+") && AVERS=$(echo $AVERSF | tr -d ".")
    else
        F_LOG MAIN "ABIN: $ABIN missing!" && return 3
    fi
    F_LOG MAIN "Detected Ansible version: AVERS: $AVERS. Min required: $MREQAVERSION"

    [ "$AVERS" -lt "$MREQAVERSION" ] && F_LOG MAIN "No suitable Ansible version found!!! Required: $REQAVERSION Found: $AVERSF" && return 3
    MAXAVERSION=$AVERSF
    echo "$MAXAVERSION"
}

# ugly but efficient
echo "$@" | egrep -q "help"
[ $? -eq 0 ] && F_HELP && F_EXITUNCLEAN

# ensure we know the real user and deny starting PORS directly as SPLUSER or ROOT user
ME=$(id -un)
DENYSTART=0
if [ "$ME" == "$AEUSER" -a -z "$CALLUSR" ];then
    DENYSTART=1
else
    [ "$ME" == "root" ] && DENYSTART=1
fi
[ $DENYSTART -eq 1 ] && echo -e "\n\nERROR: Starting PORS as user $ME has been denied.\nPORS must be started as your REAL user since v2.3!\n\nSo .. login as your regular user and try again\n\n" && F_EXIT 4

if [ "$ME" != "$AEUSER" ] || [ -z "$CALLUSR" ];then
    echo "Thanks for choosing PORS $ME, starting PORS now ($@) ..."
    sudo -u $AEUSER /usr/bin/env CALLUSR=$ME $0 $@
    F_EXITUNCLEAN $?
fi

echo "starting PORS as user $ME"

####  pre-check Ansible reqs

# check ansible variable file existence
[ ! -f $HOME/.ansible.cfg ] && echo -e "\nERROR: missing $HOME/.ansible.cfg. Please ensure you have copied it from EXAMPLES/ansible.cfg\n\ne.g: cp EXAMPLES/ansible.cfg $HOME/.ansible.cfg\n" && exit 4

# ensure audit log dir exists
[ ! -d "$DATADIR/audit" ] && mkdir -p $DATADIR/audit

ABINX=$ABIN

cd $ADIR
 
echo "$@" | egrep -q "(noninteractive|batch)"
if [ $? -eq 0 ];then
   # enter non-interactive/batch mode
    export LOG=$LOGDIR/$(date +%F_%H-%M)_${BIN}_batchmode.log
    rm $LOGDIR/${BIN}_batchmode.log
    ln -s $LOG $LOGDIR/${BIN}_batchmode.log
    F_LOGROTATE
    # reset any previous set user host file
    > $AEUSRHOSTFILE

    # Ansible version check
    export MAXAVERSION=$(F_CHECKVERSION)
    LASTERR=$?
    if [ $LASTERR -ne 0 ] || [ -z "$MAXAVERSION" ];then
        F_LOG $FUNCNAME "ended with $LASTERR, detected Ansible version: >$MAXAVERSION<" && F_EXIT $LASTERR
    fi
    F_LOG MAIN "PYTHONPATH: $PYTHONPATH"

    export RUNMODE=batch
    export BDEPAPPSUBSET=0
    unset BATCHACT

    # parse args
    while [ ! -z "$1" ];do
        case "$1" in
	    -1) BABIN=$ABIN ;shift;;
            --batch|--noninteractive) shift;;
	    -p|--play) BPLAY="$2"; shift 2;;
	    --playargs) BPLAYARGS="$2"; shift 2;;
            -F|--function|--func) BFUNC="$?"; shift 2;;
            --funcargs) BFUNCARGS="$?"; shift 2;;
            -a|--action) BACT="$2"; shift 2;;
	    -t|--target) BTARGET="$2"; shift 2;;
            -i|--inventory) export HOSTFILE="$2"; export SHOSTFILE="$HOSTFILE"; FORCEDHOSTFILE="$2"; shift 2;;
            --env) TARGETENV=$2; shift 2 ;;
            --site) TARGETSITE="$2"; shift 2 ;;
            --deployapp)
            export BDEPAPP="$2"
            export BDEPAPPSUBSET=1
            shift 2
            ;;
            --vault-password-file)
            declare VAULTTEMPFILE="$2"
            shift 2
            [ ! -f $VAULTTEMPFILE ] && F_LOG MAIN "ERROR: $VAULTTEMPFILE does not exist!" \
                && echo "ERROR: $VAULTTEMPFILE does not exist!" \
                && F_EXIT 99
            unset A2VAULTARG
            declare A2VAULTARG="--vault-password-file $VAULTTEMPFILE"
            declare ABIN="$ABIN ${A2VAULTARG}"
            declare VBINX=$VBIN
            declare VBIN="$VBIN ${A2VAULTARG}"
            #echo "ABIN: $ABIN, VBIN: $VBIN"
            ;;
            -pa|--post-action)
            export BATCHACT="$2"
            shift 2
            ;;
            --verbose)
            export PLAYNOISE="-vvv"
            shift
            ;;
            --debug)
            export PLAYNOISE="-vvvv"
            shift
            ;;
	    *) echo -e "ERROR unknown argument: $1\n"; F_EXIT ;;
        esac
    done
   # validate args
   for f in $HOSTFILE $BPLAY; do
	if [ ! -f $f ];then
	  echo "ERROR missing file: >$f<"
	  F_EXIT 4
	fi
   done
   [ -z "$BTARGET" -o -z "$HOSTFILE" ] && echo -e "ERROR: missing a required arg\n(target:$BTARGET,hosts:$HOSTFILE)!" && F_EXIT 4
   [ -z "$BACT" -a -z "$BPLAY" ] && echo -e "ERROR: Either action or play must be defined (action: $BACT, play: $BPLAY)!" && F_EXIT 4

    ## @var EXECBIT
    ## @brief execution lock file based on the target environment
    ## @showinitializer
    ## @details A simple lock file to detect an already running PORS session.
    ## Makes use of the selected environment so you are able to run e.g. prod and dev the same time
    declare EXECBIT=/tmp/.pors_batch_${TARGETENV}.lock

   # detect running session and kill/ask
   [ -f $EXECBIT ] && echo -e "\n\nWARNING: It seems PORS is already running by user: $(cat $EXECBIT)! ABORTED!" && F_LOG "$BIN" "PORS is already running by $(cat $EXECBIT). ABORTED!" && F_EXIT 4
    echo "$CALLUSR" > $EXECBIT && chmod o+w $EXECBIT

    ## @var PORS_TEMPDIR
    ## @brief Temporary directory defined within ansible config
    ## @details ..
    ## @showinitializer
    declare PORS_TEMPDIR=$(grep pors_temp_dir $AINVENTORY/$TARGETENV/group_vars/all/pors.yml | cut -d ":" -f 2)

    # check uncommitted changes & commit if needed
    F_DATACOMMIT "manual changes" "data directory has been altered outside of PORS - committed the current state before actually starting.."

   # run
    if [ "$BPLAY" ];then
        F_LOG MAIN "$ABIN -i $HOSTFILE $BPLAY -e \"target=$BTARGET accept_hostkey=true $BPLAYARGS\""
        $ABIN -i $HOSTFILE $BPLAY -e "target=$BTARGET accept_hostkey=true $BPLAYARGS $TARGETSITE" $PLAYNOISE >> $LOG 2>&1
    else
        if [ "$BFUNC" ];then
            F_LOG MAIN ".. will exec $BFUNC. Args: $BFUNCARGS"
            $BFUNC $BFUNCARGS
        else
            case $BACT in
                deploy)
                export DEPLOYAPPSUBSET=$BDEPAPPSUBSET 
                F_DEPLOYAPP >> $LOG 2>&1
                DEPERR=$?
                [ $DEPERR -ne 0 ] && F_LOG MAIN "deploying ended with $DEPERR" && F_EXIT $DEPERR
                if [ ! -z "$BATCHACT" ];then
                    F_LOG "$BIN" "activating changes..."
                    F_SHEXEC >> $LOG 2>&1
                    F_EXIT $?
                fi
                ;;
                *)
                echo "ERROR: Action $BACT does not exists!"
                exit 3
                ;;
            esac
        fi
    fi
else
    unset A2VAULTARG
    [ "$ENABLEVAULT" == "yes" ] \
    && declare A2VAULTARG="--vault-password-file $VAULTTEMPFILE" \
    && declare ABIN="$ABIN ${A2VAULTARG}" \
    && declare VBINX=$VBIN \
    && declare VBIN="$VBIN ${A2VAULTARG}"

    # interactive mode
    MENUDONE=0
    F_LOGROTATE
    # reset any previously set user host file
    > $AEUSRHOSTFILE

    # Ansible version check
    export MAXAVERSION=$(F_CHECKVERSION)
    LASTERR=$?
    if [ $LASTERR -ne 0 ] || [ -z "$MAXAVERSION" ];then
        F_LOG $FUNCNAME "ended with $LASTERR, detected Ansible version: >$MAXAVERSION<" && F_EXIT $LASTERR
    fi

    while [ ! -z "$1" ]; do
      case "$1" in
	--advanced)
	MAINMENU=F_MENUADVANCED
	shift
	;;
	--testing)
	MAINMENU=F_MENUTESTING
	shift
	;;
	--env)
	export TARGETENV=$2
	shift 2
	;;
        -i|--inventory)
        export FORCEDHOSTFILE="$2"
        shift 2
        ;;
        --stealth)
        export STEALTHMODE=1
        shift
        ;;
        --verbose)
        export PLAYNOISE="-vvv"
        shift
        ;;
        --debug)
        export PLAYNOISE="-vvvv"
        shift
        ;;
	*)
	F_HELP
	F_EXIT
	;;
      esac
    done
    # support multiple environments
    while [ -z "$TARGETENV" ];do
	TARGETENV=$(F_CHOOSEENV)
        [ "$TARGETENV" == "ABORTED" ] && F_EXIT
    done

    [ ! -d "$AINVENTORY/$TARGETENV" ] && echo -e "\nERROR: specified environment $TARGETENV\n($AINVENTORY/$TARGETENV)\ndoes not exist!" && F_HELP && F_EXIT

    ## @var EXECBIT
    ## @brief execution lock file based on the target environment
    ## @showinitializer
    ## @details A simple lock file to detect an already running PORS session.
    ## Makes use of the selected environment so you are able to run e.g. prod and dev the same time
    declare EXECBIT=/tmp/.pors_${TARGETENV}.lock

    # detect running session and kill/ask
    if [ -z "$STEALTHMODE" ];then
        NONE='\033[00m'
        RED='\033[01;31m'
        [ -f "$EXECBIT" ] && echo -e "\n\t${RED}WARNING - WARNING\n\t-----------------------${NONE}\n\n\tIt seems PORS is already opened by \n\n${RED}\t\t>  $(cat $EXECBIT)  <${NONE}\n\n\tBEFORE you choose overwriting the lock ${RED}contact the above user!${NONE}\n\tPORS does not support working in parallel so this WILL break things if you try to proceed while another user is actively working!\n\n" && read -p "....... do you want ME to override, delete the execbit and continue anyways (no risk no fun heh?)? (y/N)" KICKUSER
        echo KICK: $KICKUSER
        [ -f "$EXECBIT" ]&&[ "$KICKUSER" != "y" ] && F_EXITUNCLEAN
        echo "$CALLUSR" > $EXECBIT && chmod 777 $EXECBIT
        # check uncommitted changes & commit if needed
        F_DATACOMMIT "manual changes" "data directory has been altered outside of PORS - committed the current state before actually starting.."
    else
        F_LOG START "running in STEALTH MODE!!!"
        declare LOG="${WORKDIR}/$(date +%F_%H-%M)_${BIN}-stealthmode.log"
    fi

    ## @var DEFAULTVAULT
    ## @brief full path to the default vault
    ## @details This is used to check the typed password so it must exists (if using ENABLEVAULT=yes)
    ## @showinitializer
    declare DEFAULTVAULT=$AINVENTORY/$TARGETENV/group_vars/all/vault.yml

    ## @var PORS_TEMPDIR
    ## @brief Temporary directory defined within ansible config
    ## @details ..
    ## @showinitializer
    declare PORS_TEMPDIR=$(grep pors_temp_dir $AINVENTORY/$TARGETENV/group_vars/all/pors.yml | cut -d ":" -f 2)

    # pre-setup DATADIR
    DATADIRS="$DATADIR/custom/roles $DATADIR/custom/playbooks"
    for d in $DATADIRS;do [ ! -d "$d" ] && mkdir -p $d;done
    [ ! -d "$DATADIR/custom/roles/defaults" ] && ln -s $ADIR/roles/defaults $DATADIR/custom/roles/ && F_LOG $FUNCNAME "created roles/defaults in data dir"

    END=0
    while [ $END -eq 0 ];do
        [ -z "$MAINMENU" ]&& MAINMENU=F_MENUMAIN
        $MAINMENU
        END=$?
        [ $END -eq 4 ] && F_LOG MAIN ".. goodbye!"
    done
fi

F_EXIT $?
